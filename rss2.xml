<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Rabbit blog</title>
    <link>http://yunpc.github.io/</link>
    
    <atom:link href="http://yunpc.github.io/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description></description>
    <pubDate>Wed, 21 Apr 2021 14:10:33 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>noreferrer</title>
      <link>http://yunpc.github.io/2021/04/21/noreferrer/</link>
      <guid>http://yunpc.github.io/2021/04/21/noreferrer/</guid>
      <pubDate>Wed, 21 Apr 2021 13:53:37 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;링크-타입-noreferrer&quot;&gt;링크 타입 : noreferrer&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;noreferrer&lt;/code&gt;는 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;area&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;f</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="링크-타입-noreferrer">링크 타입 : noreferrer</h1><p><code>noreferrer</code>는 <code>&lt;a&gt;</code>, <code>&lt;area&gt;</code>, <code>&lt;form&gt;</code>의 <code>rel</code> 속성에 쓰는 속성 값이다. 타겟 브라우저로 이동할 때 원 브라우저에 대한 정보(Referer)를 제공하지 않는다. 레퍼러를 제공하지 않기 때문에 새 탭으로 인한 보안 문제가 해결된다. 이런 면에서는 <code>noopener</code>가 쓰인 것과 같은 효과를 볼 수 있다.</p>]]></content:encoded>
      
      
      <category domain="http://yunpc.github.io/categories/HTML-CSS/">HTML/CSS</category>
      
      <category domain="http://yunpc.github.io/categories/HTML-CSS/Docs/">Docs</category>
      
      <category domain="http://yunpc.github.io/categories/HTML-CSS/Docs/MDN/">MDN</category>
      
      
      
      <comments>http://yunpc.github.io/2021/04/21/noreferrer/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>nooopener</title>
      <link>http://yunpc.github.io/2021/04/21/noopener/</link>
      <guid>http://yunpc.github.io/2021/04/21/noopener/</guid>
      <pubDate>Wed, 21 Apr 2021 12:14:22 GMT</pubDate>
      
        
        
      <description>&lt;h1 id=&quot;링크-타입-noopener&quot;&gt;링크 타입: noopener&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;noopener&lt;/code&gt;란 &lt;code&gt;a&lt;/code&gt;, &lt;code&gt;area&lt;/code&gt;, &lt;code&gt;form&lt;/code&gt;태그의 &lt;code&gt;rel&lt;/co</description>
        
      
      
      
      <content:encoded><![CDATA[<h1 id="링크-타입-noopener">링크 타입: noopener</h1><p><code>noopener</code>란 <code>a</code>, <code>area</code>, <code>form</code>태그의 <code>rel</code>속성에 들어가는 속성 값이다. 이 값은 새로운 창이 열려있을 때, 기존에 브라우징 되어있는 요소에 접근할 수 없도록 한다.</p><blockquote><p>A브라우저에서 링크를 타고 B브라우저를 새탭에서 열었을 경우 <code>Window.opener</code>라는 객체가 생기는데, 이걸 통해 B브라우저가 A브라우저를 악의적으로 동작하게 만들 수 있기 때문에 <code>noopener</code>는 이 객체를 생성하지 않고 널값을 반환한다.</p></blockquote><p>이 값은 특히 신뢰할 수 없는 사이트에 들어갈 때 유용하다. 이 값을 사용하면 <code>Window.opener</code>를 통해서 현재 브라우저에 접근할 수 있는 통로를 차단한다. (이 값을 사용한다는 기본 전제는 <code>Referer</code>HTTP 헤더를 사용한다는 것이다. 리퍼러는 사용자가 어디에서 새 브라우저로 왔는지 url에 보여준다. 이 정보가 명확히 있기 때문에 <code>Window.opener</code>에서 조작할 수 있는건데, <code>noreferrer</code>를 사용한다면 애초에 어디서부터 왔는지 보이지 않기 때문에 <code>noopener</code>를 사용할 이유가 없어진다.)</p><p><code>noopener</code>를 사용할 경우 <code>_top</code>, <code>_self</code>, <code>_parent</code>가 모두 <code>_blank</code>처럼 사용된다.(새탭으로 무조건 여는 것은 아니고 새로운 탭으로 열지 말지를 물어본다. 이 부분은 예제를 해봐야겠다.)</p><blockquote><p>현재 <code>target="_blank"</code>를 <code>&lt;a&gt;</code>태그에 사용하면 이 값이 암묵적으로 적용된다.</p></blockquote>]]></content:encoded>
      
      
      <category domain="http://yunpc.github.io/categories/HTML-CSS/">HTML/CSS</category>
      
      <category domain="http://yunpc.github.io/categories/HTML-CSS/Docs/">Docs</category>
      
      <category domain="http://yunpc.github.io/categories/HTML-CSS/Docs/MDN/">MDN</category>
      
      
      
      <comments>http://yunpc.github.io/2021/04/21/noopener/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>가사 검색</title>
      <link>http://yunpc.github.io/2021/04/09/Song-Search/</link>
      <guid>http://yunpc.github.io/2021/04/09/Song-Search/</guid>
      <pubDate>Fri, 09 Apr 2021 01:32:31 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;문제정의&quot;&gt;문제정의&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;가사에 사용된 모든 단어들이 담긴 배열 &lt;code&gt;words&lt;/code&gt;에서 &lt;code&gt;queries&lt;/code&gt;에 해당되는 단어가 몇 개가 있는지 반환하는 문제이다. &lt;code&gt;querie</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="문제정의">문제정의</h2><hr /><p>가사에 사용된 모든 단어들이 담긴 배열 <code>words</code>에서 <code>queries</code>에 해당되는 단어가 몇 개가 있는지 반환하는 문제이다. <code>queries</code>에는 와일드 카드 <code>?</code>가 하나 이상 존재하며, 이 와일드 카드는 문자의 앞부분을 차지하거나 뒷부분만을 차지한다(<code>fr?do</code>와 같은 형식이 없다.).</p><p><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvNjAwNjA=">문제 링크<i class="fa fa-external-link-alt"></i></span></p><h2 id="문제풀이">문제풀이</h2><hr /><p>trie 자료구조를 이용하여 문제를 풀 수 있다. 이번에는 다른 분의 핵심 아이디어를 듣고 코드로 구현하였다. 코드는 아래와 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">words, queries</span>):</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value=<span class="literal">None</span></span>):</span></span><br><span class="line">            self.value = value</span><br><span class="line">            self.child = <span class="built_in">dict</span>()</span><br><span class="line">            self.len_dict = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">            self.root = Node()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, value:<span class="built_in">str</span></span>):</span></span><br><span class="line">            node = self.root</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> value:</span><br><span class="line">                <span class="comment"># add dictionary for wildcard</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(value) <span class="keyword">not</span> <span class="keyword">in</span> node.len_dict:</span><br><span class="line">                    node.len_dict[<span class="built_in">len</span>(value)] = <span class="number">0</span></span><br><span class="line">                node.len_dict[<span class="built_in">len</span>(value)] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> node.child: <span class="comment"># There is no child</span></span><br><span class="line">                    new_node = Node(c)</span><br><span class="line">                    node.child[c] = new_node</span><br><span class="line">                    node = new_node</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node = node.child[c]</span><br><span class="line">            node.child[<span class="string">&#x27;*&#x27;</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, queri</span>):</span></span><br><span class="line">            node = self.root</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> queri:</span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> node.len_dict[<span class="built_in">len</span>(queri)] <span class="keyword">if</span> <span class="built_in">len</span>(queri) <span class="keyword">in</span> node.len_dict <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">in</span> node.child:</span><br><span class="line">                    node = node.child[c]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># def print(self):</span></span><br><span class="line">        <span class="comment">#     node = self.root</span></span><br><span class="line">        <span class="comment">#     queue = []</span></span><br><span class="line">        <span class="comment">#     queue.append(node)</span></span><br><span class="line">        <span class="comment">#     while queue:</span></span><br><span class="line">        <span class="comment">#         root = queue[0]</span></span><br><span class="line">        <span class="comment">#         del queue[0]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#         if root.value is not None:</span></span><br><span class="line">        <span class="comment">#             print(root.value, end = &quot; &quot;)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#         if  &#x27;*&#x27; in root.child:</span></span><br><span class="line">        <span class="comment">#             print(&#x27;*&#x27;)</span></span><br><span class="line">        <span class="comment">#             continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#         for node in root.child.values():</span></span><br><span class="line">        <span class="comment">#             queue.append(node)</span></span><br><span class="line">    </span><br><span class="line">    reversed_words = [word[::-<span class="number">1</span>] <span class="keyword">for</span> word <span class="keyword">in</span> words]</span><br><span class="line"></span><br><span class="line">    trie = Trie()</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        trie.add(word)</span><br><span class="line"></span><br><span class="line">    reversed_trie = Trie()</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> reversed_words:</span><br><span class="line">        reversed_trie.add(word)</span><br><span class="line"></span><br><span class="line">    answer = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> queri <span class="keyword">in</span> queries:</span><br><span class="line">        <span class="keyword">if</span> queri[<span class="number">0</span>] == <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">            answer.append(reversed_trie.search(queri[::-<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer.append(trie.search(queri))</span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><p>일단 Trie에 대해서 알아야 하는데 이에 대한 <span class="exturl" data-url="aHR0cHM6Ly9ob29vbmdzLnRpc3RvcnkuY29tLzI4">링크<i class="fa fa-external-link-alt"></i></span>를 첨부해 두었으니 참고하면 좋을 것 같다. 이에 대해 안다고 가정하고 설명을 진행한다.</p><p>이 문제에서 제한 시간내에 문제를 풀기 위한 핵심 요소는 와일드 카드의 사용이다. 문자 사이에 와일드 카드가 올 일은 없기 때문에 만약 접미사가 와일드 카드이면 더 이상 Trie를 탐색하지 않도록 해야 문제가 풀린다.</p><p>이를 풀기 위해 <code>len_dict</code>를 생성하였다. <code>len_dict</code>는 해당 노드에서 뻗어나가는 단어들을 길이에 따라 몇 개의 단어가 있는지 알려주는 딕셔너리이다. 문제 테스트 케이스에 대해 len_dict를 그려보자면 다음과 같다.</p><figure><img src="/images/programmers/trie.jpeg" alt="Trie와 len_dict" /><figcaption aria-hidden="true">Trie와 len_dict</figcaption></figure><p>그림을 보면 root에 5글자를 가진 단어 5개 6글자를 가진 단어 1개를 표시해두고 아래로 뻗어 나가면서 각자의 위치에 자신의 하위 위치에 있는 단어들의 개수를 길이에 따라 저장해둔 것을 볼 수 있다. 이런식으로 했을때 만약 <code>fro??</code>와 같은 쿼리가 들어오면 o까지만 순회를 하고 5를 key값으로 하는 value 3을 리턴해주면 된다.</p><p>이렇게 하면 해결하지 못하는 케이스가 여전히 있는데 바로 와일드 카드가 앞쪽에 붙는 경우다. 이렇게 하면 모든 단어를 순회해봐야 알 수 있게 되기 때문에 역시나 효율성에서 애를 먹는다. 이를 해결하는 방법은 간단한다. 단어를 거꾸로 하여 새로운 Trie를 만들고 쿼리도 역으로 하여 <code>search</code>를 진행하면 된다.</p><p>시간복잡도를 계산하자면, words의 길이를 n, 개수를 m이라 하면 trie를 생성하는데에 <span class="math inline">\(O(nm)\)</span>이 든다. 이를 만들고 쿼리를 진행하므로 <code>queries</code>의 길이를 q라하고 개수를 p라하면, <span class="math inline">\(O(pq)\)</span>만큼 소요된다. 따라서 최종 시간복잡도는 <span class="math inline">\(O(nm) + O(pq)\)</span>이다.</p><p>너무 시간복잡도가 어마어마하게 느껴질 수도 있지만, 와일드카드와 단어간의 중첩이 있어 실질적인 시간은 좀 더 짧다고 생각한다.</p><h2 id="테스트">테스트</h2><p><br></p><figure><img src="/images/programmers/song_search.png" alt="테스트 화면" /><figcaption aria-hidden="true">테스트 화면</figcaption></figure><p><br></p>]]></content:encoded>
      
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/">Problem Solving</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/">Programmers</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/Level4/">Level4</category>
      
      
      
      <comments>http://yunpc.github.io/2021/04/09/Song-Search/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>평범한 배낭</title>
      <link>http://yunpc.github.io/2021/04/06/Knapsack/</link>
      <guid>http://yunpc.github.io/2021/04/06/Knapsack/</guid>
      <pubDate>Tue, 06 Apr 2021 12:06:36 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;문제정의&quot;&gt;문제정의&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;0-1 knapsack 문제이다.&lt;/p&gt;
&lt;h2 id=&quot;문제풀이&quot;&gt;문제풀이&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;이번에는 내 코드와 강사님이 최적화를 거친 코드를 단계로 보며 DP에 대해 정리하려고 한</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="문제정의">문제정의</h2><hr /><p>0-1 knapsack 문제이다.</p><h2 id="문제풀이">문제풀이</h2><hr /><p>이번에는 내 코드와 강사님이 최적화를 거친 코드를 단계로 보며 DP에 대해 정리하려고 한다. 일단 필자의 코드는 아래와 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">N, K = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>))</span><br><span class="line"></span><br><span class="line">values = []</span><br><span class="line">weights = []</span><br><span class="line"></span><br><span class="line">max_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    w, v = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    values.append(v)</span><br><span class="line">    weights.append(w)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knapsack</span>(<span class="params">values, weights, n, W</span>):</span></span><br><span class="line">    <span class="keyword">if</span> W &lt;= <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n-<span class="number">1</span>, W) <span class="keyword">in</span> max_dict:</span><br><span class="line">        <span class="keyword">return</span> max_dict[(n-<span class="number">1</span>, W)]</span><br><span class="line"></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> W &gt;= weights[n-<span class="number">1</span>]:</span><br><span class="line">        res =  <span class="built_in">max</span>(knapsack(values, weights, n-<span class="number">1</span>, W), </span><br><span class="line">        knapsack(values, weights, n-<span class="number">1</span>, W-weights[n-<span class="number">1</span>]) + values[n-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res = knapsack(values, weights, n-<span class="number">1</span>, W)</span><br><span class="line"></span><br><span class="line">    max_dict[(n-<span class="number">1</span>, W)] = res</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(knapsack(values, weights, N, K))</span><br></pre></td></tr></table></figure><p>재귀를 이용한 구현이다. 가용치를 <code>W</code>라하고, <code>n</code>을 넣을 물건의 고유번호라고 생각하면, 이 둘이 0일 때 반환하는 값은 0이다.</p><p>계산했던 값을 저장하기 위해 <code>max_dict</code> 딕셔너리를 이용하였다. 여기에 들어가는 키 값은 물건의 고유번호와 가용치가 묶인 튜플이다. 값으로는 최대가치를 반환한다.</p><p>이 값이 만약에 존재한다면 계산 해뒀던 값이므로 이 값을 반환한다. 그렇지 않은 경우 값을 새로 계산하여야 한다. 만약 가용치안에 현재 물건이 들어갈 수 있다면, 들어간 경우와 그렇지 않은 경우를 모두 고려하여 값을 계산한다.</p><p>가용치안에 물건이 들어갈 수 없다면 없는 경우만 고려하면 된다. 이 때 계산한 값을 딕셔너리에 저장하는 것을 잊지말자!</p><p>백준에 결과를 돌려보면 다음과 같다.</p><figure><img src="/images/baekjoon/12865.png" alt="테스트 화면" /><figcaption aria-hidden="true">테스트 화면</figcaption></figure><p>이제 여기서 최적화를 한 단계씩 해나갈 수 있다. 기존의 Top-down방식을 Bottom-up으로 구성하면 코드는 다음과 같이 변경할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">N, K = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>.split())</span><br><span class="line"></span><br><span class="line">W = [<span class="number">0</span>] * (N + <span class="number">1</span>)</span><br><span class="line">V = [<span class="number">0</span>] * (N + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">    W[i], V[i] = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>.split())</span><br><span class="line"></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(K+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, K+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> w &gt;= W[i]:</span><br><span class="line">            dp[i][w] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][w], dp[i-<span class="number">1</span>][w-W[i]] + V[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][w] = dp[i-<span class="number">1</span>][w]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dp[N][K]) </span><br></pre></td></tr></table></figure><p><code>dp</code>라는 2차원 리스트를 만들어서 <code>i</code>번째 물건을 가중치 <code>W</code>에 따라 넣는 경우와 넣지 않는 경우, 넣지 못하는 경우를 전부 기록한다.</p><figure><img src="/images/baekjoon/12865-1.png" alt="테스트 화면" /><figcaption aria-hidden="true">테스트 화면</figcaption></figure><p>위와 비교하여 메모리도 늘고 시간도 늘었다. 실은 이건 재귀에 비하면 느릴 수 있는게 애초에 2차원 배열의 모든 요소를 사용하지 않기 때문에 메모리 낭비가 있기 때문이다. 그리고 표의 모든 요소를 채우기 때문에 시간도 그만큼 오래 걸린다. 하지만 재귀같은 경우 998번이 넘는 호출을 할수가 없기 떄문에 데이터 값이 큰 경우 재귀는 사용하기 어렵기 때문에 이걸 알아놔야 한다.</p><p>여기서 보이는 개선 방안은 크게 두가지 이다.</p><ol type="1"><li>공간의 낭비</li><li>표의 모든 요소를 계산할 필요가 없는 것</li></ol><p>이 두가지를 최적화 시켜나가려고 한다. 일단 공간적인 면에서 최적화를 시켜보자. 코드를 자세히 보면 점화식을 사용하는 부분에서 <code>i-1</code>번째 줄만 사용하는 것을 볼 수 있다. 그럼 그 이전의 행은 더 이상 쓸 일이 없으므로 이 부분에 대해서 최적화를 하면 다음과 같은 코드로 변경할 수 있다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">N, K = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">W = [<span class="number">0</span>] * (N + <span class="number">1</span>)</span><br><span class="line">V = [<span class="number">0</span>] * (N + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">    W[i], V[i] = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(K+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, K+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> w &gt;= W[i]:</span><br><span class="line">            dp[i%<span class="number">2</span>][w] = <span class="built_in">max</span>(dp[(i-<span class="number">1</span>)%<span class="number">2</span>][w], dp[(i-<span class="number">1</span>)%<span class="number">2</span>][w-W[i]] + V[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i%<span class="number">2</span>][w] = dp[(i-<span class="number">1</span>)%<span class="number">2</span>][w]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dp[N%<span class="number">2</span>][K]) </span><br></pre></td></tr></table></figure><p>i값에 따라 번갈아 가면서 값을 쓸 수 있도록 하였다.</p><figure><img src="/images/baekjoon/12865-2.png" alt="테스트 화면" /><figcaption aria-hidden="true">테스트 화면</figcaption></figure><p>연산 횟수는 다르지 않기 때문에 걸리는 시간은 그대로지만, 메모리 사용량이 크게 준 것을 확인하였다.</p><p>여기서 이제 2번에 대한 최적화를 추가로 할 수 있다. 연산량을 줄이는 것인데, 재귀로 코드를 짰을 때 호출되는 <code>w</code> 값을 계산하여 이를 저장하고 for문에서 이 값들에 대한 계산만 하면 최적화를 할 수 있다.</p><p>코드는 아래와 같다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">N, K = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">W = [<span class="number">0</span>] * (N + <span class="number">1</span>)</span><br><span class="line">V = [<span class="number">0</span>] * (N + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">    W[i], V[i] = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">need_calc = [<span class="built_in">set</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">need_calc[N].add(K)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> need_calc[i]:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> w == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> w &gt;= W[i]:</span><br><span class="line">            need_calc[i-<span class="number">1</span>].add(w-W[i])</span><br><span class="line">        need_calc[i-<span class="number">1</span>].add(w)</span><br><span class="line"></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(K + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> need_calc[i]:</span><br><span class="line">        <span class="keyword">if</span> w &gt;= W[i]:</span><br><span class="line">            dp[i%<span class="number">2</span>][w] = <span class="built_in">max</span>(dp[(i-<span class="number">1</span>)%<span class="number">2</span>][w], dp[(i-<span class="number">1</span>)%<span class="number">2</span>][w-W[i]] + V[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i%<span class="number">2</span>][w] = dp[(i-<span class="number">1</span>)%<span class="number">2</span>][w]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dp[N%<span class="number">2</span>][K])</span><br></pre></td></tr></table></figure><p>첫번째 for문을 주목하자. 우리는 이미 점화식을 통해 계산해야 하는 <code>w</code>값을 알 수 있다. 그래서 초기에 최종 가용치만을 넣어두고 여기에서 두 경우(선택하는 경우와 하지 않는 경우)로 나누어서 계산에 쓰이는 <code>w</code>값만 <code>need_calc</code>에 넣는다.</p><figure><img src="/images/baekjoon/12865-3.png" alt="테스트 화면" /><figcaption aria-hidden="true">테스트 화면</figcaption></figure><p>오버헤드가 없기 때문에 시간이 재귀보다 단축한 것을 볼 수 있다. 이렇게 최적화 과정에 대해 공부하였는데, 공부를 많이 해야겠다는 생각이 든다. 기죽지 말고 꾸준히 공부해야겠다. ✍️</p>]]></content:encoded>
      
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/">Problem Solving</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Beakjoon/">Beakjoon</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Beakjoon/12000-12999/">12000-12999</category>
      
      
      
      <comments>http://yunpc.github.io/2021/04/06/Knapsack/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>도둑질</title>
      <link>http://yunpc.github.io/2021/04/06/Stolen/</link>
      <guid>http://yunpc.github.io/2021/04/06/Stolen/</guid>
      <pubDate>Tue, 06 Apr 2021 12:05:29 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;문제정의&quot;&gt;문제정의&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;인접한 집을 털지 않으면서 최대한 많은 돈을 도둑질하는 문제이다. 이 때 집은 원형으로 이어져 있다고 가정하기 때문에 첫번째 인덱스와 마지막 인덱스가 이어져있다. &lt;span class=&quot;ex</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="문제정의">문제정의</h2><hr /><p>인접한 집을 털지 않으면서 최대한 많은 돈을 도둑질하는 문제이다. 이 때 집은 원형으로 이어져 있다고 가정하기 때문에 첫번째 인덱스와 마지막 인덱스가 이어져있다. <span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvNDI4OTc=">문제 링크<i class="fa fa-external-link-alt"></i></span></p><h2 id="문제풀이">문제풀이</h2><hr /><p>전체 코드는 다음과 같다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">money</span>):</span></span><br><span class="line">    dp1 = [<span class="number">0</span>] * (<span class="built_in">len</span>(money)-<span class="number">1</span>)</span><br><span class="line">    dp1[<span class="number">0</span>] = money[<span class="number">0</span>]</span><br><span class="line">    dp1[<span class="number">1</span>] = <span class="built_in">max</span>(money[<span class="number">0</span>], money[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(money)-<span class="number">1</span>):</span><br><span class="line">        dp1[i] = <span class="built_in">max</span>(dp1[i-<span class="number">1</span>], money[i]+dp1[i-<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    dp2 = [<span class="number">0</span>] * <span class="built_in">len</span>(money)</span><br><span class="line">    dp2[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp2[<span class="number">1</span>] = money[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(money)):</span><br><span class="line">        dp2[i] = <span class="built_in">max</span>(dp2[i-<span class="number">1</span>], money[i]+dp2[i-<span class="number">2</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp1[-<span class="number">1</span>], dp2[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p><p>집이 원형으로 이어져있을 때의 조건을 생각하지 못해서 결국 풀이를 봤다. 결론적으로 말하면 첫번째집과 마지막집은 동시에 선택하지 못한다! 그래서 이 경우를 둘로 나눠서 생각한다.</p><ol type="1"><li>마지막 집을 제외하고 도둑질 할 수 있는 최대 금액을 찾는다.</li><li>첫번째 집을 제외하고 도둑질 할 수 있는 최대 금액을 찾는다.</li><li>위의 두 값 중에서 큰 값을 반환한다.</li></ol><p>이렇게 하면 겹치는 케이스가 존재할 수 있지만 적어도 피하려고 하는 케이스만을 제외하고 나머지 경우의 수를 다 구할 수 있다.</p><p>시간 복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p><h2 id="테스트">테스트</h2><p><br></p><figure><img src="/images/programmers/stolen.png" alt="테스트 화면" /><figcaption aria-hidden="true">테스트 화면</figcaption></figure><p><br></p><p>DP는 너무 어렵다.. 유형중에 제일 해보지 않아서 어색하다. 백준에서 DP문제만 골라 풀어봐야겠다.</p>]]></content:encoded>
      
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/">Problem Solving</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/">Programmers</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/Level4/">Level4</category>
      
      
      
      <comments>http://yunpc.github.io/2021/04/06/Stolen/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>2xn 타일링(파이썬)</title>
      <link>http://yunpc.github.io/2021/04/06/2Tiling/</link>
      <guid>http://yunpc.github.io/2021/04/06/2Tiling/</guid>
      <pubDate>Tue, 06 Apr 2021 12:05:13 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;문제정의&quot;&gt;문제정의&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;가로 길이가 2이고 세로의 길이가 1인 직사각형 모양의 타일이 있다. 이 타일로 2*n바닥을 덮을 수 있는 경우의 수를 구하는 문제이다.&lt;/p&gt;
&lt;h2 id=&quot;문제풀이&quot;&gt;문제풀이&lt;/h2&gt;
&lt;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="문제정의">문제정의</h2><hr /><p>가로 길이가 2이고 세로의 길이가 1인 직사각형 모양의 타일이 있다. 이 타일로 2*n바닥을 덮을 수 있는 경우의 수를 구하는 문제이다.</p><h2 id="문제풀이">문제풀이</h2><hr /><p>전체 코드는 다음과 같다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n</span>):</span></span><br><span class="line">    answer = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    fn, fn_1 = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">        fn, fn_1 = fn_1, fn+fn_1</span><br><span class="line">        fn %= <span class="number">1000000007</span></span><br><span class="line">        fn_1 %= <span class="number">1000000007</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fn % <span class="number">1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(solution(<span class="number">4</span>))</span><br></pre></td></tr></table></figure> 자바로 풀 때보다 코드가 한결 간결하다. 이 문제를 잘 생각해보면 피보나치 수열과 원리가 같다는 것을 알 수 있다. 자바로 풀 때는 재귀로 풀었었는데, 파이썬은 반복을 통해서 구현하였다.</p><p>시간 복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p><h2 id="테스트">테스트</h2><p><br></p><figure><img src="/images/programmers/2nTiling.png" alt="테스트 화면" /><figcaption aria-hidden="true">테스트 화면</figcaption></figure><p><br></p>]]></content:encoded>
      
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/">Problem Solving</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/">Programmers</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/Level3/">Level3</category>
      
      
      
      <comments>http://yunpc.github.io/2021/04/06/2Tiling/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>베스트앨범</title>
      <link>http://yunpc.github.io/2021/04/05/Best-Albam/</link>
      <guid>http://yunpc.github.io/2021/04/05/Best-Albam/</guid>
      <pubDate>Mon, 05 Apr 2021 12:05:48 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;문제정의&quot;&gt;문제정의&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;베스트 앨범에 곡을 넣는 문제이다. 우선순위는 다음과 같다.&lt;/p&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;재생 횟수가 가장 많은 장르를 먼저 배치한다.&lt;/li&gt;
&lt;li&gt;장르 안에서 재생 횟수가 많</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="문제정의">문제정의</h2><hr /><p>베스트 앨범에 곡을 넣는 문제이다. 우선순위는 다음과 같다.</p><ol type="1"><li>재생 횟수가 가장 많은 장르를 먼저 배치한다.</li><li>장르 안에서 재생 횟수가 많은 곡 두개를 넣는다. 곡이 하나라면 하나만 넣는다.</li><li>재생 횟수가 동일할 경우 고유번호(인덱스)가 낮은 것을 우선 배치한다.</li></ol><p><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvNDI1Nzk=">문제 링크<i class="fa fa-external-link-alt"></i></span></p><h2 id="문제풀이">문제풀이</h2><hr /><p>이번 문제는 기존 내 코드와 파이써닉하게 작성된 코드를 비교하려고 한다. 이건 기존에 혼자 풀이한 코드이다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">genres, plays</span>):</span></span><br><span class="line">    answer = []</span><br><span class="line">    genre_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, genre <span class="keyword">in</span> <span class="built_in">enumerate</span>(genres):</span><br><span class="line">        <span class="keyword">if</span> genre_dict.get(genre) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            genre_dict[genre] = plays[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            v = genre_dict.get(genre)</span><br><span class="line">            genre_dict[genre] = v + plays[i]</span><br><span class="line"></span><br><span class="line">    sorted_dict = <span class="built_in">sorted</span>(genre_dict.items(), key = (<span class="keyword">lambda</span> x : x[<span class="number">1</span>]), reverse = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> el <span class="keyword">in</span> sorted_dict:</span><br><span class="line">        song_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, genre <span class="keyword">in</span> <span class="built_in">enumerate</span>(genres):</span><br><span class="line">            <span class="keyword">if</span> genre == el[<span class="number">0</span>]:</span><br><span class="line">                song_dict[i] = plays[i]</span><br><span class="line"></span><br><span class="line">        sorted_song_dict = <span class="built_in">sorted</span>(song_dict.items(), key = (<span class="keyword">lambda</span> x : x[<span class="number">1</span>]), reverse = <span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(sorted_song_dict):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            answer.append(item[<span class="number">0</span>])</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><p><code>genre_dict</code>는 장르별로 총 플레이 횟수를 저장하기 위한 딕셔너리이다. <code>enumerate</code>를 활용하여 장르가 저장되어 있지 않은 경우 새로 등록을 하고, 이미 있는 경우에는 저장된 값에 현재 재생횟수를 추가한다.</p><p><code>genre_dict</code>는 <code>sorted</code>를 활용하여 값을 기준으로 내림차순 정렬을 한다. 이렇게 하면 1번 조건을 만족할 수 있게 된다.</p><p>이제 2,3번에 관한 처리를 해야한다. <code>sorted_dict</code>에서 값을 꺼내면서 장르마다 그 장르에 속하는 곡을 찾아낸다. 곡을 찾을 경우 곡의 인덱스를 키로 하고 재생횟수를 값으로 하여 딕셔너리에 추가한다.</p><p>이 뒤는 1번과 비슷하다. <code>sorted</code>를 다시 활용하여 값을 기준으로 내림차순 정렬한다(<code>sorted_song_dict</code>).</p><p>이제 여기서 2개씩 꺼내서 <code>answer</code>리스트에 추가한다. 들어있는 요소가 한개라면 하나만 넣고 종료한다.</p><p>알고리즘은 똑같다. 하지만 파이써닉 하게 작성한 코드를 보면 코드 라인이 확실히 줄어든다.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">genres, plays</span>):</span></span><br><span class="line">    ht1 = <span class="built_in">dict</span>()</span><br><span class="line">    ht2 = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, elem <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(genres, plays)):</span><br><span class="line">        g, p = elem</span><br><span class="line">        <span class="keyword">if</span> g <span class="keyword">not</span> <span class="keyword">in</span> ht1:</span><br><span class="line">            ht1[g] = <span class="number">0</span></span><br><span class="line">            ht2[g] = []</span><br><span class="line"></span><br><span class="line">        ht1[g] += p</span><br><span class="line">        ht2[g].append((i, p))</span><br><span class="line">                    <span class="comment">#(g,p)              # -p 내림차순!</span></span><br><span class="line">    sort_ht1 = <span class="built_in">sorted</span>(<span class="built_in">list</span>(ht1.items()), key = <span class="keyword">lambda</span> x: -x[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> g,p <span class="keyword">in</span> sort_ht1:</span><br><span class="line">        sort_ht2 = <span class="built_in">sorted</span>(ht2[g], key= <span class="keyword">lambda</span> x: -x[<span class="number">1</span>])</span><br><span class="line">        answer += <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x : x[<span class="number">0</span>], sort_ht2))[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure><ol type="1"><li><code>zip</code>을 통해 기존 인덱스 접근과는 다른 접근 방식을 보여준다.</li><li><code>sorted</code>에서 람다함수 부분을 보면 <code>reverse</code>속성이 없고 대신 값에 마이너스를 취한 것을 볼 수 있다. 기능의 차이는 없지만 이렇게 한 경우 코드가 더 간결해 보인다.</li><li><code>map</code>과 <code>lambda</code>를 활용하여 곡의 고유번호 2개를 가져온다. 이때 <code>list</code>로 묶에 슬라이싱을 한다.</li></ol><h2 id="테스트">테스트</h2><p><br></p><figure><img src="/images/programmers/bestalbam.png" alt="테스트 화면" /><figcaption aria-hidden="true">테스트 화면</figcaption></figure><p><br></p><p>통과는 하였지만 파이써닉하게 푸는 것은 아직 더 공부가 필요할 것 같다.</p>]]></content:encoded>
      
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/">Problem Solving</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/">Programmers</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/Level3/">Level3</category>
      
      
      
      <comments>http://yunpc.github.io/2021/04/05/Best-Albam/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>1920번 수 찾기</title>
      <link>http://yunpc.github.io/2021/04/05/Find-Num/</link>
      <guid>http://yunpc.github.io/2021/04/05/Find-Num/</guid>
      <pubDate>Mon, 05 Apr 2021 04:25:15 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;문제정의&quot;&gt;문제정의&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;이분 탐색을 이용한 수 탐색 문제이다.&lt;/p&gt;
&lt;h2 id=&quot;문제풀이&quot;&gt;문제풀이&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;전체 코드는 다음과 같다. &lt;figure class=&quot;highlight python</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="문제정의">문제정의</h2><hr /><p>이분 탐색을 이용한 수 탐색 문제이다.</p><h2 id="문제풀이">문제풀이</h2><hr /><p>전체 코드는 다음과 같다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">A, key</span>):</span></span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = <span class="built_in">len</span>(A)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        mid = (l+r) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> A[mid] == key:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> A[mid] &gt; key:</span><br><span class="line">            r = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = mid+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">N = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">A = <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, _ <span class="keyword">in</span> <span class="built_in">enumerate</span>(A):</span><br><span class="line">    A[i] = <span class="built_in">int</span>(A[i])</span><br><span class="line"></span><br><span class="line">A.sort()</span><br><span class="line"></span><br><span class="line">M = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">X = <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, _ <span class="keyword">in</span> <span class="built_in">enumerate</span>(X):</span><br><span class="line">    <span class="built_in">print</span>(binary_search(A, <span class="built_in">int</span>(X[i])))</span><br></pre></td></tr></table></figure></p><p>이분 탐색을 구현하는 문제이다. 입력을 받는 부분을 건너 뛰고 <code>binary_search</code>함수를 보면 된다. 인덱스를 기준으로 이분탐색을 진행한다.</p><h2 id="테스트">테스트</h2><p><br></p><figure><img src="/images/baekjoon/1920.png" alt="테스트 화면" /><figcaption aria-hidden="true">테스트 화면</figcaption></figure><p><br></p>]]></content:encoded>
      
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/">Problem Solving</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Beakjoon/">Beakjoon</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Beakjoon/1000-1999/">1000-1999</category>
      
      
      
      <comments>http://yunpc.github.io/2021/04/05/Find-Num/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>징검다리</title>
      <link>http://yunpc.github.io/2021/04/02/Stepping-Stone/</link>
      <guid>http://yunpc.github.io/2021/04/02/Stepping-Stone/</guid>
      <pubDate>Fri, 02 Apr 2021 11:21:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;문제정의&quot;&gt;문제정의&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;징검다리에서 돌을 빼냈을 때 벌어지는 간격의 최솟값이 가장 큰 것을 구하는 것이다. 문제는 &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9wcm9ncmFtbWVy</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="문제정의">문제정의</h2><hr /><p>징검다리에서 돌을 빼냈을 때 벌어지는 간격의 최솟값이 가장 큰 것을 구하는 것이다. 문제는 <span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvNDMyMzg=">여기<i class="fa fa-external-link-alt"></i></span>에서 볼 수 있다.</p><h2 id="문제풀이">문제풀이</h2><hr /><p>이진 탐색을 이용한 문제이다. 유형을 익히면 반가운 문제이지만, 처음에 보면 전혀 감이 안 잡힌다.</p><p>전체 코드는 다음과 같다. <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">distance, rocks, n</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFeasable</span>(<span class="params">distance, rocks, n, k</span>):</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        pos = <span class="number">0</span></span><br><span class="line">        total = <span class="built_in">len</span>(rocks)</span><br><span class="line">        <span class="keyword">for</span> rock <span class="keyword">in</span> rocks:</span><br><span class="line">            <span class="keyword">if</span> rock - pos &gt;= k:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                pos = rock</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> total-cnt &lt;= n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    answer = <span class="number">0</span></span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = distance</span><br><span class="line">    rocks.sort()</span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        mid = (l+r) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span>(isFeasable(distance, rocks, n, mid)):</span><br><span class="line">            answer = mid</span><br><span class="line">            l = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = mid</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(solution(<span class="number">25</span>, [<span class="number">2</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">21</span>, <span class="number">17</span>], <span class="number">2</span>))</span><br></pre></td></tr></table></figure> 전체적인 코드의 흐름은 다음과 같다. 1. 간격에 대해서 이분 탐색을 해볼 것이다. 이를 <code>k</code>라고 두자. 2. <code>k</code>의 가장 작은 경우는 0이고 가장 큰 경우는 <code>distance</code>이므로 <code>l</code>과 <code>r</code>로 둔다. 3. 이분 탐색을 하면서 만약 <code>isFeasable</code>을 만족한다면, 돌을 더 빼도 된다는 의미이다. 따라서 mid 값을 늘린다. 4. 아니라면 mid 값을 줄인다. 5. 아니면 answer를 반환한다.</p><p>여기서 왜 돌을 더 빼도 된다는 의미에 대해 알아보기 위해 <code>isFeasable</code>을 살펴보자</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isFeasable</span>(<span class="params">distance, rocks, n, k</span>):</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    pos = <span class="number">0</span></span><br><span class="line">    total = <span class="built_in">len</span>(rocks)</span><br><span class="line">    <span class="keyword">for</span> rock <span class="keyword">in</span> rocks:</span><br><span class="line">        <span class="keyword">if</span> rock - pos &gt;= k:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            pos = rock</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> total-cnt &lt;= n:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p>매개변수로 <code>distance</code>, <code>rocks</code>, <code>n</code>, <code>k</code>를 받는다. <code>cnt</code>는 돌의 개수를 의미하고 <code>pos</code>는 현재 선택한 돌의 위치를 본다. <code>total</code>은 총 돌의 개수를 의미한다.</p><p>for 문의 의미는 최솟값 <code>k</code>만큼의 간격에 포함되는 돌들을 세겠다는 의미이다. 프로그래머스에서 나온 예제를 보면 돌이 [2, 11, 14, 17, 21]의 순서로 놓여있다. 가령 <code>k</code>가 6이라면 [11, 17]에 위치한 돌이 선택되고 <code>cnt</code>는 2가 된다. <code>total</code>에서 <code>cnt</code>를 빼면 몇 개의 돌이 빠졌는지 볼 수 있고 이 값이 <code>n</code>보다 같거나 작으면 <code>True</code>를 반환한다.</p><p>이하에서 <code>True</code>를 반환하는 이유가 있다. 아래의 그림을 보자.</p><figure><img src="/images/programmers/stepping.jpeg" alt="k와 n의 관계" /><figcaption aria-hidden="true">k와 n의 관계</figcaption></figure><p><code>k</code>값이 증가하면 <code>n</code>값도 증가한다. 최솟값이 증가하니 돌 사이의 간격이 더 넓어져야 하기 때문이다. 여기서 우리는 <code>n</code>을 만족하는 최대를 구하려고 한다. 그러면 <code>l</code>이 증가해야 하는 경우를 살펴보아야 한다. 그림을 보면 <code>n</code>의 값이 요구하는 값보다 작을 때 <code>k</code>가 증가해야 함을 볼 수 있다. 이 이유로 인해 비교 연산자 <code>&lt;=</code>를 사용한 것이다.</p><h2 id="테스트">테스트</h2><figure><img src="/images/programmers/stepping_stone.png" alt="테스트 화면" /><figcaption aria-hidden="true">테스트 화면</figcaption></figure><p>자바로 하다가 파이썬으로 넘어오니까 코드가 훨씬 간결해서 놀랐다. 이제부터라도 열심히 애용하겠다.</p>]]></content:encoded>
      
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/">Problem Solving</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/">Programmers</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/Level4/">Level4</category>
      
      
      
      <comments>http://yunpc.github.io/2021/04/02/Stepping-Stone/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>입국심사</title>
      <link>http://yunpc.github.io/2021/03/09/Immigration/</link>
      <guid>http://yunpc.github.io/2021/03/09/Immigration/</guid>
      <pubDate>Tue, 09 Mar 2021 08:19:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;문제정의&quot;&gt;문제정의&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;입국 심사관들이 승객들을 심사하는데 걸리는 가장 최소 시간을 구하는 문제이다. &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="문제정의">문제정의</h2><hr /><p>입국 심사관들이 승객들을 심사하는데 걸리는 가장 최소 시간을 구하는 문제이다. <span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvNDMyMzg=">문제 링크<i class="fa fa-external-link-alt"></i></span></p><h2 id="문제풀이">문제풀이</h2><hr /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Immigration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level3 입국심사</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span>[] times = &#123;<span class="number">7</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(times);</span><br><span class="line">        System.out.println(BinarySearch(times, n, times[times.length-<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span>[] times, <span class="keyword">int</span> n, <span class="keyword">long</span> max)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l = <span class="number">1</span>, r = max * n;</span><br><span class="line">        <span class="keyword">long</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> ans = Long.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isPassed(times, n, mid))</span><br><span class="line">            &#123;</span><br><span class="line">                ans = Math.min(ans, mid);</span><br><span class="line">                r = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPassed</span><span class="params">(<span class="keyword">int</span>[] times, <span class="keyword">int</span> n, <span class="keyword">long</span> mid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> amount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.length; i++)</span><br><span class="line">            amount +=  mid / times[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(amount &gt;= n)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>전체 코드는 다음과 같다.</p><p>일단 심사하는데 걸리는 시간을 정렬한다. 이 문제를 해결하기 위한 큰 그림은 이분탐색을 활용하는 것이다. 이분탐색의 mid를 걸리는 최대 시간으로 가정한다. 그리고 이 최대시간을 적용했을 때 모든 승객들을 심사할 수 있는지 검사한다. 만약 모든 승객을 검사할 수 있다면 midr값을 줄이고, 아니라면 mid값을 늘린다.</p><p>이분 탐색에서 초기 <code>l</code>값은 1로 <code>r</code>값은 가장 오래 걸리는 심사기간에 n을 곱한다. 그 뒤로는 <code>isPassed</code>함수를 통해 모든 승객을 심할 수 있는지 검사하고 만약 검사할 수 있다면, 정답을 더 작은 쪽으로 업데이트하고 <code>r</code>값을 <code>mid+1</code>로 업데이트한다.</p><p>그렇지 않다면 <code>mid</code>값이 더 커져야 한다는 의미이므로 <code>l</code>을 <code>mid+1</code>로 업데이트한다.</p><p><code>isPassed</code>를 검사하는 방법은 들어온 <code>mid</code>값에 대해 심사위원의 시간을 나눠서 검사를 할 수 있는 사람의 수를 전부 더해본다. 만약 이 값이 <code>n</code>을 넘는다면, <code>true</code>를 반환하고, 그렇지 않으면 <code>false</code>를 반환한다.</p><p><code>times</code>의 길이를 <code>m</code>이라 하고, <code>times</code>에서 가장 큰 값을 <code>x</code>라 한다면, 최종 시간복잡도는 <span class="math display">\[O(mlognx)\]</span>이다.</p><h2 id="테스트">테스트</h2><p><br></p><center><img src="/images/programmers/immigration.png" width="290" height="230"></center><p><br></p><p>처음 풀이를 틀려서 다른 사람의 풀이를 참고했는데, 이게 전형적인 이분탐색 문제라고 해서 알아보지 못한 내 자신이 원망스러웠다. 학교 수업 때 이러한 유형을 풀어본 적이 있기 때문이다. 보통 엄청 큰 수가 나오고 최소 또는 최대를 구하라는 문제가 이분탐색의 유형에 해당된다고 한다. 앞으로는 잘 기억해두어야 겠다.</p>]]></content:encoded>
      
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/">Problem Solving</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/">Programmers</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/Level3/">Level3</category>
      
      
      
      <comments>http://yunpc.github.io/2021/03/09/Immigration/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>이중우선순위큐</title>
      <link>http://yunpc.github.io/2021/03/05/Double-Priority-Queue/</link>
      <guid>http://yunpc.github.io/2021/03/05/Double-Priority-Queue/</guid>
      <pubDate>Fri, 05 Mar 2021 08:00:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;문제정의&quot;&gt;문제정의&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;일반적인 우선순위 큐에서 tail에서도 값이 나올 수 있게 만드는 문제이다. I + (숫자)인 경우 숫자를 삽입하는 것이고 &quot;D 1&quot;인 경우 최댓값을 제거하고, &quot;D -1&quot;이라면 최솟값을 제</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="문제정의">문제정의</h2><hr /><p>일반적인 우선순위 큐에서 tail에서도 값이 나올 수 있게 만드는 문제이다. I + (숫자)인 경우 숫자를 삽입하는 것이고 "D 1"인 경우 최댓값을 제거하고, "D -1"이라면 최솟값을 제거한다. 이런 명령어들이 담긴 배열을 전부 수행하였을 때, 큐에 남은 최댓값과 최솟값을 배열로 담아 반환하면 된다. <span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvNDI2Mjg=">문제링크<i class="fa fa-external-link-alt"></i></span></p><h2 id="문제풀이">문제풀이</h2><hr /><p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoublePriorityQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level3 이중 우선순위 큐</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PriorityQueue&lt;Integer&gt; big;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PriorityQueue&lt;Integer&gt; small;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Integer, Integer&gt; big_map;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Integer, Integer&gt; small_map;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] operations = &#123;<span class="string">&quot;I 16&quot;</span>, <span class="string">&quot;I -5643&quot;</span>, <span class="string">&quot;D -1&quot;</span>, <span class="string">&quot;D 1&quot;</span>, <span class="string">&quot;D 1&quot;</span>, <span class="string">&quot;I 123&quot;</span>, <span class="string">&quot;D -1&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        big = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(Collections.reverseOrder());</span><br><span class="line">        small = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        big_map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        small_map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String s : operations)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">&quot;D 1&quot;</span>) &amp;&amp; !big.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> big_i = big.peek();</span><br><span class="line">                big_map.put(big_i, big_map.getOrDefault(big_i, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                big.poll();</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;D -1&quot;</span>) &amp;&amp; !small.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> small_i = small.peek();</span><br><span class="line">                small_map.put(small_i, small_map.getOrDefault(small_i, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                small.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.contains(<span class="string">&quot;I&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> i = Integer.parseInt(s.substring(<span class="number">1</span>).trim());</span><br><span class="line">                big.add(i);</span><br><span class="line">                small.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            synchroize();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(big.isEmpty())</span><br><span class="line">            System.out.println(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(big.peek());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(small.isEmpty())</span><br><span class="line">            System.out.println(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(small.peek());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synchroize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(big_map.getOrDefault(big.peek(), <span class="number">0</span>) &lt; small_map.getOrDefault(big.peek(), <span class="number">0</span>)</span><br><span class="line">        &amp;&amp; !big.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> big_i = big.peek();</span><br><span class="line">            big_map.put(big_i, big_map.getOrDefault(big_i, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            big.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(big_map.getOrDefault(small.peek(), <span class="number">0</span>) &gt; small_map.getOrDefault(small.peek(), <span class="number">0</span>)</span><br><span class="line">        &amp;&amp; !small.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> small_i = small.peek();</span><br><span class="line">            small_map.put(small_i, small_map.getOrDefault(small_i, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            small.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 가장 쉬운 구현방법을 생각해보면 리스트를 선언하여 연산할 수 있겠지만, 그런 경우 시간이 굉장히 오래걸린다. 그래서 우선순위큐를 활용하여 문제를 풀어보자.</p><p>문제점은 우선순위큐에는 tail이라는 개념이 없는 것이다. 애초에 heap으로 구성이 되어 있으니 최대값만 찾거나 최소값만 찾을 수 있다. 필자는 이를 보완하기 위해 우선순위 큐 두개를 활용하기로 했다.</p><p>여기에 추가로 두 개의 맵을 선언하는데 맵의 역할은 각 큐에서 어느 숫자가 몇 번 삭제 되었는지 기록하는 용도이다. 우선순위 큐를 두개를 사용하였지만, 실제로는 하나의 큐로 인식하기 때문에 이 두 큐에서 한쪽만 원소가 삭제되면 안된다. 따라서 이 두 큐를 동기화하기 위해 사용된다.</p><p>첫 번째 for문을 보자. 일단 최대값을 제거해야 하는 경우 <code>big</code>에서 하나를 제거하고 맵에 삭제된 횟수를 갱신한다. 최솟값을 제거하는 경우도 동일한 원리로 작동한다.</p><p>만약 숫자를 삽입하는 경우라면 두 큐에 모두 삽입한다.</p><p>삭제 또는 추가를 마칠 때 마다, 동기화를 해야하는데 필자는 이를 <code>synchronize</code>라는 함수를 통해 구현하였다. 함수 내부를 들여다보면, 두 개의 while문이 나타나는데, 두 while문은 동작하는 방식이 동일하므로 첫번째 while문에 대해서 이야기하겠다.</p><p><code>big</code>큐의 가장 첫번째 원소가 삭제된 횟수가 <code>small</code>에서 삭제된 횟수보다 작다면, 이는 지워야 하는 원소이므로 제거한다. <code>big</code>이 비어있지 않는 한 계속 반복하면 된다. 이를 통해 두 큐를 동기화 할 수 있다.</p><p><code>operation</code>의 크기를 n이라 하였을 때, 최종 시간복잡도는 <span class="math inline">\(O(nlogn)\)</span>이다. 그거보다 시간복잡도가 높지 않을까 생각하는 분이 계실 수도 있는데, 생각해보면 두 큐에 들어갔다 나오는 횟수를 전부 더하면 <span class="math inline">\(4nlogn\)</span>이다.</p><h2 id="테스트">테스트</h2><p><br></p><center><img src="/images/programmers/double_pq.png" width="290" height="130"></center><p><br></p><p>질문하기를 보니까 조건에 부합하지 않게 짜도 통과되는 경우가 있다고 한다. 이 부분에서 좀 더 신경을 써줬으면 좋겠다.</p>]]></content:encoded>
      
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/">Problem Solving</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/">Programmers</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/Level3/">Level3</category>
      
      
      
      <comments>http://yunpc.github.io/2021/03/05/Double-Priority-Queue/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>단속 카메라</title>
      <link>http://yunpc.github.io/2021/03/04/Control-Camera/</link>
      <guid>http://yunpc.github.io/2021/03/04/Control-Camera/</guid>
      <pubDate>Thu, 04 Mar 2021 07:44:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;문제정의&quot;&gt;문제정의&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;최대한 많은 overlap을 하나로 묶을 때, 나오는 집합의 크기를 구하는 문제이다. 상세한 설명은 아래에 계속하겠다. &lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="문제정의">문제정의</h2><hr /><p>최대한 많은 overlap을 하나로 묶을 때, 나오는 집합의 크기를 구하는 문제이다. 상세한 설명은 아래에 계속하겠다. <span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvNDI4ODQ=">문제 링크<i class="fa fa-external-link-alt"></i></span></p><h2 id="문제풀이">문제풀이</h2><hr /><p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Section</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Section</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Section</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        <span class="keyword">this</span>.e = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Section sec)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.s - sec.s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpeedTrap</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//프로그래머스 level3 단속카메라</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] routes = &#123;</span><br><span class="line">            &#123;-<span class="number">20</span>, <span class="number">15</span>&#125;,</span><br><span class="line">            &#123;-<span class="number">14</span>, -<span class="number">5</span>&#125;,</span><br><span class="line">            &#123;-<span class="number">18</span>, -<span class="number">13</span>&#125;,</span><br><span class="line">            &#123;-<span class="number">5</span>, -<span class="number">3</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Section&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; routes.length; i++)</span><br><span class="line">            pq.add(<span class="keyword">new</span> Section(routes[i][<span class="number">0</span>], routes[i][<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cam_cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> end = pq.peek().e;</span><br><span class="line">            <span class="keyword">while</span>(!pq.isEmpty() &amp;&amp; pq.peek().s &lt;= end)</span><br><span class="line">            &#123;</span><br><span class="line">                end = pq.peek().e &lt; end ? pq.peek().e : end;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            cam_cnt++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(cam_cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 알고리즘의 이해를 돕기 위해 아래의 그림을 보자</p><p><br></p><center><img src="/images/programmers/cam.jpeg" width="1184" height="431"></center><p><br></p><p>프로그래머스에서 주어진 구간을 수평선 상에 표시하였다. 최소한의 카메라를 설치해야한다는 것은 최대한 차가 많이 다닐 것 같은 길목에 카메라를 놓아야 한다는 것이다. 그 말은 구간이 최대한 많이 겹치는 쪽에 카메라를 놓으면 된다는 것이다.</p><p>이를 구현하기 위해서 <code>Section</code>클래스를 선언하였다. 구간의 처음과 끝을 저장해두며, 정렬을 할 때 구간의 시작점을 기준으로 정렬한다.</p><p>우선순위 큐를 선언하여 Section을 집어넣는다. 이 큐에서 하나씩 빼면서 최대한 겹칠 수 있는 구간들을 묶을 것이다. 일단 <code>end</code>를 큐의 첫원소의 도착구간으로 설정한다. 그리고 <code>end</code>보다 출발점이 작은 구간은 무조건 겹치므로 이들을 팝한다. 이 때, 팝한 것들 중에 기존 <code>end</code>보다 작은 종료구간이 있다면 그 값으로 대체한다.</p><p>이 반복이 마치면 더 이상 겹치는 구간이 없다는 의미이므로 하나로 묶는 작업이 끝난 것이다. 카메라를 설치한다는 의미로 <code>cam_cnt</code>를 1가한다.</p><p>우선순위 큐를 사용하였기 때문에 구간의 개수를 n이라 하였을 때, 최종 시간복잡도는 <span class="math inline">\(O(nlogn)\)</span>이다.</p><h2 id="테스트">테스트</h2><p><br></p><center><img src="/images/programmers/camera.png" width="290" height="130"></center><p><br></p><p>학교 수업에서 해봤던 문제라 수월하게 풀 수 있었다. 앞으로 나만의 코테 데이터베이스를 더 쌓아나가야지.</p>]]></content:encoded>
      
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/">Problem Solving</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/">Programmers</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/Level3/">Level3</category>
      
      
      
      <comments>http://yunpc.github.io/2021/03/04/Control-Camera/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>디스크 컨트롤러</title>
      <link>http://yunpc.github.io/2021/03/04/Disk-Controller/</link>
      <guid>http://yunpc.github.io/2021/03/04/Disk-Controller/</guid>
      <pubDate>Thu, 04 Mar 2021 06:26:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;문제정의&quot;&gt;문제정의&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;SJF(Shortest Job First)를 구현하는 문제이다.&lt;/p&gt;
&lt;h2 id=&quot;문제풀이&quot;&gt;문제풀이&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;전체 코드는 다음과 같다. &lt;figure class=&quot;hi</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="문제정의">문제정의</h2><hr /><p>SJF(Shortest Job First)를 구현하는 문제이다.</p><h2 id="문제풀이">문제풀이</h2><hr /><p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Job</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> request_time;</span><br><span class="line">    <span class="keyword">int</span> service_time;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(<span class="keyword">int</span> request_time, <span class="keyword">int</span> service_time)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.request_time = request_time;</span><br><span class="line">        <span class="keyword">this</span>.service_time = service_time;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Job j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.service_time - j.service_time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level3 디스크 컨트롤러</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] jobs = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">            &#123;<span class="number">500</span>, <span class="number">6</span>&#125;,</span><br><span class="line">            <span class="comment">// &#123;0, 7&#125;,</span></span><br><span class="line">            <span class="comment">// &#123;0, 3&#125;,</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(jobs, (a,b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        Queue&lt;Job&gt; prepare_q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jobs.length; i++)</span><br><span class="line">            prepare_q.add(<span class="keyword">new</span> Job(jobs[i][<span class="number">0</span>], jobs[i][<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Job&gt; ready_q = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> time = jobs[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> total_t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> done = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(done != jobs.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!prepare_q.isEmpty() &amp;&amp; prepare_q.peek().request_time &lt;= time)</span><br><span class="line">                ready_q.add(prepare_q.poll());</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!ready_q.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                Job job = ready_q.poll();</span><br><span class="line">                time += job.service_time;</span><br><span class="line">                total_t += time - job.request_time;</span><br><span class="line">                done++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                time = prepare_q.peek().request_time;</span><br><span class="line">        &#125;        </span><br><span class="line"></span><br><span class="line">        System.out.println((<span class="keyword">int</span>)Math.floor(total_t/done));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 작업을 나타내기 위한 클래스를 먼저 정의한다. 문제에서 주어진 입력대로 클래스의 인스턴스 변수는 <code>request_time</code>과 <code>service_time</code>이다. 여기서 비교 클래스를 상속받아 메소드를 오버라이딩 해주는데 인스턴스들을 정렬할 경우 <code>service_time</code>이 오름차순이 되도록 한다.</p><p>주어진 입력은 요청시간 순대로 들어오지 않으므로 이에 대해 람다식으로 정렬을 해주는 것이 우선이다. 람다식을 이용해 정렬한다.</p><p>정렬한 배열을 <code>prepare_q</code>에 전부 넣는다. 실은 여기서 개인의 취향대로 여기서도 우선순위 큐를 활용해도 된다. 이 큐는 처리되길 기다리는 작업들을 모아둔 것이라고 보면 된다.</p><p>이제 작업을 순차적으로 처리해야 한다. 초기 <code>time</code>을 첫번째 요청시간으로 초기화한다. <code>total_t</code>는 총 반환시간을 의미하며, <code>done</code>은 종료된 작업의 개수를 뜻한다.</p><p>반복은 모든 작업이 완료될 때 까지로 한다. 준비 큐(<code>prepare_q</code>)가 비어있지 않을 때, time보다 작거나 같은 요청시간을 가진 작업들을 모두 빼와 대기 큐(<code>ready_q</code>)에 집어넣는다. 이 때 대기 큐에 하나라도 들어가 있다면, 들어온 것 중에서 가장 작은 서비스시간을 가진 것을 꺼낸다. 그리고 <code>time</code>에는 서비스 시간을 더하고 <code>total_t</code>에 <code>time-(요청 시간)</code>을 더해준다. 그리고 <code>done</code>을 1증가한다. 만약에 대기 큐가 비어있다면 준비큐의 맨 앞의 요청시간을 <code>time</code>으로 갱신한다.</p><p>정렬을 사용하였기 때문에 작업의 개수를 n이라 하였을 때, 최종 시간복잡도는 <span class="math inline">\(O(nlogn)\)</span>이다.</p><h2 id="테스트">테스트</h2><p><br></p><center><img src="/images/programmers/disk_controller.png" width="290" height="130"></center><p><br></p><p>처음에는 우선순위큐를 이용하지 않고 dfs에서 방문기록을 남겼던 것 처럼, 배열을 정렬하고 방문기록을 활용하여 똑같은 논리로 짰었는데 계속 틀렸다. 어제 몇 시간을 고민하다. 결국 다 지우고 우선순위 큐로 구현하였더니 통과가 되었다. 그 전 코드의 문제점이 뭔지 알았으면 좋았을텐데, 앞으로 공부를 하면서 꼬인 논리를 지금 보다 더 능숙하게 풀어냈으면 좋겠다.</p>]]></content:encoded>
      
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/">Problem Solving</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/">Programmers</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/Level3/">Level3</category>
      
      
      
      <comments>http://yunpc.github.io/2021/03/04/Disk-Controller/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>가장 먼 노드</title>
      <link>http://yunpc.github.io/2021/03/03/Farthest-Node/</link>
      <guid>http://yunpc.github.io/2021/03/03/Farthest-Node/</guid>
      <pubDate>Wed, 03 Mar 2021 05:10:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;문제정의&quot;&gt;문제정의&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;1번 노드로부터 가장 멀리 떨어진 노드가 총 몇 개인지 계산하는 문제이다.&lt;/p&gt;
&lt;h2 id=&quot;문제풀이&quot;&gt;문제풀이&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;전체 코드는 다음과 같다. &lt;figure cla</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="문제정의">문제정의</h2><hr /><p>1번 노드로부터 가장 멀리 떨어진 노드가 총 몇 개인지 계산하는 문제이다.</p><h2 id="문제풀이">문제풀이</h2><hr /><p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FarthestNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 level3 가장 먼 노드</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] edge = &#123;</span><br><span class="line">            &#123;<span class="number">3</span>, <span class="number">6</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>, <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>, <span class="number">2</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>, <span class="number">2</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//adjacency list</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj_list = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            adj_list.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            adj_list.get(edge[i][<span class="number">0</span>]).add(edge[i][<span class="number">1</span>]);</span><br><span class="line">            adj_list.get(edge[i][<span class="number">1</span>]).add(edge[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//bfs</span></span><br><span class="line">        <span class="keyword">int</span>[] distance = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> root = q.poll();</span><br><span class="line">            visited[root] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> depth = distance[root]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i : adj_list.get(root))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    distance[i] = depth;</span><br><span class="line">                    visited[i] = <span class="keyword">true</span>;</span><br><span class="line">                    q.add(i);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; distance.length; i++)</span><br><span class="line">            max = Math.max(max, distance[i]);</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; distance.length; i++)</span><br><span class="line">            answer = distance[i] == max ? answer+<span class="number">1</span> : answer;</span><br><span class="line"></span><br><span class="line">        System.out.println(answer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> bfs를 이용해서 문제를 풀면 된다. 각 노드의 <code>depth</code>(깊이)를 계산하여 제일 큰 값을 가지는 노드가 총 몇 개인지 세어본다. 이번 문제에서는 간선이 많기 때문에 행렬형태로 연결을 포함할 수 없다. 그래서 adjacency list를 통해 구현하였다.</p><p>그래프를 모두 표시하고 난 뒤, bfs를 한다. 큐를 선언하고 각 노드의 깊이를 저장할 <code>distance</code>를 선언한다. 1번노드부터 bfs를 시작할 것이므로, 1을 큐에 삽입한다.</p><p>이제 큐에서 1을 꺼내 루트로 생각하고 방문여부를 나타내는 <code>visited</code>를 true로 한다. <code>root</code>와 인접한 노드들은 <code>root</code>+1의 깊이를 가지므로 이 값을 <code>depth</code>로 둔다. 이제 인접 리스트를 돌면서 방문하지 않았던 노드들의 깊이를 기록하고 방문기록을 true로 한다.</p><p>이 과정을 모두 마치면 <code>distance</code>값 중에 가장 큰 것을 <code>max</code>값으로 한다. 그리고 <code>distance</code>중에 <code>max</code>값이 몇 개가 있는지 세면 정답이다.</p><p>adjacency list를 사용하기 때문에, 노드 개수를 V, 간선의 개수를 E라고 한다면 최종 시간복잡도는 <span class="math inline">\(O(V+E)\)</span>이다.</p><h2 id="테스트">테스트</h2><p><br></p><center><img src="/images/programmers/farthest_node.png" width="290" height="130"></center><p><br></p><p>필자는 처음에 다익스트라로 풀었는데 구현이 잘못되었는지 계속 틀려서 결국 노트북을 닫았다. 약한 멘탈이 미울 지경이다. 문제점을 못찾겠어서 고민하다가 bfs로도 될 것 같은데라는 생각이 들었다. 하지만 어제는 기력이 다해서 집에서 뻗었다. 결국 다른 사람의 풀이를 찾아보니 다 bfs로 풀었다. 다익스트라로 푼 사람은 못 봤다. bfs로 풀어서 정답을 맞았지만 다익스트라로 풀었을 때 왜 틀렸는지는 아직 의문이다.</p>]]></content:encoded>
      
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/">Problem Solving</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/">Programmers</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/Level3/">Level3</category>
      
      
      
      <comments>http://yunpc.github.io/2021/03/03/Farthest-Node/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>단어변환</title>
      <link>http://yunpc.github.io/2021/03/02/Transfrom-Word/</link>
      <guid>http://yunpc.github.io/2021/03/02/Transfrom-Word/</guid>
      <pubDate>Tue, 02 Mar 2021 06:39:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;문제정의&quot;&gt;문제정의&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;시작단어에서 끝단어로 변환하는 최소 횟수를 알아내려고 한다. 만약 변환할 수 없다면 0을 반환한다. 변환을 거칠 땐 알파벳 한 글자만 바꿀 수 있다.&lt;/p&gt;
&lt;h2 id=&quot;문제풀이&quot;&gt;문제풀이</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="문제정의">문제정의</h2><hr /><p>시작단어에서 끝단어로 변환하는 최소 횟수를 알아내려고 한다. 만약 변환할 수 없다면 0을 반환한다. 변환을 거칠 땐 알파벳 한 글자만 바꿀 수 있다.</p><h2 id="문제풀이">문제풀이</h2><hr /><p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformWord</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//프로그래머스 level3 단어 변환</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] matrix;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String begin = <span class="string">&quot;hit&quot;</span>;</span><br><span class="line">        String target = <span class="string">&quot;cog&quot;</span>;</span><br><span class="line">        String[] words = &#123;<span class="string">&quot;cog&quot;</span>, <span class="string">&quot;log&quot;</span>, <span class="string">&quot;lot&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;dot&quot;</span>, <span class="string">&quot;hot&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(begin);</span><br><span class="line">        <span class="keyword">for</span>(String s : words)</span><br><span class="line">            list.add(s);</span><br><span class="line"></span><br><span class="line">        matrix = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()][list.size()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; list.size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(canConnect(list.get(i), list.get(j)))</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">1</span>;</span><br><span class="line">                    matrix[j][i] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> inf = <span class="number">1250</span>;</span><br><span class="line">        <span class="keyword">int</span>[] distance  = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">boolean</span>[] visited  = <span class="keyword">new</span> <span class="keyword">boolean</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; list.size(); i++)</span><br><span class="line">            distance[i] = inf;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!stack.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> root = stack.pop();</span><br><span class="line">            visited[root] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[root][i] == <span class="number">1</span> &amp;&amp; !visited[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                    <span class="keyword">if</span>(distance[i] &gt; distance[root]+<span class="number">1</span>)</span><br><span class="line">                        distance[i] = distance[root]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = list.indexOf(target);</span><br><span class="line">        <span class="keyword">if</span>(index == -<span class="number">1</span> || distance[index] == inf)</span><br><span class="line">            System.out.println(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(distance[index]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canConnect</span><span class="params">(String s1, String s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr1 = s1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] arr2 = s2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> wrong = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr1[i] != arr2[i])</span><br><span class="line">                ++wrong;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrong == <span class="number">1</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 단어간의 변환 관계를 따지면 그래프를 만들 수 있다. 만든 그래프에서 begin에서 각 단어까지 변환하는데 걸리는 최소 변환 횟수를 구한다. 마지막으로 타겟 단어의 index에 해당하는 횟수를 반환하면 된다. 만약 타겟 단어가 없다면 0을 반환한다.</p><p>일단 그래프를 만들기 위해 두 단어가 변환이 되는 지 확인하는 함수 <code>canConnect</code>를 정의하였다. 모든 단어의 길이는 같다고 했으므로, 한쪽의 길이를 기준으로 하여 문자를 비교한다. 만약 다른 글자수(<code>wrong</code>)가 하나라면 <code>true</code>를 반환하고, 아니라면 <code>false</code>를 반환한다.</p><p>리스트 <code>list</code>를 만들어 첫시간과 words를 합친다. 반복문을 통해 모든 쌍을 <code>canConnect</code>를 통해 변환할 수 있는 관계인지 파악하고, 만약 변환할 수 있다면 <code>matrix</code>에 1이라 표시한다(18-30줄).</p><p>그래프를 <code>matrix</code>에 표시했으므로, dfs를 활용하여 최소 변환 횟수를 구할 차례이다. 이번 문제는 가능한 가 가능한지 않은가가 아니라, 최소를 찾아야 하므로 <code>distance</code>를 추가로 선언한다. 시작단어인 <code>distance[0]</code>은 0으로 하고 나머지는 큰 상수로 초기화한다.</p><p>이제 본격적인 dfs로 들어가보자. 스택에 0번을 넣고 <code>vistied</code>(방문했는지 여부)를 true로 한다. 그리고 변환할 수 있는 단어 중에 아직 방문하지 않은 단어들의 인덱스를 담는다. 이 때, 변환 횟수를 비교하는데 만약 현재 단어가 가지고 있는 <code>distance</code>값보다 현재 단어에서 1을 더한 값이 더 작다면 그 값으로 업데이트한다.</p><p>dfs를 모두 마치면 <code>distance</code>에는 시작단어에서 각각의 모든 단어로 변환할 수 있는 최소 횟수가 담기게 된다. 이제 <code>indexOf()</code>메소드를 이용하여 끝 단어의 인덱스를 구해 그 값을 반환하면 된다. 만약 끝단어의 <code>distance</code>값이 무한이거나 없을 경우에는 <code>false</code>를 출력하면 된다.</p><p>adjacency matrix를 사용하기 때문에, 최종 시간복잡도는 <span class="math inline">\(O(n^2)\)</span>이다.</p><h2 id="테스트">테스트</h2><p><br></p><center><img src="/images/programmers/word_transform.png" width="290" height="130"></center><p><br></p><p>다른 사람의 풀이를 보니 그냥 dfs를 이용해서 풀었는데도 통과가 되었다. 그런데 그렇게 하면 최소값이 아니게 도달해도 정답이 되버릴텐데,, 이 부분에서 프로그래머스가 테스트 케이스를 추가해줬으면 좋겠다는 생각이 들었다.</p><p>이 문제를 풀면서 다익스트라를 참고도 안하고 혼자서 해보려고 했는데 나중에 다 풀고보니 다익스트라는 인접한 것 중에 가장 짧은 경로를 기준으로 가는 거라고 했다. 필자는 그냥 가장 나중에 확인한 것을 다음 노드로 지정하였는데 이렇게 해도 최단 거리를 찾을 수 있을지 궁금하다. 다음에 또 이런 문제를 만난다면 그 땐 다익스트라를 좀 더 세심하게 구현해야겠다. 덕분에 모자란 개념을 보충할 수 있었다.</p>]]></content:encoded>
      
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/">Problem Solving</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/">Programmers</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/Level3/">Level3</category>
      
      
      
      <comments>http://yunpc.github.io/2021/03/02/Transfrom-Word/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>섬 연결하기</title>
      <link>http://yunpc.github.io/2021/03/02/Connect-Island/</link>
      <guid>http://yunpc.github.io/2021/03/02/Connect-Island/</guid>
      <pubDate>Tue, 02 Mar 2021 02:45:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;문제정의&quot;&gt;문제정의&lt;/h2&gt;
&lt;hr /&gt;
&lt;h3 id=&quot;섬-연결하기&quot;&gt;섬 연결하기&lt;/h3&gt;
&lt;p&gt;섬 사이를 연결하는 다리를 짓는 건설비용이 주어진다. 모든 섬을 연결하려고 할 때, 드는 건설비용의 최솟값을 구하라.&lt;/p&gt;
&lt;h2 id=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="문제정의">문제정의</h2><hr /><h3 id="섬-연결하기">섬 연결하기</h3><p>섬 사이를 연결하는 다리를 짓는 건설비용이 주어진다. 모든 섬을 연결하려고 할 때, 드는 건설비용의 최솟값을 구하라.</p><h2 id="문제풀이">문제풀이</h2><hr /><p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Island</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Island</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Island</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        <span class="keyword">this</span>.e = e;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Island arg0)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arg0.v &gt;= <span class="keyword">this</span>.v ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectingIsland</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level3 섬 연결하기</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> costs[][] = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            parent[i] = i;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        List&lt;Island&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; costs.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Island temp = <span class="keyword">new</span> Island(costs[i][<span class="number">0</span>], costs[i][<span class="number">1</span>], costs[i][<span class="number">2</span>]);</span><br><span class="line">            list.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//matrix 만들기</span></span><br><span class="line">        <span class="keyword">for</span>(Island land : list)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(find(land.e) == find(land.s))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            union(land.e, land.s);</span><br><span class="line">            answer += land.v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == parent[a])</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">return</span> parent[a] = find(parent[a]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a_root = (find(a));</span><br><span class="line">        <span class="keyword">int</span> b_root = (find(b));</span><br><span class="line">        <span class="keyword">if</span>(a_root != b_root)</span><br><span class="line">            parent[a_root] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 크루스칼 알고리즘을 사용하면 된다. 필자는 분명 수업시간에 들었던 것 같은데 막상 구현하려고 하니 다 까먹었다.. 그래서 이번 문제를 통해 다시 정리할 수 있었다. 크루스칼 알고리즘을 간단히 설명하자면 간선의 비용이 가장 적은 것 부터 선택해 나가는 알고리즘이다. 다만 사이클이 형성되어서는 안된다. 그렇다면 간선을 선택할 때 마다 사이클이 발생하는지 봐야하는데 이 때 쓰이는 자료구조가 union-find이다.</p><p>union-find를 구현하기 위해 parent배열을 선언했다. parent 배열은 자신의 부모가 누구인지 저장하는 배열이다. 처음에는 자신의 위에 아무도 없으므로 배열의 인덱스로 값을 초기화한다.</p><p>union-find에선 두 가지 함수가 필요한데, 하나는 find함수이고, 하나는 union이다. find는 해당 노드의 최상단 부모를 찾아주는 함수이다. 최상단 부모는 parent값과 노드 값이 일치할 것이므로 그 때의 값을 반환하면 된다. 그렇지 않다면 재귀를 통해 부모를 찾아간다. 이 때, return문을 보면 find한 값을 parent[a]에 대입하는 것을 볼 수 있는데, 이 과정을 거치지 않는다면 <span class="math inline">\(O(n)\)</span>으로 수행 시간이 길어지기 때문이다.</p><p>union함수는 두 노드를 합쳐주는 역할을 한다. a의 최상단 부모값과 b의 최상단 부모값을 찾아 이 둘이 같지 않다면 부모를 통일해준다. 코드 자체는 어렵지 않다.</p><p>필자는 섬을 표현하기 위한 클래스 Island를 새로 선언하였다. 시작점을 s, 끝점을 e, 비용을 v로 하였다. 정렬기준은 비용을 기준으로 하였다. 메인에서 읽어들인 값을 리스트에 저장하여 정렬하였다. 이렇게 하면, 간선비용을 기준으로 하여 오름차순으로 정렬 할 수 있다.</p><p>오름차순으로 정렬한 Island를 순회하며, 사이클이 형성될 경우 간선을 선택하지 않고 그렇지 않을 경우 그 값을 answer에 더하고 두 섬이 합해지는 걸 나타내기 위해 union함수를 사용한다. 사이클인지 아닌지 확인하는 방법은 두 섬의 최상단 부모가 같은지 확인하면 된다.</p><p>간선의 최대 개수는 <span class="math inline">\(n*(n-1) \over 2\)</span>이므로, 최종 시간복잡도는 <span class="math inline">\(O(n^2log_2n^2)\)</span>이다.</p><h2 id="테스트">테스트</h2><p><br></p><center><img src="/images/programmers/connect_island.png" width="290" height="210"></center><p><br></p><p>union-find를 연습했었는데 다시 하려니 또 까먹었다. 최적화하는 방법까지 잘 익혀야겠다. 중요한건 복습 또 복습이다.</p><p>다른 사람의 풀이를 보니 별도 클래스를 선언하지 않고 람다식으로 특정값을 기준으로 정렬하는 것을 보았다. 앞으로도 잘 쓰일 것 같으니 여기에 메모해 둔다.</p><p><code>Arrays.sort(costs, (a, b) -&gt; Integer.compare(a[2], b[2]));</code></p>]]></content:encoded>
      
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/">Problem Solving</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/">Programmers</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/Level3/">Level3</category>
      
      
      
      <comments>http://yunpc.github.io/2021/03/02/Connect-Island/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>정수 삼각형</title>
      <link>http://yunpc.github.io/2021/02/25/Integer-Triangle/</link>
      <guid>http://yunpc.github.io/2021/02/25/Integer-Triangle/</guid>
      <pubDate>Thu, 25 Feb 2021 07:55:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;문제정의&quot;&gt;문제정의&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;삼각형의 꼭대기부터 바닥까지 가는 경로 중에서 경로의 합이 가장 큰 것을 찾는 문제이다. 아래쪽으로 갈 때는 자신의 바로 왼쪽 아래나 오른쪽 아래로만 이동할 수 있다.&lt;/p&gt;
&lt;h2 id=&quot;</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="문제정의">문제정의</h2><hr /><p>삼각형의 꼭대기부터 바닥까지 가는 경로 중에서 경로의 합이 가장 큰 것을 찾는 문제이다. 아래쪽으로 갈 때는 자신의 바로 왼쪽 아래나 오른쪽 아래로만 이동할 수 있다.</p><h2 id="문제풀이">문제풀이</h2><hr /><p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerTriangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level3 정수 삼각형</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] triangle = &#123;</span><br><span class="line">            &#123;<span class="number">7</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>,<span class="number">8</span>&#125;,</span><br><span class="line">            &#123;<span class="number">8</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] sum = <span class="keyword">new</span> <span class="keyword">int</span>[triangle.length][triangle.length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(triangle.length == <span class="number">1</span>)</span><br><span class="line">            System.out.println(triangle[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        sum[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; triangle.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[i][<span class="number">0</span>] = triangle[i][<span class="number">0</span>] + sum[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            sum[i][len-<span class="number">1</span>] = triangle[i][len-<span class="number">1</span>] + sum[i-<span class="number">1</span>][len-<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len-<span class="number">1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> max = Math.max(sum[i-<span class="number">1</span>][j-<span class="number">1</span>], sum[i-<span class="number">1</span>][j]);</span><br><span class="line">                sum[i][j] = max + triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        len--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            answer = Math.max(answer, sum[triangle.length-<span class="number">1</span>][i]);</span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 아이디어는 이렇다. 삼각형의 밑변을 길이로 하여 2차원 배열을 생성한다. 그리고 여기에 해당 위치에 오기까지의 합 중 가장 큰 것을 넣을 것이다. 필자는 이를 sum이라 하였다. sum[0][0]은 맨 꼭대기이므로 triangle[0][0]을 넣는다. 꼭대기에서 갈 수 있는 곳은 3과 8이다. 3의 위치에서 최대값은 3+7=10, 8위치에서 합의 최대는 7+8=15이다. 3번째 줄로 내려가보자. 8은 3의 위치에서 내려올 수 밖에 없으므로 최대값은 10+8=18이다. 1의 경우 2번째 줄의 3과 8에서 둘 다 내려올 수 있다. 이 문제는 최대를 찾는 문제이므로 10과 15중 15를 선택하여 15+1=16을 기록하면 된다.</p><p>이런식으로 sum을 채워나가고 가장 아래층의 수 중 가장 큰 수를 찾으면 된다. 이를 코드로 그대로 구현하였다. sum을 정사각형으로 선언했기 때문에 각 층에 있는 숫자의 개수를 len으로 알려주었다. 가장 꼭대기를 채워넣고 그 아래부터는 for문의 영향을 받는다. 각 층에서 맨 왼쪽과 오른쪽 원소는 내려오는 경로가 하나밖에 없기 때문에 이는 따로 처리한다. 이를 제외한 원소는 위층의 왼쪽 대각선과 오른쪽 대각선의 sum값을 비교 한뒤 큰 값을 취한다. 각 층에서의 연산이 끝나면 len을 증가한다.</p><p>반복이 끝나면 맨 아래층의 원소에서 최대값을 찾아 반환한다.</p><p>연산 횟수는 삼각형의 밑변을 n이라 할 때, <span class="math inline">\(n^2 \over 2\)</span>이므로, 최종 시간복잡도는 <span class="math inline">\(O(n^2)\)</span>이다.</p><h2 id="테스트">테스트</h2><p><br></p><center><img src="/images/programmers/integer_triangle.png" width="290" height="500"></center><p><br></p><p>다이나믹 프로그래밍에 약한 편이다. 이건 기초문제라 쉽게 해결했지만, 이 유형에 좀 더 익숙해져야겠다.</p>]]></content:encoded>
      
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/">Problem Solving</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/">Programmers</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/Level3/">Level3</category>
      
      
      
      <comments>http://yunpc.github.io/2021/02/25/Integer-Triangle/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>자물쇠와 열쇠</title>
      <link>http://yunpc.github.io/2021/02/24/Key-and-Lock/</link>
      <guid>http://yunpc.github.io/2021/02/24/Key-and-Lock/</guid>
      <pubDate>Wed, 24 Feb 2021 09:58:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;문제정의&quot;&gt;문제정의&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;열쇠의 돌기부분이 자물쇠의 홈에 맞는지 판별하는 문제이다. 열쇠를 자물쇠에 맞출 때, 열쇠가 자물쇠 바깥으로 삐져나올 수 있다. 하지만 자물쇠와 열쇠의 돌기부분이 서로 맞물리면 안된다. 자세</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="문제정의">문제정의</h2><hr /><p>열쇠의 돌기부분이 자물쇠의 홈에 맞는지 판별하는 문제이다. 열쇠를 자물쇠에 맞출 때, 열쇠가 자물쇠 바깥으로 삐져나올 수 있다. 하지만 자물쇠와 열쇠의 돌기부분이 서로 맞물리면 안된다. 자세한 사항은 아래 링크에서 확인하길 바란다.</p><p><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvNjAwNTk=">문제 링크<i class="fa fa-external-link-alt"></i></span></p><h2 id="문제풀이">문제풀이</h2><hr /><p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockandKey</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level3 자물쇠와 열쇠</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] key = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] lock = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> answer = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//get rotation</span></span><br><span class="line">        <span class="keyword">int</span>[][][] keys = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][key.length][key.length];</span><br><span class="line">        <span class="comment">//make keys</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; key.length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                keys[<span class="number">0</span>][i][j] = key[i][j];</span><br><span class="line">                keys[<span class="number">1</span>][i][j] = key[key.length-<span class="number">1</span>-j][i];</span><br><span class="line">                keys[<span class="number">2</span>][i][j] = key[key.length-<span class="number">1</span>-i][key.length-<span class="number">1</span>-j];</span><br><span class="line">                keys[<span class="number">3</span>][i][j] = key[j][key.length-<span class="number">1</span>-i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//count zero</span></span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lock.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lock.length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(lock[i][j] == <span class="number">0</span>)</span><br><span class="line">                    zero++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//find match key</span></span><br><span class="line">        <span class="keyword">int</span> m = key.length;</span><br><span class="line">        <span class="keyword">int</span> n = lock.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//4keys</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; m+n-<span class="number">1</span>; c++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m+n-<span class="number">1</span>; r++)<span class="comment">//right corner position</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//check if key is matched</span></span><br><span class="line">                    <span class="keyword">boolean</span> match = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">int</span> zero_cnt = zero;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> y = c-m+<span class="number">1</span>; y &lt;= c; y++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> x = r-m+<span class="number">1</span>; x &lt;= r; x++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>(y &lt; <span class="number">0</span> || x &lt; <span class="number">0</span> || y &gt;= lock.length || x &gt;= lock.length)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="keyword">int</span> v = keys[i][y-(c-m+<span class="number">1</span>)][x-(r-m+<span class="number">1</span>)];</span><br><span class="line">                            <span class="keyword">if</span>(v == <span class="number">1</span> &amp;&amp; lock[y][x] == <span class="number">1</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                match = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span>(v == <span class="number">1</span> &amp;&amp; lock[y][x] == <span class="number">0</span>)</span><br><span class="line">                                zero_cnt--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(!match)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//if answer found</span></span><br><span class="line">                    <span class="keyword">if</span>(zero_cnt == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        answer = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                        </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(answer)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(answer)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 코드가 긴편이다. 전체적인 과정을 생각해보면 다음과 같다. 1. 열쇠는 회전이 가능하다 90도씩 회전한 4개 열쇠를 만든다. 2. 자물쇠에서 홈이 몇 개 있는지 센다. 3. 자물쇠에 각 열쇠를 끼워본다. 4. 자물쇠에 열쇠가 맞고 모든 홈을 채웠다면 답을 true로 한다. 5. 그렇지 않다면 다음 자리로 열쇠를 이동해본다.</p><p>1번 과정 코드부터 살펴보자 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get rotation</span></span><br><span class="line"><span class="keyword">int</span>[][][] keys = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][key.length][key.length];</span><br><span class="line"><span class="comment">//make keys</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; key.length; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        keys[<span class="number">0</span>][i][j] = key[i][j];</span><br><span class="line">        keys[<span class="number">1</span>][i][j] = key[key.length-<span class="number">1</span>-j][i]; <span class="comment">//90</span></span><br><span class="line">        keys[<span class="number">2</span>][i][j] = key[key.length-<span class="number">1</span>-i][key.length-<span class="number">1</span>-j]; <span class="comment">//180</span></span><br><span class="line">        keys[<span class="number">3</span>][i][j] = key[j][key.length-<span class="number">1</span>-i]; <span class="comment">//270</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 회전 각에 따라 총 4개의 열쇠가 나올 수 있다. 회전을 구현하는 방법은 읽는 순서를 달리하면 된다. 이는 코드에 나와있으니 코드를 스스로 공부하고 그림을 그려가면서 알아보길 바란다. 이렇게 하면 4개의 열쇠꾸러미를 손에 쥘 수 있다.</p><p>2번 과정은 2차원 배열을 순회하면서 0인 부분을 세면 된다. 이 부분은 간단하므로 넘어가자.</p><p>3,4,5과정은 한 코드로 나타나 있다. 범위 설정에 주의하면서 코드를 보자. <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//find match key</span></span><br><span class="line"><span class="keyword">int</span> m = key.length;</span><br><span class="line"><span class="keyword">int</span> n = lock.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//4keys</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; m+n-<span class="number">1</span>; c++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m+n-<span class="number">1</span>; r++)<span class="comment">//right corner position</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//check if key is matched</span></span><br><span class="line">            <span class="keyword">boolean</span> match = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> zero_cnt = zero;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = c-m+<span class="number">1</span>; y &lt;= c; y++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x = r-m+<span class="number">1</span>; x &lt;= r; x++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(y &lt; <span class="number">0</span> || x &lt; <span class="number">0</span> || y &gt;= lock.length || x &gt;= lock.length)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> v = keys[i][y-(c-m+<span class="number">1</span>)][x-(r-m+<span class="number">1</span>)];</span><br><span class="line">                    <span class="keyword">if</span>(v == <span class="number">1</span> &amp;&amp; lock[y][x] == <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        match = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(v == <span class="number">1</span> &amp;&amp; lock[y][x] == <span class="number">0</span>)</span><br><span class="line">                        zero_cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!match)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//if answer found</span></span><br><span class="line">            <span class="keyword">if</span>(zero_cnt == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                answer = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(answer)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(answer)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 첫번째 반복은 열쇠 꾸러미에서 몇 번째 열쇠를 쓸 것인지 나타낸다. 열쇠는 총 4개이므로 4개의 열쇠에 대해 각각 수행해본다.</p><p>c와 r의 반복은 열쇠를 이동해보는 반복이다. c와 r은 열쇠의 오른쪽 아래 모서리가 위치하는 점을 기준으로 하였다. 모든 경우의 수를 해보려면 오른쪽 아래 모서리가 (0,0)에서 (m+n-2, m+n-2)까지 움직여야 한다(m은 열쇠의 가로, n은 자물쇠의 가로이다).</p><p>열쇠를 이동했다면 이제 홈에 들어맞는지 확인해야 한다. 이는 y와 x에 대한 반복문으로 나타냈다. 오른쪽 아래 모서리를 기준으로 움직였기 때문에, 열쇠가 들어맞는지 검사하기 위해선 위쪽 모서리 값을 알아야 한다. 이는 (c-m+1, r-m+1)이다. 그럼 여기부터 열쇠와 자물쇠가 들어맞는지 확인하면 된다.</p><p>일단 x나 y가 자물쇠 범위 밖을 벗어났다면 비교할 필요가 없으므로 continue를 한다. 만약 범위 이내라면 둘을 비교한다. 이때 열쇠는 [0][0]부터 비교하는 것이기 때문에, 현재 y와 x에서 왼쪽 모서리 값을 빼준다.</p><p>만약 비교하는 열쇠와 자물쇠가 모두 돌기부분이라면 들어맞지 않으므로 break를 통해 탈출한다. 이 때 match를 이용해 한 번더 반복을 탈출하여 열쇠가 바로 이동할 수 있도록 한다.</p><p>만약 열쇠는 돌기이고 자물쇠가 홈부분이면, zero_cnt를 하나씩 줄인다. 모든 검사를 마칠 때 이 값이 0이라면 열쇠가 자물쇠에 들어맞다는 뜻이므로, 모든 반복을 탈출하고 답을 출력한다.</p><p>반복 횟수를 계산해보자면 <span class="math inline">\((m+n-2)(m+n-2)m*m\)</span>이 된다. 따라서 최고차항을 따로 떼어내면 최종 시간복잡도는 <span class="math inline">\(O(m^2n^2)\)</span>이다.</p><h2 id="테스트">테스트</h2><p><br></p><center><img src="/images/programmers/lockandkey.png" width="290" height="500"></center><p><br></p><p>처음으로 2시간 안에 level3문제를 스스로 풀어서 기쁘다. 멘탈만 흔들리지 않으면 성장할 수 있다고 생각하는 오늘이다. 요새 네카라쿠배 2차테스트를 하는데 알고보니 실수를 해서 점수를 다 날려 먹게 생겼다 하... 2일차까지 테스트 점수가 다 꽝인데 그래도 포기하지 않고 끝까지 해보기로 했다. 학원의 힘을 빌리지 않고도 성장할 수 있으니까! 가벼운 마음으로 테스트에 임하자.</p>]]></content:encoded>
      
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/">Problem Solving</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/">Programmers</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/Level3/">Level3</category>
      
      
      
      <comments>http://yunpc.github.io/2021/02/24/Key-and-Lock/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>네트워크</title>
      <link>http://yunpc.github.io/2021/02/24/Network/</link>
      <guid>http://yunpc.github.io/2021/02/24/Network/</guid>
      <pubDate>Wed, 24 Feb 2021 08:58:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;문제정의&quot;&gt;문제정의&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;네트워크의 개수가 몇 개인지 판별하는 문제이다. 기본적인 탐색문제이다.&lt;/p&gt;
&lt;p&gt;&lt;span class=&quot;exturl&quot; data-url=&quot;aHR0cHM6Ly9wcm9ncmFtbWVycy5j</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="문제정의">문제정의</h2><hr /><p>네트워크의 개수가 몇 개인지 판별하는 문제이다. 기본적인 탐색문제이다.</p><p><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvNDMxNjI=">문제 링크<i class="fa fa-external-link-alt"></i></span></p><h2 id="문제풀이">문제풀이</h2><hr /><p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Network</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level3 네트워크</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] computers = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            &#123;</span><br><span class="line">                answer++;</span><br><span class="line">                visited[i] = <span class="keyword">true</span>;</span><br><span class="line">                Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">                stack.push(i);</span><br><span class="line">                <span class="keyword">while</span>(!stack.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> t = stack.peek();</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(computers[t][j] == <span class="number">1</span> &amp;&amp; !visited[j])</span><br><span class="line">                        &#123;</span><br><span class="line">                            visited[j] = <span class="keyword">true</span>;</span><br><span class="line">                            stack.push(j);</span><br><span class="line">                        &#125; </span><br><span class="line">                            </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 전형적인 탐색문제라 어렵지 않다. 일단 각 컴퓨터를 한번이라도 체크했는지 확인하는 불리안 배열을 생성한다. 그리고 이 배열을 순회하며 만약 한 번도 체크하지 않은 컴퓨터라면 dfs를 실시 한다. 필자는 스택을 이용해서 dfs를 구현했다.</p><p>반복 횟수를 계산해보자면 <span class="math inline">\((m+n-2)(m+n-2)m*m\)</span>이 된다. 따라서 최고차항을 따로 떼어내면 최종 시간복잡도는 <span class="math inline">\(O(m^2n^2)\)</span>이다.</p><h2 id="테스트">테스트</h2><p><br></p><center><img src="/images/programmers/network.png" width="290" height="500"></center><p><br></p><p>예전만 해도 dfs가 왜 스택이고 bfs는 왜 큐인지 이해가 잘 안갔는데 어느 새, 혼자서 아무것도 참고하지 않고 dfs를 구현할 수 있게 되었다. 늦은 감이 없지 않아 있지만, 그래도 성장했음을 느낀다.</p>]]></content:encoded>
      
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/">Problem Solving</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/">Programmers</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/Level3/">Level3</category>
      
      
      
      <comments>http://yunpc.github.io/2021/02/24/Network/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>풍선 터트리기</title>
      <link>http://yunpc.github.io/2021/02/22/Pop-Ballon/</link>
      <guid>http://yunpc.github.io/2021/02/22/Pop-Ballon/</guid>
      <pubDate>Mon, 22 Feb 2021 08:29:00 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;문제정의&quot;&gt;문제정의&lt;/h2&gt;
&lt;hr /&gt;
&lt;p&gt;나란히 있는 두 풍선을 임의로 선택하여 그 중에 큰 쪽을 터트린다. 단, 한번은 더 작은 숫자의 풍선을 터트릴 수 있다. 풍선이 1개가 남을 때 까지 터트릴 때, 최후에 남을 수 있는 풍선의</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="문제정의">문제정의</h2><hr /><p>나란히 있는 두 풍선을 임의로 선택하여 그 중에 큰 쪽을 터트린다. 단, 한번은 더 작은 숫자의 풍선을 터트릴 수 있다. 풍선이 1개가 남을 때 까지 터트릴 때, 최후에 남을 수 있는 풍선의 갯수를 반환하라.</p><h2 id="문제풀이">문제풀이</h2><hr /><p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BallonPop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level3 풍선 터트리기</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        </span><br><span class="line">        left[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">        right[a.length-<span class="number">1</span>] = a[a.length-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">            left[i] = left[i-<span class="number">1</span>] &gt; a[i] ? a[i] : left[i-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = a.length-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            right[i] = right[i+<span class="number">1</span>] &gt; a[i] ? a[i] : right[i+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">            answer = (left[i] &lt; a[i]) &amp;&amp; (right[i] &lt; a[i]) ? answer : answer+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 한 풍선을 선택하고 그 풍선이 최후로 남을 수 있는 경우의 수를 생각해보면 자신을 기준으로 좌우에서 풍선의 최소값을 각각 구한다. 만약 좌우의 풍선값보다 기준 풍선값의 값이 작다면, 이 풍선은 절대 터트릴 수 없다. 이를 코드로 구현한 것이 위와 같다.</p><p>시간 복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p><h2 id="테스트">테스트</h2><p><br></p><center><img src="/images/programmers/ballonpop.png" width="290" height="380"></center><p><br></p><p>요새 문제풀이를 통 못했는데 일단 난이도가 어려워져서 고민하는 시간이 많아 포스팅 하는 텀이 길어진다. 물론 이 풀이도 질문하기에서 본 접근방법을 참고한 거라 공부가 많이 필요하다고 느낀다. 패스트캠퍼스에서 주관하는 네카라쿠배 교육과정의 2차테스트를 치르고 있는 중인데, 혼자 공부하는 것보단 학원이 나을 것 같아서 최선을 다해 테스트에 임하려고 한다. 그래도 혼자 공부하는 시간을 줄이진 말아야지. 화이팅!</p>]]></content:encoded>
      
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/">Problem Solving</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/">Programmers</category>
      
      <category domain="http://yunpc.github.io/categories/Problem-Solving/Programmers/Level3/">Level3</category>
      
      
      
      <comments>http://yunpc.github.io/2021/02/22/Pop-Ballon/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
