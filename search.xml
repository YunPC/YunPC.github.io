<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>124 나라의 숫자</title>
    <url>/2020/12/31/124Contry-Num/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>10진법을 1,2,4에 존재하는 나라의 규칙에 따라 새로 나타내는 문제이다. 규칙을 찾아내는 것이 관건인데, 필자는 다른 사람들이랑 다른 관점으로 풀었다(코드 길이는 훨씬 길다).</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Country124Num</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 124 나라의 숫자</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line">        StringBuilder buff = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> r = n % <span class="number">3</span>;</span><br><span class="line">            n/=<span class="number">3</span>;</span><br><span class="line">            buff.append(String.valueOf(r));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">char</span>[] arr = buff.reverse().toString().toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> p = i;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;=<span class="number">0</span>; j--)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[j] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        p = j;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(p != i)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> k = p; k &lt; i; k++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> pre_num = Integer.parseInt(String.valueOf(arr[k]));</span><br><span class="line">                        <span class="keyword">char</span> pre_char = Character.forDigit(pre_num-<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">                        arr[k] = pre_char;</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">int</span> aft_num = Integer.parseInt(String.valueOf(arr[k+<span class="number">1</span>]));</span><br><span class="line">                        <span class="keyword">char</span> aft_char = Character.forDigit(aft_num+<span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line">                        arr[k+<span class="number">1</span>] = aft_char;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> start_idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                start_idx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start_idx; i &lt; arr.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i] == <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">                arr[i] = <span class="string">&#x27;4&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String answer = <span class="keyword">new</span> String(arr);</span><br><span class="line">        answer = answer.substring(start_idx, arr.length);</span><br><span class="line"></span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 부분부분 따라가보자. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> r = n % <span class="number">3</span>;</span><br><span class="line">    n/=<span class="number">3</span>;</span><br><span class="line">    buff.append(String.valueOf(r));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span>[] arr = buff.reverse().toString().toCharArray();</span><br></pre></td></tr></table></figure> 일단 정상적인 3진법으로 만든다. 기본적으로 이 문제는 3진법의 응용문제이다. 왜냐하면 사용하는 숫자가 총 3개이기 때문이다. 이를 대응관계로 보면 3진법의 수는 {0, 1, 2}인데, 이 문제의 경우 {4, 1, 2}로 대응된다. 그러면 3진법으로 바꿔서 4,1,2로만 바꾸면 되지 않느냐 할 수 있는데 그럴 수 없다. 3의 배수가 아닌 수는 앞서 말했던 방법이 통한다. 하지만 6을 예시로 들어보자 6의 경우 3진법으로 바꾸면 20이다. 이를 대응 관계에 비춰 바꿔보면 24이지만, 정답은 14이다. 0이 존재하지 않기 때문에 이를 처리하기 위한 방법이 필요하다. 실은 이 부분에서 꽤 고생을했는데 필자가 생각한 방법은 이렇다. 1. 3진수로 바꾼 배열을 뒤에서부터 보면서 0이 있는지 확인한다. 2. 0이 있으면 앞에서부터 빌려올 수 있는 수가 있는지 확인한다. 3. 빌려올 수 있는 수가 있다면 빌려온다. 이 때 내려받는 수는 10진법에선 10이지만, 지금은 3진법이므로 3이 되겠다. 4. 3을 빌려준 수는 1 깎인다. 5. 0을 다 없애고 나면 3인 수를 4로 바꿔준다.</p>
<p>이해를 돕기 위해 그림을 첨부한다.</p>
<center>
<img src="/images/programmers/124country_picture.jpeg" width="414" height="660">
</center>
<p>초등학생 때 했던 10진수 빼기를 생각하면 된다.</p>
<p>이 부분에서 시간복잡도는 3으로 나눴을 때의 자릿수만큼이므로 <span class="math inline">\(O(log3(n))\)</span>이다.</p>
<p>말이 길었는데 이것만 이해하면 나머지는 코드만 읽으면 된다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = arr.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] == <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> p = i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt;=<span class="number">0</span>; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[j] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                p = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p != i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = p; k &lt; i; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> pre_num = Integer.parseInt(String.valueOf(arr[k]));</span><br><span class="line">                <span class="keyword">char</span> pre_char = Character.forDigit(pre_num-<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">                arr[k] = pre_char;</span><br><span class="line">                        </span><br><span class="line">                <span class="keyword">int</span> aft_num = Integer.parseInt(String.valueOf(arr[k+<span class="number">1</span>]));</span><br><span class="line">                <span class="keyword">char</span> aft_char = Character.forDigit(aft_num+<span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line">                arr[k+<span class="number">1</span>] = aft_char;</span><br><span class="line">                        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 3진수로 바꾼 수에서 뒤에서부터 보면서 0이 있는지 확인한다. 만약 0이 있다면, 자신의 앞에 있는 수에서 3을 빌릴 수 있는지 확인한다. 3을 빌릴 수 있는 숫자가 발견되면, 그 인덱스를 기억해 놨다가. 빌리고 빼는 것을 반복한다. 위 코드에서 보이는 k를 iterator로 쓰는 for문이 바로 그 부분이다(3,4번과정). 이 분의 시간 복잡도는 <span class="math inline">\(O(log3(n))\)</span>인데, 해봤자 <span class="math inline">\(2log3(n)\)</span>이기 때문이다. 앞쪽에서 빌리면 해당수와 앞쪽 사이에는 0이 절대로 존재할 수 없기 때문인데, 혹시 더 이해가 안간다면 이메일을 통해 언제든지 질문하기를 바란다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        start_idx = i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = start_idx; i &lt; arr.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(arr[i] == <span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">        arr[i] = <span class="string">&#x27;4&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 거의 다왔다. 4,5과정을 거쳐도 코드적으로 해결해야하는 것이 있는데 자릿수가 있다. 아까 그림을 보면 알 수 있듯이 원래 9의 자릿수는 3자리였지만 변환 후의 자릿수는 2자릿수로 문자열을 편집해줄 필요가 있다. 앞에서 부터 0이 안나오는 인덱스를 저장해두어 나중에 substring으로 잘라준다. 그리고 3을 4로 치환한다(5번과정). 이 부분도 시간복잡도는 <span class="math inline">\(O(log3(n))\)</span>이다.</p>
<p>따라서 최종 시간복잡도는 <span class="math inline">\(O(log3(n))\)</span> 이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/124_country.png" width="350" height="500">
</center>
<p><br></p>
<p>60줄을 넘었는데 다른 풀이는 고작 10줄안에 끝나서 절망했다. 하지만 할 수 있는건 계속 문제를 풀어나가는 수 밖에 없다. n에 나머지 연산을 해주고 나눌 때 3의 배수이면 -1을 해줬는데, 자릿수를 올리지 않기 위해서 그랬다고 하지만, 경험적으로 풀어봐야 이해할듯 말듯하고, 원리에 대해 명쾌하게 설명해주는 블로그가 없어서 아쉬웠다. 이 부분은 좀 더 고민해보고 이 포스트에 보충해서 쓰도록 하겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>2xn 타일링(파이썬)</title>
    <url>/2021/04/06/2Tiling/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>가로 길이가 2이고 세로의 길이가 1인 직사각형 모양의 타일이 있다. 이 타일로 2*n바닥을 덮을 수 있는 경우의 수를 구하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">n</span>):</span></span><br><span class="line">    answer = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    fn, fn_1 = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n+<span class="number">1</span>):</span><br><span class="line">        fn, fn_1 = fn_1, fn+fn_1</span><br><span class="line">        fn %= <span class="number">1000000007</span></span><br><span class="line">        fn_1 %= <span class="number">1000000007</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fn % <span class="number">1000000007</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(solution(<span class="number">4</span>))</span><br></pre></td></tr></table></figure> 자바로 풀 때보다 코드가 한결 간결하다. 이 문제를 잘 생각해보면 피보나치 수열과 원리가 같다는 것을 알 수 있다. 자바로 풀 때는 재귀로 풀었었는데, 파이썬은 반복을 통해서 구현하였다.</p>
<p>시간 복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<figure>
<img src="/images/programmers/2nTiling.png" alt="테스트 화면" /><figcaption aria-hidden="true">테스트 화면</figcaption>
</figure>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level3</category>
      </categories>
  </entry>
  <entry>
    <title>2xn 타일링</title>
    <url>/2021/02/09/2xn-Tiling/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>가로 길이가 2이고 세로의 길이가 1인 직사각형 모양의 타일이 있다. 이 타일로 2*n바닥을 덮을 수 있는 경우의 수를 구하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Tiling2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 Level3 2xn 타일링</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] cache;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line">        cache = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">int</span> answer = ReturnAnswer(n, <span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ReturnAnswer</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> w)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(w == n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(w &gt; n)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(cache[w] != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> cache[w];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            res = ReturnAnswer(n,w+<span class="number">1</span>) % <span class="number">1000_000_007</span>;</span><br><span class="line">            res += ReturnAnswer(n, w+<span class="number">2</span>) % <span class="number">1000_000_007</span>;</span><br><span class="line">            cache[w] = res%<span class="number">1000_000_007</span>;</span><br><span class="line">            <span class="keyword">return</span> cache[w];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 생각해보면 세로길이2를 채울 수 있는 경우의 수는 2가지 밖에 없다. 하나는 세로로 하나의 타일이 쌓인 경우이고, 나머지 하나는 가로로 두개의 타일이 쌓인 경우이다. 첫번째 경우에는 가로로 1증가하고, 두번째 경우는 가로가 2증가한다. 이 두가지 경우를 계속 시도해보는 코드를 짜면 된다.</p>
<p><code>ReturnAnswer</code>함수를 살펴보자. <code>n</code>은 주어진 가로 길이이고 <code>w</code>는 현재 가로 길이다. 만약 이 가로 길이에 도달하면 1을 반환하고 그렇지 않으면 0을 반환한다. 여기서 연산의 반복을 줄이기 위해 캐시도 사용한다. 만약 해당 길이에 이미 구해놓은 값이 있으면 그 값을 사용한다.</p>
<p>새로 계산해야 하는 경우 길이를 1늘린 것과 2늘린 값을 가져와서 나머지 연산을 한다. 이 둘은 더하는 과정에서도 값이 1,000,000,007을 넘는 경우가 있으므로 캐시에 값을 넣을 때도 나머지 연산을 한 뒤 값을 반환한다.</p>
<p>시간 복잡도는 <span class="math inline">\(O(log2^n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/tiling.png" width="345" height="560">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level3</category>
      </categories>
  </entry>
  <entry>
    <title>2016년</title>
    <url>/2020/12/24/2016/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>2016년의 월과 일을 입력하면 요일을 출력해주는 프로그램을 짜는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>물론 제일 쉬운 방법은 스위치문이나 if-else문으로 모든 경우의 수를 짜는 것이겠지만(실제로 문제를 풀고 다른 사람 풀이 중에 그렇게 푼 사람이 있었다! 정말 존경한다.), 필자는 1월 1일부터 며칠이나 떨어져있는지 계산한 후 그 날을 요일로 바꾸는 연산을 하였다.</p>
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Year2016</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">3</span>;</span><br><span class="line">        String answer = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span>[] months = &#123;<span class="number">0</span>,<span class="number">31</span>, <span class="number">29</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">31</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">30</span>&#125;;</span><br><span class="line">        String[] days = &#123;<span class="string">&quot;MON&quot;</span>, <span class="string">&quot;TUE&quot;</span>, <span class="string">&quot;WED&quot;</span>, <span class="string">&quot;THU&quot;</span>, <span class="string">&quot;FRI&quot;</span>, <span class="string">&quot;SAT&quot;</span>, <span class="string">&quot;SUN&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> day = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span> month = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(month != a)</span><br><span class="line">        &#123;</span><br><span class="line">            day += months[month];</span><br><span class="line">            month++;</span><br><span class="line">        &#125;</span><br><span class="line">        day += b-<span class="number">1</span>;</span><br><span class="line">        day %= <span class="number">7</span>;</span><br><span class="line">        answer = days[day];</span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 코드가 짧으므로 오늘은 부분적으로 코드를 끊어서 보지 않겠다. 일단 월마다 더하는 달을 배열로 저장해둔다. 예를 들어 1월 1일에서 2월 1일로 넘어가기 위해선 31일이 필요하다. 0월이란 수는 없으므로 months의 첫번째 수는 0으로 채운다. 그리고 days에는 요일을 저장해둔다. 문제에서 2016년 1월 1일은 금요일이라 했으므로 금요일의 배열 인덱스인 4를 기본값으로한다. 이제 a와 b에 따라 요일을 출력해보자. 초기 달은 1월인데 만약 원하는 달이 1월이 아닌 경우 months의 일수를 더해간다. 그리고 b일 -1을 더해준다(1일에서 넘어가기 시작하는거기 때문이다.). 총 일수를 구했으니 이를 7로 나머지 연산을 하면 요일을 구할 수 있다.</p>
<p>총 시간복잡도는 a의 크기에 따라 달라지므로 a의 크기를 n이라하면 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/year2016.png" width="400" height="300">
</center>
<p><br></p>
<p>다른 사람의 풀이를 보니 하나하나 스위치문과 if문을 통해 구현한 사람이 있었다. 정말 대단한 사람이라고 생각한다. 문제풀이를 처음 시작할 때 효율적인 방법을 몰라도 일단 풀고자 하는 마음이 중요하다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>행렬의 덧셈</title>
    <url>/2020/12/30/Add-Matrix/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>두 행렬간의 덧셈을 하여 결과 행렬을 만드는 문제이다. 같은열 같은행의 원소끼리 더하면 된다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddMatrix</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level1 행렬의 덧셈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] arr1 = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] arr2 = &#123;</span><br><span class="line">            &#123;<span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>, <span class="number">6</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[][] answer = <span class="keyword">new</span> <span class="keyword">int</span>[arr1.length][arr1[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; arr1[<span class="number">0</span>].length; j++)</span><br><span class="line">                answer[i][j] = arr1[i][j] + arr2[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 2중 for문으로 모든 원소를 돌아보며 합을 구하면 된다. 주어진 행렬의 행을 n, 열을 m이라고 할 때, 모든 원소를 순회하므로 시간복잡도는 <span class="math inline">\(O(n*m)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/add_matrix.png" width="350" height="500">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>두 개 뽑아서 더하기</title>
    <url>/2020/12/22/Add-Two-Num-Picked/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>정수 배열 numbers가 주어질 때 서로 다른 인덱스에 있는 두 개의 숫자를 뽑아 더해서 만들 수 있는 모든 경우의 수를 배열로 담아 반환하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>간단한 문제이다. 두 수를 모두 더해보면서 배열에 넣으면 된다. 다만, 중복인 배열이 있으면 안되므로 set를 활용한다.</p>
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PickTwoSum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; numbers.length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                set.add(numbers[i]+numbers[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(set);</span><br><span class="line">        list.sort(<span class="keyword">null</span>);</span><br><span class="line">        Integer arr[] = <span class="keyword">new</span> Integer[list.size()];</span><br><span class="line">        arr = list.toArray(arr);</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            answer[i] = Integer.parseInt(arr[i].toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>부분부분 살펴보자</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashSet&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; numbers.length; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        set.add(numbers[i]+numbers[j]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>중복을 방지하기 위해 배열이 아닌 set을 선언한다. 두 수를 더해서 set에 더해간다. set에 add를 하는 것은 <span class="math inline">\(O(1)\)</span>이다. 따라서 for문에 의해 이부분은 <span class="math inline">\(O(n^2)\)</span>이다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(set);</span><br><span class="line">list.sort(<span class="keyword">null</span>);</span><br><span class="line">Integer arr[] = <span class="keyword">new</span> Integer[list.size()];</span><br><span class="line">arr = list.toArray(arr);</span><br><span class="line"><span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[arr.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    answer[i] = Integer.parseInt(arr[i].toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>set은 순서에 상관하지 않기 때문에 정렬이라는 개념이 없다. 그래서 이를 list로 바꿔준뒤 int형태로 바꿔주는 과정이다. list에 있는 sort는 <span class="math inline">\(O(nlogn)\)</span>이고 for문은 <span class="math inline">\(O(n)\)</span>이므로 이 부분에서 시간복잡도는 <span class="math inline">\(O(nlogn)\)</span>이다.</p>
<p>따라서 총 걸리는 시간 복잡도는 <span class="math inline">\(O(n^2)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<figure>
<img src="/images/programmers/pick_two_sum_result.png" alt="pick_two_sum_result" /><figcaption aria-hidden="true">pick_two_sum_result</figcaption>
</figure>
<p>c++로 코딩을 하다가 다시 자바를 하려니 까먹은 자료구조나 메소드가 많다. 앞으로 천천히 익혀나가야겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>안드로이드 스튜디오 깃 연동하는 법</title>
    <url>/2021/01/21/AndroidStudio-Git/</url>
    <content><![CDATA[<h2 id="안드로이드와-깃-연동하기mac">안드로이드와 깃 연동하기(Mac)</h2>
<hr />
<p>여러 포스트를 보고 안드로이드와 깃은 연동하려 했으나 안드로이드 스튜디오에서 깃 계정이 등록이 안되는 오류에 부딪히고 말았다. 그런 경우 토큰을 받아 하면 된다는데, 귀찮아서 이것저것 만지다 보니 됐다. 내 포스팅을 보고 다른 사람들도 도움을 받았으면 좋겠다.</p>
<ul>
<li>새 안드로이드 프로젝트 만들기</li>
</ul>
<p>일단 프로젝트를 만들자.</p>
<figure>
<img src="/images/android_git/1.png" alt="1" /><figcaption aria-hidden="true">1</figcaption>
</figure>
<p>여기서 Create New Project를 클릭한다.</p>
<ul>
<li>프로젝트 탬플릿 선택하기</li>
</ul>
<figure>
<img src="/images/android_git/2.png" alt="2" /><figcaption aria-hidden="true">2</figcaption>
</figure>
<p>어떤 것을 하던 상관은 없지만 일단 빈 액티비티로 만든다.</p>
<ul>
<li>프로젝트 명 생성하기</li>
</ul>
<figure>
<img src="/images/android_git/3.png" alt="3" /><figcaption aria-hidden="true">3</figcaption>
</figure>
<p>프로젝트명을 생성해줍니다.</p>
<figure>
<img src="/images/android_git/4.png" alt="4" /><figcaption aria-hidden="true">4</figcaption>
</figure>
<p>이제 프로젝트로 만든 폴더와 같은 위치에 gitignore을 생성한다. 프로젝트 폴더의 상위에서 터미널을 열어 위와 같이 touch .gitignore을 입력한다. 필자의 경우 SayHello위에 AndroidStudioProject가 있으므로 거기서 커맨드를 입력했다.</p>
<figure>
<img src="/images/android_git/5.png" alt="5" /><figcaption aria-hidden="true">5</figcaption>
</figure>
<p>만들어진 파일은 <code>커맨드</code>+<code>쉬프트</code>+<code>.</code>으로 볼 수 있다. 이제 이걸 열고 ignore파일을 작성한다. ignore파일을 아래의 링크에서 만들 수 있다. 필자는 코틀린과 안드로이드 스튜디오를 넣었다.</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudG9wdGFsLmNvbS9kZXZlbG9wZXJzL2dpdGlnbm9yZQ==">https://www.toptal.com/developers/gitignore<i class="fa fa-external-link-alt"></i></span></p>
<p>이제 다시 안드로이드 스튜디오로 돌아간다.</p>
<figure>
<img src="/images/android_git/6.png" alt="6" /><figcaption aria-hidden="true">6</figcaption>
</figure>
<p>프로젝트에서 VCS로 들어가 깃 레파지토리 생성으로 넘어갑니다.</p>
<figure>
<img src="/images/android_git/7.png" alt="7" /><figcaption aria-hidden="true">7</figcaption>
</figure>
<p>Create Git Repository를 선택해 어떤 폴더를 깃과 연동할지 선택합니다. 필자는 AndroidStudioProject로 하였습니다. 만약 이 때 .ignore 파일이 보이지 않는다면 <code>커맨드</code>+<code>쉬프트</code>+<code>.</code>를 입력하면 볼 수 있다. .git이 보이지 않아도 괜찮다. 필자는 이미 연결한 상태라 그렇다. 여기서 Open을 누르면 빨갛게 파일명들이 바뀐것을 볼 수 있다.</p>
<figure>
<img src="/images/android_git/8.png" alt="8" /><figcaption aria-hidden="true">8</figcaption>
</figure>
<p>파일명이 빨갛게 변한 상태에서 우측 상단의 초록 체크마크를 클릭한다.</p>
<figure>
<img src="/images/android_git/9.png" alt="9" /><figcaption aria-hidden="true">9</figcaption>
</figure>
<p>그럼 왼쪽에 어떤 창이 나타나는데 커밋할 파일을 고르는 창이다. 이제보니 .gitignore가 여러개 생성이 되었는데, 앞에 것이 꼭 필요한 걸지 잘 모르겠다. 나중에 좀 더 뜯어봐야겠다.</p>
<figure>
<img src="/images/android_git/10.png" alt="10" /><figcaption aria-hidden="true">10</figcaption>
</figure>
<p>모든 파일을 체크하고 커밋옆의 아래 화살표를 클릭하면 커밋 앤 푸쉬가 나타는데 이걸 클릭한다. 커밋 메시지도 함께 입력하는 것을 잊지말자!</p>
<figure>
<img src="/images/android_git/11.png" alt="11" /><figcaption aria-hidden="true">11</figcaption>
</figure>
<p>뭐라뭐라 경고하는데 그냥 푸쉬한다고 한다.</p>
<figure>
<img src="/images/android_git/12.png" alt="12" /><figcaption aria-hidden="true">12</figcaption>
</figure>
<p>그럼 어떤 창이 뜨는데 define remote를 클릭하면 url을 달라는 창이 이렇게 뜬다. 이때 레파지토리를 생성하여 URL을 입력한다.</p>
<figure>
<img src="/images/android_git/13.png" alt="13" /><figcaption aria-hidden="true">13</figcaption>
</figure>
<p>그럼 이렇게 올릴 파일들의 목록이 나온다. 이제 푸쉬를 해준다.</p>
<figure>
<img src="/images/android_git/14.png" alt="14" /><figcaption aria-hidden="true">14</figcaption>
</figure>
<p>깃으로 돌아가면 다음과 같이 성공적으로 연결된 것을 볼 수 있다.</p>
]]></content>
      <categories>
        <category>App</category>
        <category>Android Studio</category>
      </categories>
  </entry>
  <entry>
    <title>자릿수 더하기</title>
    <url>/2020/12/29/Add-Digit/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>숫자가 들어올 때 숫자의 자릿수를 모두 더해서 출력하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AddDigit</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">123</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        String num = Integer.toString(n);</span><br><span class="line">        <span class="keyword">char</span>[] n_arr = num.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : n_arr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> temp = Integer.parseInt(String.valueOf(c));</span><br><span class="line">            answer += temp;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 숫자를 문자열을 바꾼디 숫자를 문자배열로 쪼갠다. 그리고 전부 더하여 정답을 내면 된다. 총 시간복잡도는 <span class="math inline">\(O(log10(n))\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/sum_digit.png" width="400" height="300">
</center>
<p><br></p>
<p>문자열로 바꾸지 않아도 10으로 나머지 연산을 반복함으로써 해결할 수도 있었다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>정수 내림차순으로 배치하기</title>
    <url>/2020/12/29/Arrange-Integer-Descending/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>숫자를 입력받아 거꾸로 출력하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumDesc</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//프로그래머스 문제 풀이 level1 정수 내림차순으로 배치하기</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> n = <span class="number">118372</span>;</span><br><span class="line">        <span class="keyword">long</span> answer = <span class="number">0</span>;</span><br><span class="line">        String s = Long.toString(n);</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        s = <span class="keyword">new</span> StringBuilder(<span class="keyword">new</span> String(arr)).reverse().toString();</span><br><span class="line">        answer = Long.parseLong(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 숫자-&gt;문자열-&gt;정렬-&gt;문자열-&gt;숫자로 진행하였다. 총 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/num_desc.png" width="400" height="300">
</center>
<p><br></p>
<p>람다식을 이용하여 한줄로 끝낸 사람도 있었다. 나도 람다식에 대해 공부해 봐야겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>문자열 내 마음대로 정렬하기</title>
    <url>/2020/12/28/Arrange-String-Me/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>새로운 기준으로 문자열을 정렬하는 문제이다. 문자열의 n번째 문자를 기준으로 정렬하되, 같은 문자라면 전체 문자에서 사전 중 빠른 문자를 우선으로 한다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortString</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String[] strings = &#123;<span class="string">&quot;abce&quot;</span>, <span class="string">&quot;abcd&quot;</span>, <span class="string">&quot;cdx&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(strings, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1.charAt(n) &gt; o2.charAt(n))</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(o1.charAt(n) &lt; o2.charAt(n))</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> o1.compareTo(o2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 문제 그대로 comparator를 정의하여 sort했다. 최종적으로 시간복잡도는 <span class="math inline">\(O(nlogn)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/sort_str_my.png" width="400" height="300">
</center>
<p><br></p>
<p>필자와 같이 비교하는 연산을 새로 정의하여 쓸 수도 있지만, 다른 사람 풀이 중에 흥미로운 게 있어서 여기에 적어둔다. 문자열 배열에 n번째 문자를 단어의 맨 앞에 추가하여 저장한다. 그리고 이를 정렬하면 따로 비교자를 정의하지 않고도 정렬을 할 수 있다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>나누어 떨어지는 숫자 배열</title>
    <url>/2020/12/28/Array-Divided/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>나누는 수를 주었을 때 배열 중 나누어 떨어지는 수를 오름차순으로 담아 반환하는 문제이다. 만약 나누어 떨어지는 수가 하나도 없으면 -1을 담아 반환한다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>문제에서 요구하는 것을 그대로 따라가면 된다. 바로 코드를 보도록 하자.</p>
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mod0Arr</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">10</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> divisor = <span class="number">5</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num%divisor == <span class="number">0</span>)</span><br><span class="line">                list.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(list.size() == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span>[] answer = &#123;-<span class="number">1</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Collections.sort(list);</span><br><span class="line">            <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)</span><br><span class="line">                answer[i] = Integer.parseInt(list.get(i).toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 부분부분 살펴보자 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">5</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> divisor = <span class="number">5</span>;</span><br><span class="line">ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> num : arr)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(num%divisor == <span class="number">0</span>)</span><br><span class="line">        list.add(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 어레이리스트를 선언하고 배열을 순회하면서 만약 딱 나누어 떨어지는 수라면 리스트에 원소를 집어넣는다. 이 부분의 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(list.size() == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>[] answer = &#123;-<span class="number">1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Collections.sort(list);</span><br><span class="line">    <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)</span><br><span class="line">        answer[i] = Integer.parseInt(list.get(i).toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>만약 아무 원소도 들어가있지 않다면 -1을 넣어 반환하고 그렇지 않다면 리스트를 정렬하여 정답배열에 답을 넣는다. 이 부분에서 시간복잡도는 정렬이 있기 때문에 <span class="math inline">\(O(nlogn)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/mod_0_arr.png" width="400" height="300">
</center>
<p><br></p>
<p>화면이 작아 약간 잘렸는데 아무튼 다 맞았다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>문자열 내림차순으로 배치하기</title>
    <url>/2020/12/28/Arrange-String-Descending/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>주어진 문자열을 내림차순으로 정렬하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">strDesOrder</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;Zbcdefg&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span>[] arr = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i] = s.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        String answer = <span class="keyword">new</span> StringBuilder(<span class="keyword">new</span> String(arr)).reverse().toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 문자열을 char[]로 쪼개어 정렬한 뒤, 역순으로 정렬하였다. 총 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/str_des_order.png" width="400" height="300">
</center>
<p><br></p>
<p>자바메소드 중 toCharArray()라는 메소드가 있었다. 앞으론 그 메소드를 활용하여 풀어야겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>평균 구하기</title>
    <url>/2020/12/30/Average/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>평균을 구하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetAverage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">double</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">            sum += arr[i];</span><br><span class="line">        answer = (<span class="keyword">double</span>)sum / (<span class="keyword">double</span>)arr.length;</span><br><span class="line">        System.out.print(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 간단하다 모든 원소의 합을 배열의 크기로 나누면 된다. 시간복잡도는 배열의 크기를 n이라 할 때, <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/get_average.png" width="350" height="500">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>문자열 다루기 기본</title>
    <url>/2020/12/28/Basic-String/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>주어진 문자열이 특정 조건을 만족하는지 확인하는 문제이다. 문자열은 4또는 6의 길이를 갖고 있어야하며, 전부 숫자로 이루어져 있어야한다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandleStr</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;a234&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> answer = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">4</span> || s.length() == <span class="number">6</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            answer = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">                <span class="keyword">int</span> ascii = (<span class="keyword">int</span>)c;</span><br><span class="line">                <span class="keyword">if</span>(c &gt; <span class="number">57</span> || c &lt; <span class="number">48</span>)</span><br><span class="line">                    answer = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 첫번째로 문자열의 길이가 4또는 6을 만족하는지 확인한다. 길이를 만족하면 true로 답을 바꾼다. 그 다음 조건으로 모든 문자열의 문자가 숫자인지 아스키코드로 확인한다. 만약 만족하지 않는 문자가 존재한다면 answer를 false로 바꾼다. 총 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/handle_str_basic.png" width="400" height="300">
</center>
<p><br></p>
<p>다른 사람의 풀이를 보니 NumberFormatException을 활용하여 문제를 푼 사람이 있었다. 문자열을 int로 파싱하는데 에러가 나면 answer를 false로 바꾸는 것이다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>베스트앨범</title>
    <url>/2021/04/05/Best-Albam/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>베스트 앨범에 곡을 넣는 문제이다. 우선순위는 다음과 같다.</p>
<ol type="1">
<li>재생 횟수가 가장 많은 장르를 먼저 배치한다.</li>
<li>장르 안에서 재생 횟수가 많은 곡 두개를 넣는다. 곡이 하나라면 하나만 넣는다.</li>
<li>재생 횟수가 동일할 경우 고유번호(인덱스)가 낮은 것을 우선 배치한다.</li>
</ol>
<p><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvNDI1Nzk=">문제 링크<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>이번 문제는 기존 내 코드와 파이써닉하게 작성된 코드를 비교하려고 한다. 이건 기존에 혼자 풀이한 코드이다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">genres, plays</span>):</span></span><br><span class="line">    answer = []</span><br><span class="line">    genre_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, genre <span class="keyword">in</span> <span class="built_in">enumerate</span>(genres):</span><br><span class="line">        <span class="keyword">if</span> genre_dict.get(genre) <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            genre_dict[genre] = plays[i]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            v = genre_dict.get(genre)</span><br><span class="line">            genre_dict[genre] = v + plays[i]</span><br><span class="line"></span><br><span class="line">    sorted_dict = <span class="built_in">sorted</span>(genre_dict.items(), key = (<span class="keyword">lambda</span> x : x[<span class="number">1</span>]), reverse = <span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> el <span class="keyword">in</span> sorted_dict:</span><br><span class="line">        song_dict = &#123;&#125;</span><br><span class="line">        <span class="keyword">for</span> i, genre <span class="keyword">in</span> <span class="built_in">enumerate</span>(genres):</span><br><span class="line">            <span class="keyword">if</span> genre == el[<span class="number">0</span>]:</span><br><span class="line">                song_dict[i] = plays[i]</span><br><span class="line"></span><br><span class="line">        sorted_song_dict = <span class="built_in">sorted</span>(song_dict.items(), key = (<span class="keyword">lambda</span> x : x[<span class="number">1</span>]), reverse = <span class="literal">True</span>)</span><br><span class="line">        <span class="keyword">for</span> i, item <span class="keyword">in</span> <span class="built_in">enumerate</span>(sorted_song_dict):</span><br><span class="line">            <span class="keyword">if</span> i &gt; <span class="number">1</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            answer.append(item[<span class="number">0</span>])</span><br><span class="line">            </span><br><span class="line">        </span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>
<p><code>genre_dict</code>는 장르별로 총 플레이 횟수를 저장하기 위한 딕셔너리이다. <code>enumerate</code>를 활용하여 장르가 저장되어 있지 않은 경우 새로 등록을 하고, 이미 있는 경우에는 저장된 값에 현재 재생횟수를 추가한다.</p>
<p><code>genre_dict</code>는 <code>sorted</code>를 활용하여 값을 기준으로 내림차순 정렬을 한다. 이렇게 하면 1번 조건을 만족할 수 있게 된다.</p>
<p>이제 2,3번에 관한 처리를 해야한다. <code>sorted_dict</code>에서 값을 꺼내면서 장르마다 그 장르에 속하는 곡을 찾아낸다. 곡을 찾을 경우 곡의 인덱스를 키로 하고 재생횟수를 값으로 하여 딕셔너리에 추가한다.</p>
<p>이 뒤는 1번과 비슷하다. <code>sorted</code>를 다시 활용하여 값을 기준으로 내림차순 정렬한다(<code>sorted_song_dict</code>).</p>
<p>이제 여기서 2개씩 꺼내서 <code>answer</code>리스트에 추가한다. 들어있는 요소가 한개라면 하나만 넣고 종료한다.</p>
<p>알고리즘은 똑같다. 하지만 파이써닉 하게 작성한 코드를 보면 코드 라인이 확실히 줄어든다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">genres, plays</span>):</span></span><br><span class="line">    ht1 = <span class="built_in">dict</span>()</span><br><span class="line">    ht2 = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i, elem <span class="keyword">in</span> <span class="built_in">enumerate</span>(<span class="built_in">zip</span>(genres, plays)):</span><br><span class="line">        g, p = elem</span><br><span class="line">        <span class="keyword">if</span> g <span class="keyword">not</span> <span class="keyword">in</span> ht1:</span><br><span class="line">            ht1[g] = <span class="number">0</span></span><br><span class="line">            ht2[g] = []</span><br><span class="line"></span><br><span class="line">        ht1[g] += p</span><br><span class="line">        ht2[g].append((i, p))</span><br><span class="line">                    <span class="comment">#(g,p)              # -p 내림차순!</span></span><br><span class="line">    sort_ht1 = <span class="built_in">sorted</span>(<span class="built_in">list</span>(ht1.items()), key = <span class="keyword">lambda</span> x: -x[<span class="number">1</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> g,p <span class="keyword">in</span> sort_ht1:</span><br><span class="line">        sort_ht2 = <span class="built_in">sorted</span>(ht2[g], key= <span class="keyword">lambda</span> x: -x[<span class="number">1</span>])</span><br><span class="line">        answer += <span class="built_in">list</span>(<span class="built_in">map</span>(<span class="keyword">lambda</span> x : x[<span class="number">0</span>], sort_ht2))[:<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><code>zip</code>을 통해 기존 인덱스 접근과는 다른 접근 방식을 보여준다.</li>
<li><code>sorted</code>에서 람다함수 부분을 보면 <code>reverse</code>속성이 없고 대신 값에 마이너스를 취한 것을 볼 수 있다. 기능의 차이는 없지만 이렇게 한 경우 코드가 더 간결해 보인다.</li>
<li><code>map</code>과 <code>lambda</code>를 활용하여 곡의 고유번호 2개를 가져온다. 이때 <code>list</code>로 묶에 슬라이싱을 한다.</li>
</ol>
<h2 id="테스트">테스트</h2>
<p><br></p>
<figure>
<img src="/images/programmers/bestalbam.png" alt="테스트 화면" /><figcaption aria-hidden="true">테스트 화면</figcaption>
</figure>
<p><br></p>
<p>통과는 하였지만 파이써닉하게 푸는 것은 아직 더 공부가 필요할 것 같다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level3</category>
      </categories>
  </entry>
  <entry>
    <title>가장 큰 수</title>
    <url>/2021/01/12/Biggest-Num/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>숫자 카드들이 주어지고 이들을 조합하여 가장 큰 수를 만들어 반환하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BiggestNum</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 가장 큰 수</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123;<span class="number">3</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> String[numbers.length];</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : numbers)</span><br><span class="line">        &#123;</span><br><span class="line">            arr[i++] = String.valueOf(n);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(arr, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                String s1 = o1 + o2;</span><br><span class="line">                String s2 = o2 + o1;</span><br><span class="line">                Integer i1 = Integer.parseInt(s1);</span><br><span class="line">                Integer i2 = Integer.parseInt(s2);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">return</span> i2.compareTo(i1);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        StringBuilder buff = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">boolean</span> isZero = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(String s : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Integer.parseInt(s) != <span class="number">0</span>)</span><br><span class="line">                isZero = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span>(!isZero)</span><br><span class="line">                buff.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(buff.length() == <span class="number">0</span>)</span><br><span class="line">            buff.append(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">            </span><br><span class="line">        System.out.println(buff.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 코드는 어렵지 않다. 10-13줄은 int를 문자열로 바꾸어준다. 그리고 이를 정렬하면 되는데, 가장 큰 수를 만들기 위한 정렬은 두 문자를 합쳐보고 더 큰 쪽이 앞에 가도록 하면 된다. 정말 간단하다. 그 부분이 15-26번째 줄이다. 정렬한 문자열을 이제 합쳐주면 되는데 문제 조건을 보면 0이 들어갈 수 있다고 한다. 입력으로 들어온 모든 숫자가 0일 경우를 대비해 isZero를 선언하여 첫 숫자가 0인 것은 들어가지 않도록 했다.</p>
<p>최종 시간복잡도는 numbers의 길이를 n이라 할 때 <span class="math inline">\(O(nlogn)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/biggest_num.png" width="290" height="340">
</center>
<p><br></p>
<p>질문하기를 보고나서야 푼 문제라서 아쉬움이 남는다. 그래도 하나 배웠는데 compare안에 정렬을 새로 정의할 경우 다중 조건문을 쓰면 혼돈의 정렬이 된다는 것이다(이유는 더 공부가 필요하다.). 질문하기에서 나온 해결방법을 그대로 옮긴거라 필자의 아이디어는 아니지만, compare을 작성할 때 주의해야 할 점을 알았으니 만족한다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>휴대폰 번호 가리기</title>
    <url>/2020/12/30/Blind-Phone-Num/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>휴대폰 번호의 마지막 4자리를 제외하고 *로 가리는 문자열을 만드는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneNumBlind</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제 풀이 level1 휴대폰 번호 가리기</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String phone_number = <span class="string">&quot;01033334444&quot;</span>;</span><br><span class="line">        StringBuilder buff = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; phone_number.length()-<span class="number">4</span>; i++)</span><br><span class="line">            buff.append(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">        buff.append(phone_number.substring(phone_number.length()-<span class="number">4</span>, phone_number.length()));</span><br><span class="line">        String answer = buff.toString();</span><br><span class="line"></span><br><span class="line">        System.out.print(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 스트링 버퍼를 생성하여 끝에 4자리를 남겨두고 *을 추가한 다음에 나머지 4자리를 원래 문자열에서 잘라붙여 만들었다. 이 알고리즘의 총 시간복잡도는 휴대폰 번호의 총 길이를 n이라 할 때 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/blind_phone_num.png" width="350" height="500">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>가운데 글자 가져오기</title>
    <url>/2020/12/28/Bring-Middle-Character/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>어떤 문자열이 주어졌을 때 문자열의 가운데 문자를 반환하는 문제이다 만약 문자열이 짝수일 경우 가운데 두 글자를 반환한다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>문자열의 사이즈를 구해서 /2를 하는 식으로 가운데 문자를 출력해줘야한다. 짝수인경우와 홀수인 경우를 다르게 해서 구해주면 된다.</p>
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BringMiddleLetter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;power&quot;</span>;</span><br><span class="line">        String answer = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> l = s.length();</span><br><span class="line">        <span class="keyword">if</span>(l%<span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            answer = String.valueOf(s.charAt(l/<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            answer = String.valueOf(s.charAt((l/<span class="number">2</span>)-<span class="number">1</span>)) + String.valueOf(s.charAt(l/<span class="number">2</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 문자열이 홀수인 경우 문자열의 길이/2로 구할 수 있다. 짝수의 경우 문자열의 길이/2-1과 문자열의 길이/2로 구할 수 있다.</p>
<p>이 문제의 시간복잡도는 <span class="math inline">\(O(1)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/bringmiddleletter.png" width="400" height="300">
</center>
<p><br></p>
<p>홀수 길이와 짝수 길이로 분기처리를 하지 않고도 문제를 풀 수 있는 방법이 있었다. substring을 반환하는 함수의 범위를 [(문자열의 길이-1)/2, (문자열의 길이)/2 +1)로 하면 된다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>예산</title>
    <url>/2020/12/30/Budget/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>d는 지원을 바라는 부서들의 예산들이고 총 예산은 budget이다. 최대한 지원해 줄 수 있는 부서가 몇 개인지 반환하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Budget</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level1 예산</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] d = &#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> budget = <span class="number">9</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(d);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> money : d)</span><br><span class="line">        &#123;</span><br><span class="line">            budget -= money;</span><br><span class="line">            <span class="keyword">if</span>(budget &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            answer++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(answer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 최대한 많은 부서에게 예산을 지원해주기 위해선 예산 청구가 적은 부서부터 나누어주면 된다. 이를 위해 예산 목록을 오름차순으로 정렬하고 예산이 감당할 수 있는 만큼 돈을 뺀다. 이 문제에서 청구 예산의 일부를 주는 것은 아니었으므로 난이도가 쉬웠다.</p>
<p>시간복잡도는 모든 부서에게 예산을 나눠줄 수 있을 때 d의 크기를 n이라 하면 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/budget.png" width="350" height="500">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>캐시</title>
    <url>/2021/02/01/Cache/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>캐시의 용량과 도시이름이 주어질 때, LRU 캐시 알고리즘을 사용할 때, 총 반응 시간을 계산하는 코드이다. 도시 이름은 대소문자를 가리지 않는다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedHashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 Level2 캐시</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cacheSize = <span class="number">3</span>;</span><br><span class="line">        String[] cities = &#123;<span class="string">&quot;Jeju&quot;</span>, <span class="string">&quot;Pangyo&quot;</span>, <span class="string">&quot;Seoul&quot;</span>, <span class="string">&quot;NewYork&quot;</span>, <span class="string">&quot;LA&quot;</span>, <span class="string">&quot;Jeju&quot;</span>, <span class="string">&quot;Pangyo&quot;</span>, <span class="string">&quot;Seoul&quot;</span>, <span class="string">&quot;NewYork&quot;</span>, <span class="string">&quot;LA&quot;</span>&#125;;</span><br><span class="line">        Map&lt;String, Integer&gt; map = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(cacheSize, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span>(cacheSize == <span class="number">0</span>)</span><br><span class="line">            answer = cities.length*<span class="number">5</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(String s : cities)</span><br><span class="line">            &#123;</span><br><span class="line">                s = s.toLowerCase();</span><br><span class="line">                <span class="comment">//맵에 없는 경우</span></span><br><span class="line">                <span class="keyword">if</span>(map.getOrDefault(s, <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(map.size() == cacheSize)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Map.Entry leastUsedEntry = map.entrySet().iterator().next();</span><br><span class="line">                        String key = (String)leastUsedEntry.getKey();</span><br><span class="line">                        map.remove(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                    map.put(s, <span class="number">1</span>);</span><br><span class="line">                    answer += <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    answer++;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 자바는 정말 놀라운 언어이다. 호출 빈도에 따라서 정렬해주는 맵이 이미 존재했다! LinkedHashMap에서 호출 빈도에 따른 정렬을 제공하는데, 평소에는 false로 되어있다. 이를 true로 바꿔주면 LRU를 구현하기 한 층 쉬워진다.</p>
<p>일단 캐시 사이즈가 0인 경우를 따로 처리한다. 0인 경우 맵의 크기가 0이 되어 예외가 발생하기 때문이다. 0인 경우에는 모든 도시에서 cache miss가 발생하므로 전체 크기에 5를 곱한 값을 반환한다. 그렇지 않은 경우 캐시를 활용한다. 만약 들어온 도시 이름이 맵에 없는 경우 두 가지 경우로 나뉜다.</p>
<ol type="1">
<li>캐시가 이미 다 차서 오래된 것을 제거해야 하는 경우</li>
<li>캐시에 아직 여유 공간이 있는 경우</li>
</ol>
<p>1번의 경우 맵에서 호출된지 가장 오래된 원소를 지워야한다. 이는 map에서 첫번째 원소를 제거하면 되므로 iterator의 첫번째 키값을 받아 제거한다. 이 뒤에 원소를 추가한다. 이 과정을 거치고 정답에 5를 더해준다.</p>
<p>만약 캐시에 도시 이름이 있을 경우 반응시간을 1늘려주면 된다.</p>
<p>호출 시간에 따른 정렬은 시간복잡도가 정확히 나타나있지 않다. 다만 <span class="math inline">\(logn\)</span>으로 추측이 간다(이진 탐색을 활용할 가능성이 높다). 따라서 최종시간복잡도는 <span class="math inline">\(O(nlogn)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/cache.png" width="290" height="500">
</center>
<p><br></p>
<p>자바 기본라이브러리를 잘 익혀야겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>후보키</title>
    <url>/2021/02/02/Candidate-Key/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>릴레이션이 주어질 때, 후보키가 될 수 있는 경우의 수를 구하는 문제이다. 후보키에 대한 자세한 설명은 문제 원문에 주어졌으니 참고하길 바란다.</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvNDI4OTAjcW5h">문제 링크<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CandidateKey</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 후보키</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[][] table;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> answer;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[][] relation = &#123;</span><br><span class="line">            &#123;<span class="string">&quot;b&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;b&quot;</span>,<span class="string">&quot;2&quot;</span>,<span class="string">&quot;7&quot;</span>,<span class="string">&quot;1&quot;</span>,<span class="string">&quot;b&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;8&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;7&quot;</span>,<span class="string">&quot;5&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;9&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;3&quot;</span>,<span class="string">&quot;0&quot;</span>,<span class="string">&quot;a&quot;</span>,<span class="string">&quot;f&quot;</span>,<span class="string">&quot;9&quot;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        answer = <span class="number">0</span>;</span><br><span class="line">        table = <span class="keyword">new</span> String[relation.length][relation[<span class="number">0</span>].length];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; relation.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; relation[<span class="number">0</span>].length; j++)</span><br><span class="line">                table[i][j] = relation[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">1</span>;</span><br><span class="line">        String idx = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(k &lt;= relation[<span class="number">0</span>].length)</span><br><span class="line">            ReturnIndex(<span class="number">0</span>, k++, idx, -<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReturnIndex</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> k, String idx, <span class="keyword">int</span> start_idx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; table.length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                String[] arr = idx.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                StringBuilder buff = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">for</span>(String s : arr)</span><br><span class="line">                &#123;</span><br><span class="line">                    buff.append(table[i][Integer.parseInt(s)]);</span><br><span class="line">                    buff.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(map.getOrDefault(buff.toString(), <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    map.clear();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(buff.toString(), <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(String s : keys)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span>[] key = s.toCharArray();</span><br><span class="line">                <span class="keyword">char</span>[] idx_arr = idx.toCharArray();</span><br><span class="line">                Arrays.sort(key);</span><br><span class="line">                Arrays.sort(idx_arr);</span><br><span class="line">                <span class="keyword">int</span> k_i = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idx_arr.length; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(key[k_i] == idx_arr[i])</span><br><span class="line">                    &#123;</span><br><span class="line">                        k_i++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(k_i == key.length)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            answer++;</span><br><span class="line">            keys.add(idx);</span><br><span class="line">            map.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = start_idx+<span class="number">1</span>; i &lt; table[<span class="number">0</span>].length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ReturnIndex(size+<span class="number">1</span>, k, idx+String.valueOf(i), i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 코드가 긴 편인데 과정을 살펴보면 후보키가 될 수 있는 모든 조합을 만들어보고 검사하는 것이다. 원소의 개수가 k개인 부분집합을 검사해주는 함수를 만들어서 k를 1부터 행의 갯수만큼 돌려보면 모든 경우의 수를 다 볼 수 있다. 메인쪽은 간단하기 때문에 함수만 보도록하자.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReturnIndex</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> k, String idx, <span class="keyword">int</span> start_idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; table.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            String[] arr = idx.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            StringBuilder buff = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">for</span>(String s : arr)</span><br><span class="line">            &#123;</span><br><span class="line">                buff.append(table[i][Integer.parseInt(s)]);</span><br><span class="line">                buff.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(map.getOrDefault(buff.toString(), <span class="number">0</span>) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                map.clear();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(buff.toString(), <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String s : keys)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span>[] key = s.toCharArray();</span><br><span class="line">            <span class="keyword">char</span>[] idx_arr = idx.toCharArray();</span><br><span class="line">            <span class="keyword">int</span> k_i = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; idx_arr.length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(key[k_i] == idx_arr[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    k_i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(k_i == key.length)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        answer++;</span><br><span class="line">        keys.add(idx);</span><br><span class="line">        map.clear();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start_idx+<span class="number">1</span>; i &lt; table[<span class="number">0</span>].length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ReturnIndex(size+<span class="number">1</span>, k, idx+String.valueOf(i), i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>매개변수에 대해 설명을 하자면 size는 현재 집합에 들어가있는 원소의 개수, k는 만들고자 하는 부분집합의 크기이다. idx는 부분집합에 들어가있는 원소를 나타낸다. 가령 1,2행으로 만들고자 한다면 idx에는 "12"가 들어가있다. start_idx는 이제부터 집어넣을 행을 나타낸다. 중복을 없애기 위해 strat_idx를 넣었다고 보면 된다.</p>
<p>종료조건을 먼저 생각해보자 size가 k가 되면 일단 튜플을 고유하게 분류할 수 있는지 봐야한다. 이를 위해 map을 활용하였다. idx에 있는 행번호를 가져와 map의 키를 생성한다. 이 예제에서 만약 idx가 "12"라면 "b 2", "b 2", "1 0", "7 5","3 0"으로 만들어질 것이다. 키를 만들 때 공백을 넣어주는데 이유가 있다. 수학11점과 과학1점, 과학11점과 수학1점은 다르기 때문이다. 숫자만 합하면 111이지만 다른 정보이기 때문에 다른 키 값으로 간주된다.</p>
<p>키를 만들 때마다 맵에서 똑같은 키 값이 존재하는 지 확인한다. 만약 똑같은 키값이 있다면 1이 반환되므로 이때는 맵을 클리어한 뒤 바로 함수를 종료한다.</p>
<p>맵에서 중복되지 않으면 고유성을 통과했으니 이제 유일성을 확인할 차례이다. 이 부분에서 꽤나 골머리를 앓았는데 contains를 쓰면 틀린다는 사실을 몰랐기 때문이다. "abcd"에서 "ad"는 부분집합이지만 contains로는 이를 판별할 수 없다. 그래서 이를 위한 처리를 해야한다. 두 문자열을 문자배열로 바꾼 뒤, 이미 있는 키들의 부분집합 관계인지 하나하나 확인하는 코드를 짰다. 만약 key가 idx의 부분집합이라면, k_i가 key의 크기가 될 것이고 이 때 바로 함수를 종료한다.</p>
<p>유일성도 통과가 되었다면, 정답을 1증가하고 키값에 idx를 추가한다. 맵도 전부 지워준다.</p>
<p>만약 사이즈를 만족하지 못했다면 원소를 더 넣어봐야 하므로 start_idx+1부터 행의 끝까지 함수를 재호출한다.</p>
<p>최종시간복잡도는 행의 길이를 n이라 했을 때 모든 부분집합을 따져보므로 <span class="math inline">\(O(n^n)\)</span>이다. 살인적인 시간복잡도지만 테스트케이스 크기가 크지 않다는 것에 주목하자.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/candidate_key.png" width="290" height="530">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>카펫</title>
    <url>/2021/01/15/Carpet/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>카펫의 모양이 노란색이 중앙 그 테두리를 갈색이 감싸는 형태이다. 갈색과 노란색 타일이 주어질 때 이 카펫의 모양을 만들기 위한 가로, 세로의 길이를 구하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Carpet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 카펫</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> brown = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> yellow = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> sum = (brown+<span class="number">4</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">3</span>, w = sum -<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">while</span>(w &gt;= h)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((h-<span class="number">2</span>)*(w-<span class="number">2</span>) == yellow)</span><br><span class="line">            &#123;</span><br><span class="line">                answer[<span class="number">0</span>] = w;</span><br><span class="line">                answer[<span class="number">1</span>] = h;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            h++;</span><br><span class="line">            w--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 가로 세로 길이를 합친 길이를 sum이라 할 때, 다음과 같이 구할 수 있다. 이 식은 가로x세로-4가 갈색 타일의 합인 식에서 유도했다. 문제에서 yellow는 1이상이므로 가로와 세로길이는 최소 3이상이어야 한다. 따라서 초기 세로의 길이는 3, 가로의 길이는 sum -3으로 한다. 다음으로는 while문을 돌면서 노란타일을 구한다. 노란타일의 수는 사각형 넓이에서 겉 테두리 영역을 제외한 것이므로 각각의 길이에 -2를 하여 구한다. 이 수가 문제에 주어진 노란타일의 수와 일치하면 가로와 세로 값을 배열에 담아 반환한다.</p>
<p>이 문제의 시간복잡도는 w의 초기 길이를 n이라 할 때, <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/carpet.png" width="290" height="350">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>시저 암호</title>
    <url>/2020/12/29/Ciser-Code/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>시저 암호를 프로그래밍하는 문제이다. 시저 암호를 만드는 방법은 문자열을 아스키코드로 n만큼 미뤄서 만들면 된다. 가령 abc가 있고 2가 주어진다면 cde이런식으로 만들 수 있다. 문제에서 알파벳에 대해서만 만들고 공백은 건들지 말라 했으므로, 알파벳에 대해서만 처리를 해주면 된다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CaesarCode</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level1 시저 암호</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;AB&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">1</span>;</span><br><span class="line">        StringBuffer buff = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            <span class="keyword">int</span> ascii = (<span class="keyword">int</span>) c;</span><br><span class="line">            <span class="keyword">if</span>(ascii &gt;= <span class="number">65</span> &amp;&amp; ascii &lt;= <span class="number">90</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ascii += n;</span><br><span class="line">                <span class="keyword">if</span>(ascii &gt; <span class="number">90</span>)</span><br><span class="line">                    ascii -= <span class="number">26</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ascii &gt;= <span class="number">97</span> &amp;&amp; ascii &lt;= <span class="number">122</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                ascii += n;</span><br><span class="line">                <span class="keyword">if</span>(ascii &gt; <span class="number">122</span>)</span><br><span class="line">                    ascii -= <span class="number">26</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            buff.append(String.valueOf((<span class="keyword">char</span>) ascii));</span><br><span class="line">        &#125;</span><br><span class="line">        String answer = buff.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 문자열을 문자로 하나씩 뜯어서 본다. 만약 대문자라면 90을 넘어갈 경우 대문자 A로 돌아가야 한다. 따라서 첫번째 if문을 보면 대문자에 속할 경우 n을 더하고 Z의 아스키코드를 넘아가면 A로 돌아가게 하였다. 두번째 if문도 똑같은 원리로 하면 된다. 공백의 경우 아스키코드를 늘릴 필요가 없으므로 그대로 추가하면 된다. 총 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/ceasar_code.png" width="400" height="300">
</center>
<p><br></p>
<p>필자의 경우 26을 빼주는 식으로 했는데 조금 다르게 풀 수도 있다. 주어진 문자가 소문자인지 대문자인지 판별한 후에(자바에는 친절하게 이 메소드를 제공한다.) 만약 소문자라면</p>
<p>((c - 'a')+n)%26 + 'a'</p>
<p>이런식으로 구할 수도 있다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>콜라츠 추측</title>
    <url>/2020/12/30/Colatz-Guess/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>콜라츠 추측을 몇 번 반복해야 1이 나오는지 계산하는 문제이다. 짝수인 경우 2로 나누고, 홀수인 경우 3을 곱하고 1을 더한다. 500번을 계산해도 1이 안된다면 -1을 반환한다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollatzGuess</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level1 콜라스 추측</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> ll = num;</span><br><span class="line">        <span class="keyword">while</span>(cnt &lt;= <span class="number">500</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ll == <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ll % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                ll /= <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                ll = ll*<span class="number">3</span>+<span class="number">1</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt &lt;= <span class="number">500</span>)</span><br><span class="line">            answer = cnt;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            answer = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        System.out.print(answer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 문제에서 제시한대로 코드를 짜면 된다. cnt를 0으로 초기화하고, 짝수면 나누기, 홀수면 곱하기 더하기 연산을 하면된다. 중요한 부분은 int를 쓰지 않고 long을 쓴 것을 볼 수 있는데, 이유는 곱하기 연산을 하면서 int값을 초과할 수 있기 때문이다. 필자는 이것 때문에 한번 틀렸었다. 이 문제 정의에서 이 알고리즘의 시간복잡도는 <span class="math inline">\(O(1)\)</span>이다. 왜냐하면 500이라는 횟수가 최대 실행 횟수이기 때문이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/collatz_guess.png" width="350" height="500">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>압축</title>
    <url>/2021/02/03/Compress/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>LZW압축을 구현하는 문제이다. 압축 알고리즘에 대한 상세한 설명은 아래 링크에서 확인하고 오길 바란다.</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvMTc2ODQ=">문제 링크<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Compress</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 압축</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String msg = <span class="string">&quot;KAKAO&quot;</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; answer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            map.put(String.valueOf((<span class="keyword">char</span>)(<span class="string">&#x27;A&#x27;</span>+i)), i+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> w = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">while</span>(c &lt;= msg.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> value = map.getOrDefault(msg.substring(w,c), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span>(value != <span class="number">0</span>)</span><br><span class="line">            &#123;      </span><br><span class="line">                c++;</span><br><span class="line">                <span class="keyword">if</span>(c &gt; msg.length())</span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>; </span><br><span class="line">                &#125;</span><br><span class="line">                   </span><br><span class="line">                value = map.getOrDefault(msg.substring(w,c), <span class="number">0</span>);</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            answer.add(map.get(msg.substring(w, c-<span class="number">1</span>)));</span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">                c--;</span><br><span class="line">            map.put(msg.substring(w, c), map.size()+<span class="number">1</span>);</span><br><span class="line">            w = c-<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 사전을 map으로 구현하였다. 일단 A부터 Z까지 기본 단어를 만들어 놓는다. 그리고 w에서 c까지의 문자열을 반복해서 본다. c의 값을 늘려가며 처음으로 map에 없는 단어가 나올 경우 맵에 해당 문자열을 저장하고 바로 직전 반복의 문자열은 색인 값을 반환한다. 그리고 w에 다음 위치인 c-1을 집어넣으면 되는 단순한 알고리즘이다. 하지만 이 반복은 c가 메시지의 길이에 달했을 때 배열범위에 문제가 생기므로 이에 대한 처리를 따로 해야한다. flag와 관련된 부분이 그 부분이다.</p>
<p>최종 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/compress.png" width="290" height="510">
</center>
<p><br></p>
<p>flag관련된 함수를 없앨 수 있는지 고민해봐야겠다. 깔끔하지 않다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>섬 연결하기</title>
    <url>/2021/03/02/Connect-Island/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<h3 id="섬-연결하기">섬 연결하기</h3>
<p>섬 사이를 연결하는 다리를 짓는 건설비용이 주어진다. 모든 섬을 연결하려고 할 때, 드는 건설비용의 최솟값을 구하라.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Island</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Island</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Island</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        <span class="keyword">this</span>.e = e;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Island arg0)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> arg0.v &gt;= <span class="keyword">this</span>.v ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectingIsland</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level3 섬 연결하기</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] parent;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> costs[][] = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>, <span class="number">0</span>, <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>, <span class="number">0</span>, <span class="number">7</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        parent = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            parent[i] = i;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        List&lt;Island&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; costs.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            Island temp = <span class="keyword">new</span> Island(costs[i][<span class="number">0</span>], costs[i][<span class="number">1</span>], costs[i][<span class="number">2</span>]);</span><br><span class="line">            list.add(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        Collections.sort(list);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//matrix 만들기</span></span><br><span class="line">        <span class="keyword">for</span>(Island land : list)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(find(land.e) == find(land.s))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            union(land.e, land.s);</span><br><span class="line">            answer += land.v;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a == parent[a])</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        <span class="keyword">return</span> parent[a] = find(parent[a]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">union</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a_root = (find(a));</span><br><span class="line">        <span class="keyword">int</span> b_root = (find(b));</span><br><span class="line">        <span class="keyword">if</span>(a_root != b_root)</span><br><span class="line">            parent[a_root] = b;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 크루스칼 알고리즘을 사용하면 된다. 필자는 분명 수업시간에 들었던 것 같은데 막상 구현하려고 하니 다 까먹었다.. 그래서 이번 문제를 통해 다시 정리할 수 있었다. 크루스칼 알고리즘을 간단히 설명하자면 간선의 비용이 가장 적은 것 부터 선택해 나가는 알고리즘이다. 다만 사이클이 형성되어서는 안된다. 그렇다면 간선을 선택할 때 마다 사이클이 발생하는지 봐야하는데 이 때 쓰이는 자료구조가 union-find이다.</p>
<p>union-find를 구현하기 위해 parent배열을 선언했다. parent 배열은 자신의 부모가 누구인지 저장하는 배열이다. 처음에는 자신의 위에 아무도 없으므로 배열의 인덱스로 값을 초기화한다.</p>
<p>union-find에선 두 가지 함수가 필요한데, 하나는 find함수이고, 하나는 union이다. find는 해당 노드의 최상단 부모를 찾아주는 함수이다. 최상단 부모는 parent값과 노드 값이 일치할 것이므로 그 때의 값을 반환하면 된다. 그렇지 않다면 재귀를 통해 부모를 찾아간다. 이 때, return문을 보면 find한 값을 parent[a]에 대입하는 것을 볼 수 있는데, 이 과정을 거치지 않는다면 <span class="math inline">\(O(n)\)</span>으로 수행 시간이 길어지기 때문이다.</p>
<p>union함수는 두 노드를 합쳐주는 역할을 한다. a의 최상단 부모값과 b의 최상단 부모값을 찾아 이 둘이 같지 않다면 부모를 통일해준다. 코드 자체는 어렵지 않다.</p>
<p>필자는 섬을 표현하기 위한 클래스 Island를 새로 선언하였다. 시작점을 s, 끝점을 e, 비용을 v로 하였다. 정렬기준은 비용을 기준으로 하였다. 메인에서 읽어들인 값을 리스트에 저장하여 정렬하였다. 이렇게 하면, 간선비용을 기준으로 하여 오름차순으로 정렬 할 수 있다.</p>
<p>오름차순으로 정렬한 Island를 순회하며, 사이클이 형성될 경우 간선을 선택하지 않고 그렇지 않을 경우 그 값을 answer에 더하고 두 섬이 합해지는 걸 나타내기 위해 union함수를 사용한다. 사이클인지 아닌지 확인하는 방법은 두 섬의 최상단 부모가 같은지 확인하면 된다.</p>
<p>간선의 최대 개수는 <span class="math inline">\(n*(n-1) \over 2\)</span>이므로, 최종 시간복잡도는 <span class="math inline">\(O(n^2log_2n^2)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/connect_island.png" width="290" height="210">
</center>
<p><br></p>
<p>union-find를 연습했었는데 다시 하려니 또 까먹었다. 최적화하는 방법까지 잘 익혀야겠다. 중요한건 복습 또 복습이다.</p>
<p>다른 사람의 풀이를 보니 별도 클래스를 선언하지 않고 람다식으로 특정값을 기준으로 정렬하는 것을 보았다. 앞으로도 잘 쓰일 것 같으니 여기에 메모해 둔다.</p>
<p><code>Arrays.sort(costs, (a, b) -&gt; Integer.compare(a[2], b[2]));</code></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level3</category>
      </categories>
  </entry>
  <entry>
    <title>단속 카메라</title>
    <url>/2021/03/04/Control-Camera/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>최대한 많은 overlap을 하나로 묶을 때, 나오는 집합의 크기를 구하는 문제이다. 상세한 설명은 아래에 계속하겠다. <span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvNDI4ODQ=">문제 링크<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Section</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Section</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> s;</span><br><span class="line">    <span class="keyword">int</span> e;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Section</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> e)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.s = s;</span><br><span class="line">        <span class="keyword">this</span>.e = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Section sec)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.s - sec.s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpeedTrap</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//프로그래머스 level3 단속카메라</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] routes = &#123;</span><br><span class="line">            &#123;-<span class="number">20</span>, <span class="number">15</span>&#125;,</span><br><span class="line">            &#123;-<span class="number">14</span>, -<span class="number">5</span>&#125;,</span><br><span class="line">            &#123;-<span class="number">18</span>, -<span class="number">13</span>&#125;,</span><br><span class="line">            &#123;-<span class="number">5</span>, -<span class="number">3</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Section&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; routes.length; i++)</span><br><span class="line">            pq.add(<span class="keyword">new</span> Section(routes[i][<span class="number">0</span>], routes[i][<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> cam_cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!pq.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> end = pq.peek().e;</span><br><span class="line">            <span class="keyword">while</span>(!pq.isEmpty() &amp;&amp; pq.peek().s &lt;= end)</span><br><span class="line">            &#123;</span><br><span class="line">                end = pq.peek().e &lt; end ? pq.peek().e : end;</span><br><span class="line">                pq.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            cam_cnt++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(cam_cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 알고리즘의 이해를 돕기 위해 아래의 그림을 보자</p>
<p><br></p>
<center>
<img src="/images/programmers/cam.jpeg" width="1184" height="431">
</center>
<p><br></p>
<p>프로그래머스에서 주어진 구간을 수평선 상에 표시하였다. 최소한의 카메라를 설치해야한다는 것은 최대한 차가 많이 다닐 것 같은 길목에 카메라를 놓아야 한다는 것이다. 그 말은 구간이 최대한 많이 겹치는 쪽에 카메라를 놓으면 된다는 것이다.</p>
<p>이를 구현하기 위해서 <code>Section</code>클래스를 선언하였다. 구간의 처음과 끝을 저장해두며, 정렬을 할 때 구간의 시작점을 기준으로 정렬한다.</p>
<p>우선순위 큐를 선언하여 Section을 집어넣는다. 이 큐에서 하나씩 빼면서 최대한 겹칠 수 있는 구간들을 묶을 것이다. 일단 <code>end</code>를 큐의 첫원소의 도착구간으로 설정한다. 그리고 <code>end</code>보다 출발점이 작은 구간은 무조건 겹치므로 이들을 팝한다. 이 때, 팝한 것들 중에 기존 <code>end</code>보다 작은 종료구간이 있다면 그 값으로 대체한다.</p>
<p>이 반복이 마치면 더 이상 겹치는 구간이 없다는 의미이므로 하나로 묶는 작업이 끝난 것이다. 카메라를 설치한다는 의미로 <code>cam_cnt</code>를 1가한다.</p>
<p>우선순위 큐를 사용하였기 때문에 구간의 개수를 n이라 하였을 때, 최종 시간복잡도는 <span class="math inline">\(O(nlogn)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/camera.png" width="290" height="130">
</center>
<p><br></p>
<p>학교 수업에서 해봤던 문제라 수월하게 풀 수 있었다. 앞으로 나만의 코테 데이터베이스를 더 쌓아나가야지.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level3</category>
      </categories>
  </entry>
  <entry>
    <title>올바른 괄호</title>
    <url>/2021/01/19/Correct-Bracket/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>열린괄호와 닫힌괄호로 이루어진 문자열이 올바른 괄호식인지 확인하는 문제이다. 올바른 괄호식이란 열린 괄호와 닫힌 괄호의 수가 동일해야 하며, 열렸으면 반드시 닫혀야한다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CorrectBracket</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 올바른 괄호</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;()()&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> answer = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> open = <span class="number">0</span>, close = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                open++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                close++;</span><br><span class="line">            <span class="keyword">if</span>(open &lt; close)</span><br><span class="line">            &#123;</span><br><span class="line">                answer = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(open != close)</span><br><span class="line">            answer = <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 열린괄호의 개수를 저장할 변수 open과 닫힌 괄호의 개수를 저장할 변수 close를 선언한다. 이들의 수를 세나가며 만약 close가 open보다 많아지는 경우면 모든 열린괄호가 짝지어지는 것이 아니므로 false를 반환한다. 반복문을 탈출했어도 열린괄호가 닫힌 괄호보다 많은 경우가 있으므로 이를 체크하기 위해 둘의 수가 동일한지 확인한다.</p>
<p>최종 시간복잡도는 문자열의 길이를 n이라 할 때, <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/correct_bracket.png" width="290" height="530">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>크레인 인형뽑기 게임</title>
    <url>/2020/12/22/Crain-Pick-Doll/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>말그대로 인형뽑기 게임이다. 게임판은 2차원 배열(board)이 주어진다. 그리고 인형을 뽑는 순서로 1차원 배열(moves)이 주어진다. 뽑은 인형은 바구니에 쌓이고 만약 새로 뽑은 인형이 바구니의 가장 위에 있는 인형과 동일한 인형일 경우 인형은 터진다. 이때 터진 인형의 개수를 반환하면 된다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>이 문제를 해결하기 위해 가장 brute force적인 방법을 생각해보면 1. moves의 원소를 순회하면서 0이 아닌 지점까지 아래로 파고든다 2. 인형을 꺼낸 뒤, 해당 위치를 0으로 만든다. 3. 뽑은 인형은 스택에 저장한다. 만약 스택의 가장 위에 있는 인형과 똑같은 id를 공유한다면, 스택에서 pop한 뒤 answer에 2를 더해준다.</p>
<p>이 경우 시간복잡도는 <span class="math inline">\(O(n^2)\)</span>이 된다.</p>
<p>같은 <span class="math inline">\(O(n^2)\)</span>이긴 하지만, 필자는 시간을 더 줄이기 위해 top이란 1차원 배열을 추가로 생성한다. top의 원소는 각 열에서 인형이 놓여있는 가장 높은 위치를 말한다.</p>
<figure>
<img src="/images/programmers/crane_game_101.png" alt="crane_game_101" /><figcaption aria-hidden="true">crane_game_101</figcaption>
</figure>
<p>이 경우의 top은 각각 [3,2,1,3,1]이다(맨 윗줄이 0번째).</p>
<p>이렇게 하면 앞서 말한 1번 과정에서 시간을 단축할 수 있다. 계속 아래로 파고드는 것이 아니라 해당 인덱스로 바로 접근하는 것이기 때문이다. 이제 코드와 함께 보도록 하자. 코드는 자바로 작성되었다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrainDoll</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] board = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>&#125;,&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span>[] moves = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] top = <span class="keyword">new</span> <span class="keyword">int</span>[board.length];</span><br><span class="line">        Arrays.fill(top, <span class="number">40</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; board.length; c++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; board.length; r++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[r][c] != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    top[c] = r;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; moves.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(top[moves[i]-<span class="number">1</span>] &lt; board.length)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> doll = board[top[moves[i]-<span class="number">1</span>]][moves[i]-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(stack.empty())</span><br><span class="line">                    stack.push(doll);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(stack.peek() == doll)</span><br><span class="line">                &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    answer += <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    stack.push(doll);</span><br><span class="line">                </span><br><span class="line">                top[moves[i]-<span class="number">1</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>전체코드</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[][] board = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">3</span>&#125;,&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span>[] moves = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] top = <span class="keyword">new</span> <span class="keyword">int</span>[board.length];</span><br><span class="line">Arrays.fill(top, <span class="number">40</span>);</span><br></pre></td></tr></table></figure>
<p>문제 세팅을 위한 코드이다 board와 moves를 설정하고 터트려질 인형의 수를 answer라고 한다. 그리고 top의 길이는 board의 가로 또는 세로 사이즈로 설정한다. 이때 top을 0으로 초기화하면 안되는 이유는 유효한 값이기 때문이다. 문제에서 보드판은 30*30까지 될 수 있고 이말은, 0~29까지는 실제 인형이 있는 위치를 나타내는 숫자이다. 따라서 이 범위내에 있지 않은 숫자로 초기화한다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; board.length; c++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; board.length; r++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(board[r][c] != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            top[c] = r;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>top을 초기화하는 코드이다 board를 순회하는데 순회는 위에서 아래로 한줄씩 본다. 만약 처음으로 0이 아닌 숫자가 나오면 그 위치를 저장하고 다음 줄로 넘어간다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; moves.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(top[moves[i]-<span class="number">1</span>] &lt; board.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> doll = board[top[moves[i]-<span class="number">1</span>]][moves[i]-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span>(stack.empty())</span><br><span class="line">            stack.push(doll);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(stack.peek() == doll)</span><br><span class="line">        &#123;</span><br><span class="line">            stack.pop();</span><br><span class="line">            answer += <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            stack.push(doll);</span><br><span class="line">        </span><br><span class="line">        top[moves[i]-<span class="number">1</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(answer);</span><br></pre></td></tr></table></figure>
<p>바구니를 나타낼 stack을 선언한다 밑에 있는 for문은 앞서말한 3번과정을 나타낸다. 뽑아야하는 열이 주어질 때 top이 유효범위 내에 있다면 인형의 id를 저장한다. 만약 바구니가 비어있다면 스택에 인형을 집어넣는다. 만약 바구니의 맨 위에 있는 인형과 뽑은 인형이 같다면(else if문) 스택에서 인형을 꺼내고, 답을 2증가한다. 맨 위에있는 인형과 뽑은 인형이 같지 않다면 바구니에 넣어준다. 인형을 뽑고나면 top의 해당원소를 1증가하여 인형이 뽑혔다는 것을 저장한다.</p>
<h2 id="테스트">테스트</h2>
<figure>
<img src="/images/programmers/crane_game_result.png" alt="crane_game_result" /><figcaption aria-hidden="true">crane_game_result</figcaption>
</figure>
<p>코딩테스트를 너무 늦게 준비해서 조급한 마음도 있지만 1레벨부터 찬찬히 풀어가야겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>다트게임</title>
    <url>/2020/12/31/DartGame/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>다트게임을 해서 총 몇점을 득점했는지 계산하는 문제이다. 점수는 0~10점이며 옵션에 따라 점수가 바뀔 수 있다. S는 해당 점수의 1제곱, D는 제곱, T는 세제곱을 하는 것이며, <em>은 이전 점수와 해당 점수의 2배(만약에 이전 점수가 없으면 해당 점수만 2배 한다.)이다. #은 해당 점수를 빼는 것이다. </em>과 #은 중첩될 수 있다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DartGame</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level1 다트 게임</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String dartResult = <span class="string">&quot;1S2D*3T&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">char</span>[] arr = dartResult.toCharArray();</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++)</span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="keyword">if</span>(Character.isDigit(arr[i]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> n = Integer.parseInt(String.valueOf(arr[i]));</span><br><span class="line">                <span class="keyword">if</span>(Character.isDigit(arr[i+<span class="number">1</span>]))</span><br><span class="line">                &#123;</span><br><span class="line">                    n = <span class="number">10</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(arr[i+<span class="number">1</span>] == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">                    s.push(Integer.parseInt(String.valueOf(n)));</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(arr[i+<span class="number">1</span>] == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">                    s.push((<span class="keyword">int</span>)Math.pow(n, <span class="number">2</span>));</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    s.push((<span class="keyword">int</span>)Math.pow(n, <span class="number">3</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s.size() == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> n = Integer.parseInt(String.valueOf(s.peek()));</span><br><span class="line">                    s.pop();</span><br><span class="line">                    s.push(n*<span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> n1 = Integer.parseInt(String.valueOf(s.peek()));</span><br><span class="line">                    s.pop();</span><br><span class="line">                    <span class="keyword">int</span> n2 = Integer.parseInt(String.valueOf(s.peek()));</span><br><span class="line">                    s.pop();</span><br><span class="line">                    s.push(n2*<span class="number">2</span>);</span><br><span class="line">                    s.push(n1*<span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(arr[i] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> n = Integer.parseInt(String.valueOf(s.peek()));</span><br><span class="line">                s.pop();</span><br><span class="line">                s.push(n*(-<span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            answer += s.peek();</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 부분부분 살펴보자. 일단 스트링을 문자배열로 쪼갠다음 이 문자를 하나씩 보면서 계산할 것이다. *옵션을 계산하기 위해 스택도 함께 선언하였다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(Character.isDigit(arr[i]))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = Integer.parseInt(String.valueOf(arr[i]));</span><br><span class="line">    <span class="keyword">if</span>(Character.isDigit(arr[i+<span class="number">1</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        n = <span class="number">10</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(arr[i+<span class="number">1</span>] == <span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">        s.push(Integer.parseInt(String.valueOf(n)));</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(arr[i+<span class="number">1</span>] == <span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        s.push((<span class="keyword">int</span>)Math.pow(n, <span class="number">2</span>));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        s.push((<span class="keyword">int</span>)Math.pow(n, <span class="number">3</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 에 대해서 처리해주는 부분이다. 일단 들어온 문자가 숫자인지 확인한다. 이때 10에 대한 처리를 따로 한다. 똑같은 1이 들어와도 1일 수도 있고, 10일 수도 있기 때문이다. 이를 알기 위해 다음 문자도 숫자인지 확인하고 숫자라면 n에 10을 대입한다. 그리고 S,D,T에 따른 제곱처리를 하고 스택에 쌓는다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(arr[i] == <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.size() == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(String.valueOf(s.peek()));</span><br><span class="line">        s.pop();</span><br><span class="line">        s.push(n*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n1 = Integer.parseInt(String.valueOf(s.peek()));</span><br><span class="line">        s.pop();</span><br><span class="line">        <span class="keyword">int</span> n2 = Integer.parseInt(String.valueOf(s.peek()));</span><br><span class="line">        s.pop();</span><br><span class="line">        s.push(n2*<span class="number">2</span>);</span><br><span class="line">        s.push(n1*<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>숫자와 S,D,T에 대한 처리를 모두 했으니, 다음은 <em>에 대해서 처리하자. </em>은 이전 점수와 현재 점수를 2배 처리하는 것이다. 이전 점수가 없을 수도 있으니 스택의 사이즈에 따라 달리한다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(arr[i] == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> n = Integer.parseInt(String.valueOf(s.peek()));</span><br><span class="line">    s.pop();</span><br><span class="line">    s.push(n*(-<span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>#인경우 스택의 top원소를 빼내어 -1을 곱한 뒤, 다시 집어넣는다. 이 과정을 dartResult가 끝날 때 까지 하므로 여기서의 시간복잡도는 dartResult의 길이를 n이라 할 때, \(O(n)\)이다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!s.empty())</span><br><span class="line">&#123;</span><br><span class="line">    answer += s.peek();</span><br><span class="line">    s.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 다트 게임의 점수를 모두 합산하면 정답이다. 이 부분도 <span class="math inline">\(O(n)\)</span>이다. 따라서 최종 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/dart_game.png" width="350" height="500">
</center>
<p><br></p>
<p>프로그래머스 마지막 level1을 풀었다. 그래도 올해가 끝나기 전에 풀어서 기쁘다. 앞으로는 더 어려운 문제들이 있겠지만 포기하지말고 끝까지 풀어보자. 물러서지 말자!</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>위장</title>
    <url>/2021/01/15/Disguise/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>스파이가 위장을 하려고 한다. 옷이 종류별로 있을 때, 적어도 하나의 의상은 입고 있어야 한다. 하지만 같은 종류의 옷을 겹쳐입을 순 없다. 이 때, 스파이가 옷을 입을 수 있는 경우의 수를 구하라.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Disguise</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 위장</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        String[][] clothes =</span><br><span class="line">        &#123;</span><br><span class="line">            &#123;<span class="string">&quot;yellow_hat&quot;</span>, <span class="string">&quot;headgear&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;blue_sunglasses&quot;</span>, <span class="string">&quot;eyewear&quot;</span>&#125;,</span><br><span class="line">            &#123;<span class="string">&quot;green_turban&quot;</span>, <span class="string">&quot;headgear&quot;</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clothes.length; i++)</span><br><span class="line">            map.put(clothes[i][<span class="number">1</span>], map.getOrDefault(clothes[i][<span class="number">1</span>], <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> comb_max = map.size();</span><br><span class="line">        <span class="keyword">int</span>[] clothes_num = <span class="keyword">new</span> <span class="keyword">int</span>[comb_max];</span><br><span class="line">        </span><br><span class="line">        Iterator&lt;String&gt; keys = map.keySet().iterator();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(keys.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            String key = keys.next();</span><br><span class="line">            clothes_num[idx++] = map.get(key);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> comb_cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(comb_cnt &lt;= comb_max)</span><br><span class="line">        &#123;</span><br><span class="line">            answer += getCombNum(clothes_num, comb_cnt, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            comb_cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCombNum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(k == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> total = <span class="number">0</span>; </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = idx; i &lt;= arr.length-k; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                total += getCombNum(arr, k-<span class="number">1</span>, n*arr[i], i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> total;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 코드가 좀 긴데 차근차근 보도록 하자. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clothes.length; i++)</span><br><span class="line">    map.put(clothes[i][<span class="number">1</span>], map.getOrDefault(clothes[i][<span class="number">1</span>], <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> comb_max = map.size();</span><br><span class="line"><span class="keyword">int</span>[] clothes_num = <span class="keyword">new</span> <span class="keyword">int</span>[comb_max];</span><br><span class="line"></span><br><span class="line">Iterator&lt;String&gt; keys = map.keySet().iterator();</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(keys.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">    String key = keys.next();</span><br><span class="line">    clothes_num[idx++] = map.get(key);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> comb_cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(comb_cnt &lt;= comb_max)</span><br><span class="line">&#123;</span><br><span class="line">    answer += getCombNum(clothes_num, comb_cnt, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    comb_cnt++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 일단 옷의 종류를 key로 하여 종류별로 몇 벌의 옷이 있는지 map에 저장한다. 이 때 getOrDefault함수는 아주 유용하게 쓰인다 처음 들어가는 key이면 초기화를 해주고 아닐 경우 해당 값의 1증가한 값을 넣어준다. 필자의 아이디어는 k개의 조합의 수를 구해다주는 함수가 있을 때, 1부터 옷의 모든 종류 수로 k를 늘려가면서 조합의 수를 다 더해주면 된다고 생각했다. 이 함수에 대한 세부 설명은 뒤로 미루고, clothes_num을 선언해 종류별 옷의 개수를 담아준다. 그리고 comb_cnt를 1부터 comb_max로 늘려주면서 getCombNum까지 조합의 수를 다 더해준다.</p>
<p>이제 함수를 보도록하자. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCombNum</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> k, <span class="keyword">int</span> n, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = idx; i &lt;= arr.length-k; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            total += getCombNum(arr, k-<span class="number">1</span>, n*arr[i], i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 조합의 수를 구해주는 함수이다 arr는 옷의 개수 k는 몇 개의 조합을 원하는지 알려주는 변수이다. n은 현재까지 계산된 조합의 수이며, idx는 arr에서 새로 시작해야하는 index이다. 종료 조건은 k가 0이 될 때이다. 종류개수를 전부 만족했으므로 여태까지 계산한 n을 반환하면 된다. 아닐 경우 조합을 만들어야 한다. total을 0으로 하고, idx부터 length-k까지 n에 arr[i]를 곱해 함수를 재호출한다. 이때 i의 범위가 이해가 잘 안 갈수도 있는데 만약 1,2,3,4,5가 들어간 배열이 있고 2개의 조합을 찾으려고 할 때, 앞에서부터 조합을 만들어간다고 가정하면 1,2,3,4가 가능하다. 여기서 3을 만약 선택했다면 그 다음 조합은 4,5중에 하나를 선택해야한다. 중복없는 모든 조합을 찾기 위한 방법이니 이 참에 잘 공부했으면 좋겠다.</p>
<p>필자는 처음에 이렇게 코드를 짜고 싶지 않았는데 왜냐하면 이렇게 프로그램을 짜는 경우 시간복잡도가 어마무시하게 늘어나기 때문이다. 옷의 종류가 총 n개라고 하고 k개를 선택한다고 하면 함수는 조합 수 만큼 호출되기 때문에 <span class="math inline">\(O(n^k)\)</span>만큼 호출될 것이다. k의 최대값은 n이므로 결국 <span class="math inline">\(O(n^n)\)</span>이 된다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/disguise.png" width="290" height="530">
</center>
<p><br></p>
<p>살인적인 시간복잡도를 보고 기겁을 할 수도 있는데, 다행히 통과는 했다. 일부러 1번 케이스를 보여줬는데, 통과는 되었다만 엄청난 시간복잡도를 자랑한다.. 다른 사람의 풀이를 보니 곱할 때 아무것도 선택하지 않은 것도 옵션으로 넣어 \(O(n)\)으로 끝내는 것을 보고 역시 수학을 잘해야 유리하다는 생각이 들었다. 아무튼 풀어냈지만, 수학 공부도 게을리 하지 말아야겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>디스크 컨트롤러</title>
    <url>/2021/03/04/Disk-Controller/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>SJF(Shortest Job First)를 구현하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Job</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Job</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">int</span> request_time;</span><br><span class="line">    <span class="keyword">int</span> service_time;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Job</span><span class="params">(<span class="keyword">int</span> request_time, <span class="keyword">int</span> service_time)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.request_time = request_time;</span><br><span class="line">        <span class="keyword">this</span>.service_time = service_time;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Job j)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.service_time - j.service_time;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiskController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level3 디스크 컨트롤러</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] jobs = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">            &#123;<span class="number">500</span>, <span class="number">6</span>&#125;,</span><br><span class="line">            <span class="comment">// &#123;0, 7&#125;,</span></span><br><span class="line">            <span class="comment">// &#123;0, 3&#125;,</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(jobs, (a,b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        Queue&lt;Job&gt; prepare_q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; jobs.length; i++)</span><br><span class="line">            prepare_q.add(<span class="keyword">new</span> Job(jobs[i][<span class="number">0</span>], jobs[i][<span class="number">1</span>]));</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;Job&gt; ready_q = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> time = jobs[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> total_t = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> done = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(done != jobs.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!prepare_q.isEmpty() &amp;&amp; prepare_q.peek().request_time &lt;= time)</span><br><span class="line">                ready_q.add(prepare_q.poll());</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(!ready_q.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                Job job = ready_q.poll();</span><br><span class="line">                time += job.service_time;</span><br><span class="line">                total_t += time - job.request_time;</span><br><span class="line">                done++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                time = prepare_q.peek().request_time;</span><br><span class="line">        &#125;        </span><br><span class="line"></span><br><span class="line">        System.out.println((<span class="keyword">int</span>)Math.floor(total_t/done));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 작업을 나타내기 위한 클래스를 먼저 정의한다. 문제에서 주어진 입력대로 클래스의 인스턴스 변수는 <code>request_time</code>과 <code>service_time</code>이다. 여기서 비교 클래스를 상속받아 메소드를 오버라이딩 해주는데 인스턴스들을 정렬할 경우 <code>service_time</code>이 오름차순이 되도록 한다.</p>
<p>주어진 입력은 요청시간 순대로 들어오지 않으므로 이에 대해 람다식으로 정렬을 해주는 것이 우선이다. 람다식을 이용해 정렬한다.</p>
<p>정렬한 배열을 <code>prepare_q</code>에 전부 넣는다. 실은 여기서 개인의 취향대로 여기서도 우선순위 큐를 활용해도 된다. 이 큐는 처리되길 기다리는 작업들을 모아둔 것이라고 보면 된다.</p>
<p>이제 작업을 순차적으로 처리해야 한다. 초기 <code>time</code>을 첫번째 요청시간으로 초기화한다. <code>total_t</code>는 총 반환시간을 의미하며, <code>done</code>은 종료된 작업의 개수를 뜻한다.</p>
<p>반복은 모든 작업이 완료될 때 까지로 한다. 준비 큐(<code>prepare_q</code>)가 비어있지 않을 때, time보다 작거나 같은 요청시간을 가진 작업들을 모두 빼와 대기 큐(<code>ready_q</code>)에 집어넣는다. 이 때 대기 큐에 하나라도 들어가 있다면, 들어온 것 중에서 가장 작은 서비스시간을 가진 것을 꺼낸다. 그리고 <code>time</code>에는 서비스 시간을 더하고 <code>total_t</code>에 <code>time-(요청 시간)</code>을 더해준다. 그리고 <code>done</code>을 1증가한다. 만약에 대기 큐가 비어있다면 준비큐의 맨 앞의 요청시간을 <code>time</code>으로 갱신한다.</p>
<p>정렬을 사용하였기 때문에 작업의 개수를 n이라 하였을 때, 최종 시간복잡도는 <span class="math inline">\(O(nlogn)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/disk_controller.png" width="290" height="130">
</center>
<p><br></p>
<p>처음에는 우선순위큐를 이용하지 않고 dfs에서 방문기록을 남겼던 것 처럼, 배열을 정렬하고 방문기록을 활용하여 똑같은 논리로 짰었는데 계속 틀렸다. 어제 몇 시간을 고민하다. 결국 다 지우고 우선순위 큐로 구현하였더니 통과가 되었다. 그 전 코드의 문제점이 뭔지 알았으면 좋았을텐데, 앞으로 공부를 하면서 꼬인 논리를 지금 보다 더 능숙하게 풀어냈으면 좋겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level3</category>
      </categories>
  </entry>
  <entry>
    <title>내적</title>
    <url>/2020/12/29/Dot-Product/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>배열 a와 b가 주어질 때 내적을 구하는 문제이다. 내적은 같은 인덱스로 둘을 짝지어 곱한 뒤, 전부 합산하면 된다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DotProduct</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level1 내적</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] b = &#123;-<span class="number">3</span>,-<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">            answer += a[i]*b[i];</span><br><span class="line">        System.out.print(answer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> a와 b의 길이는 같으므로 둘 중 하나를 기준으로 배열을 순회하며 a와 b값을 곱해 더해나간다. 총 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/dot_product.png" width="400" height="300">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>이중우선순위큐</title>
    <url>/2021/03/05/Double-Priority-Queue/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>일반적인 우선순위 큐에서 tail에서도 값이 나올 수 있게 만드는 문제이다. I + (숫자)인 경우 숫자를 삽입하는 것이고 "D 1"인 경우 최댓값을 제거하고, "D -1"이라면 최솟값을 제거한다. 이런 명령어들이 담긴 배열을 전부 수행하였을 때, 큐에 남은 최댓값과 최솟값을 배열로 담아 반환하면 된다. <span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvNDI2Mjg=">문제링크<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoublePriorityQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level3 이중 우선순위 큐</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PriorityQueue&lt;Integer&gt; big;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PriorityQueue&lt;Integer&gt; small;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Integer, Integer&gt; big_map;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Integer, Integer&gt; small_map;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] operations = &#123;<span class="string">&quot;I 16&quot;</span>, <span class="string">&quot;I -5643&quot;</span>, <span class="string">&quot;D -1&quot;</span>, <span class="string">&quot;D 1&quot;</span>, <span class="string">&quot;D 1&quot;</span>, <span class="string">&quot;I 123&quot;</span>, <span class="string">&quot;D -1&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        big = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;(Collections.reverseOrder());</span><br><span class="line">        small = <span class="keyword">new</span> PriorityQueue&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">        big_map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        small_map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String s : operations)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">&quot;D 1&quot;</span>) &amp;&amp; !big.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> big_i = big.peek();</span><br><span class="line">                big_map.put(big_i, big_map.getOrDefault(big_i, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                big.poll();</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;D -1&quot;</span>) &amp;&amp; !small.isEmpty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> small_i = small.peek();</span><br><span class="line">                small_map.put(small_i, small_map.getOrDefault(small_i, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                small.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.contains(<span class="string">&quot;I&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> i = Integer.parseInt(s.substring(<span class="number">1</span>).trim());</span><br><span class="line">                big.add(i);</span><br><span class="line">                small.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            synchroize();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(big.isEmpty())</span><br><span class="line">            System.out.println(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(big.peek());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(small.isEmpty())</span><br><span class="line">            System.out.println(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(small.peek());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">synchroize</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(big_map.getOrDefault(big.peek(), <span class="number">0</span>) &lt; small_map.getOrDefault(big.peek(), <span class="number">0</span>)</span><br><span class="line">        &amp;&amp; !big.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> big_i = big.peek();</span><br><span class="line">            big_map.put(big_i, big_map.getOrDefault(big_i, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            big.poll();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(big_map.getOrDefault(small.peek(), <span class="number">0</span>) &gt; small_map.getOrDefault(small.peek(), <span class="number">0</span>)</span><br><span class="line">        &amp;&amp; !small.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> small_i = small.peek();</span><br><span class="line">            small_map.put(small_i, small_map.getOrDefault(small_i, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            small.poll();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 가장 쉬운 구현방법을 생각해보면 리스트를 선언하여 연산할 수 있겠지만, 그런 경우 시간이 굉장히 오래걸린다. 그래서 우선순위큐를 활용하여 문제를 풀어보자.</p>
<p>문제점은 우선순위큐에는 tail이라는 개념이 없는 것이다. 애초에 heap으로 구성이 되어 있으니 최대값만 찾거나 최소값만 찾을 수 있다. 필자는 이를 보완하기 위해 우선순위 큐 두개를 활용하기로 했다.</p>
<p>여기에 추가로 두 개의 맵을 선언하는데 맵의 역할은 각 큐에서 어느 숫자가 몇 번 삭제 되었는지 기록하는 용도이다. 우선순위 큐를 두개를 사용하였지만, 실제로는 하나의 큐로 인식하기 때문에 이 두 큐에서 한쪽만 원소가 삭제되면 안된다. 따라서 이 두 큐를 동기화하기 위해 사용된다.</p>
<p>첫 번째 for문을 보자. 일단 최대값을 제거해야 하는 경우 <code>big</code>에서 하나를 제거하고 맵에 삭제된 횟수를 갱신한다. 최솟값을 제거하는 경우도 동일한 원리로 작동한다.</p>
<p>만약 숫자를 삽입하는 경우라면 두 큐에 모두 삽입한다.</p>
<p>삭제 또는 추가를 마칠 때 마다, 동기화를 해야하는데 필자는 이를 <code>synchronize</code>라는 함수를 통해 구현하였다. 함수 내부를 들여다보면, 두 개의 while문이 나타나는데, 두 while문은 동작하는 방식이 동일하므로 첫번째 while문에 대해서 이야기하겠다.</p>
<p><code>big</code>큐의 가장 첫번째 원소가 삭제된 횟수가 <code>small</code>에서 삭제된 횟수보다 작다면, 이는 지워야 하는 원소이므로 제거한다. <code>big</code>이 비어있지 않는 한 계속 반복하면 된다. 이를 통해 두 큐를 동기화 할 수 있다.</p>
<p><code>operation</code>의 크기를 n이라 하였을 때, 최종 시간복잡도는 <span class="math inline">\(O(nlogn)\)</span>이다. 그거보다 시간복잡도가 높지 않을까 생각하는 분이 계실 수도 있는데, 생각해보면 두 큐에 들어갔다 나오는 횟수를 전부 더하면 <span class="math inline">\(4nlogn\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/double_pq.png" width="290" height="130">
</center>
<p><br></p>
<p>질문하기를 보니까 조건에 부합하지 않게 짜도 통과되는 경우가 있다고 한다. 이 부분에서 좀 더 신경을 써줬으면 좋겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level3</category>
      </categories>
  </entry>
  <entry>
    <title>짝수와 홀수</title>
    <url>/2020/12/29/Even-Odd/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>주어진 숫자가 홀수이면 "Odd"를 출력하고 짝수라면 "Even"을 출력하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EvenOdd</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제 풀이 level1 짝수와 홀수</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">3</span>;</span><br><span class="line">        String answer = num % <span class="number">2</span> == <span class="number">0</span> ? <span class="string">&quot;Even&quot;</span> : <span class="string">&quot;Odd&quot;</span>;</span><br><span class="line">        System.out.print(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 2로 나누어서 0이 나온다면 짝수이므로 "Even"을 넣고 0이 아니라면 홀수라는 의미이므로 "Odd"를 넣는다. 따라서 전체 시간복잡도는 <span class="math inline">\(O(1)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/even_odd.png" width="400" height="300">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>예상 대진표</title>
    <url>/2021/01/22/Expect-Tournament/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>부전승이 없고 n명의 선수가 토너먼트를 진행할 때, 두 선수가 만날 라운드 수를 반환하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpectTournament</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 Level2 예상 대진표</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">8</span>, a = <span class="number">4</span>, b = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> total_round = Integer.toBinaryString(n).length()-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l = Math.min(a,b);</span><br><span class="line">        <span class="keyword">int</span> r = Math.max(a,b);</span><br><span class="line">        <span class="keyword">int</span> answer = total_round;</span><br><span class="line">        <span class="keyword">int</span> size = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= total_round; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j+=size)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j &lt;= l &amp;&amp; r &lt;= j+(size-<span class="number">1</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    answer = i;</span><br><span class="line">                    flag = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(flag)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            size *= <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 원래 재귀로 풀었었는데, 런타임 에러가 자꾸 떠서 결국 방법을 바꾸었다. 비주얼 스튜디오 코드에서는 동작했던 걸 보아하니 채점 사이트에서 막은 건가 싶었다. 어쨌든 새로 한 두번째 방법은 2명씩 4명씩 8명씩.. 이런식으로 계속 묶어나가며 a,b가 동시에 속한 경우를 발견하면 그 라운드를 i에 받고 반복문을 마친다.</p>
<p>코드를 좀 더 자세히 설명하자면, total_round는 이진법으로 바꾼 문자열에서 -1하면 된다. 그리고 l은 두 선수 중 숫자가 작은 쪽, r은 숫자가 큰 쪽이다. 1라운드부터 최종라운드까지 선수들을 묶어가면서 범위에 두 선수가 속해있는지 확인한다. 이때 초기 size는 선수가 2명씩 묶이므로 2로하고 라운드를 진행할 수록 팀 당 선수는 2배씩 늘어나므로 size도 2를 곱해준다.</p>
<p>최종 시간복잡도는 공비가 \(1\)인 등비수열의 합이므로, 2진법을 계산하는 과정이 있기 때문에 \(O(n*{1}^n)\)이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/expect_tournament.png" width="290" height="540">
</center>
<p><br></p>
<p>비트 연산을 통해서 문제를 푼 것을 보고 감탄을 느꼈다. 2로 나누거나 곱하는 연산은 비트 연산을 통해 풀어볼 수 없는지 공부해 봐야겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>N으로 표현</title>
    <url>/2021/02/09/Express-N/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<h3 id="n으로-표현하기">N으로 표현하기</h3>
<p>자연수 N을 최대 8개까지 써서 사칙연산으로 주어진 수를 표현할 수 있는지 보는 문제이다. 만약 표현할 수 있다면 표현할 수 있는 수 중에 가장 작은 사용횟수를 출력해야 한다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NExpress</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level3 n으로 표현</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> answer = -<span class="number">1</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>, number = <span class="number">17</span>;</span><br><span class="line"></span><br><span class="line">        ReturnMin(<span class="number">0</span>, <span class="number">0</span>, number, N);</span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ReturnMin</span><span class="params">(<span class="keyword">int</span> res, <span class="keyword">int</span> cnt, <span class="keyword">int</span> number, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = N;</span><br><span class="line">        <span class="keyword">if</span>(cnt &gt; <span class="number">8</span>)</span><br><span class="line">            answer = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(res == number)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(answer == -<span class="number">1</span> || answer &gt; cnt)</span><br><span class="line">                answer = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>-cnt; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                ReturnMin(res+temp, cnt+i+<span class="number">1</span>, number, N);</span><br><span class="line">                ReturnMin(res-temp, cnt+i+<span class="number">1</span>, number, N);</span><br><span class="line">                ReturnMin(res*temp, cnt+i+<span class="number">1</span>, number, N);</span><br><span class="line">                ReturnMin(res/temp, cnt+i+<span class="number">1</span>, number, N);</span><br><span class="line"></span><br><span class="line">                temp = temp*<span class="number">10</span>+N;</span><br><span class="line">            &#125;</span><br><span class="line">    </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 다른 사람의 코드를 찾아서 쓴 코드이다. 필자도 dfs로 풀 생각을 하였는데 <code>temp</code>부분에서 실수를 했다. 가령 1111+1111는 2222가 나와야 하는데 필자는 1111+1111을 계산하지 않고 끝내버리는 오류가 있었기 때문이다. 문제점을 알았으니 다행이다. 일단 코드 설명을 해보면 <code>res</code>는 현재까지 계산한 값을 의미하고 <code>cnt</code>는 사용횟수이다. <code>number</code>는 만들고자 하는 값이다.</p>
<p>재귀의 종료 조건은 사용횟수가 8을 넘어가면 답이 없는 것이므로 <code>answer</code>에 -1을 한다. 다른 경우는 8번안에 숫자가 만들어진다면 <code>answer</code>가 -1이거나 <code>cnt</code>보다 <code>answer</code>가 큰 경우 답을 <code>cnt</code>로 한다. 그것도 아니라면 사칙연산을 추가로 진행해야 한다. 사용할 수 있는 횟수만큼 <code>N</code>을 뒤에 붙여가며 더해간다. 예를들면 5를 4번쓸 수 있으면 [5,55,555,5555]로 사칙연산을 하는 것이다.</p>
<p>시간 복잡도는 최대 8번이라는 조건이 있기 때문에 <span class="math inline">\(O(4^8)\)</span>이므로 <span class="math inline">\(O(1)\)</span>로 나타낼 수 있다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/N_express.png" width="290" height="320">
</center>
<p><br></p>
<p>동적계획법으로 푸는 방법을 몰라서 재귀를 사용하였는데, 이런 경우 대게 테스트 케이스가 커서 골치 아픈 경우가 많다. 하지만 이 문제는 8이라는 제한 횟수가 있어서 그런지 시간 초과가 나는 일은 없었다. 재귀함수를 짤 때 종료조건에 대해 꼼꼼히 생각해봐야겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level3</category>
      </categories>
  </entry>
  <entry>
    <title>가장 먼 노드</title>
    <url>/2021/03/03/Farthest-Node/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>1번 노드로부터 가장 멀리 떨어진 노드가 총 몇 개인지 계산하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FarthestNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 level3 가장 먼 노드</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] edge = &#123;</span><br><span class="line">            &#123;<span class="number">3</span>, <span class="number">6</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>, <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>, <span class="number">2</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">2</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>, <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">5</span>, <span class="number">2</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//adjacency list</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; adj_list = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(n+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++)</span><br><span class="line">            adj_list.add(<span class="keyword">new</span> ArrayList&lt;Integer&gt;());</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; edge.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            adj_list.get(edge[i][<span class="number">0</span>]).add(edge[i][<span class="number">1</span>]);</span><br><span class="line">            adj_list.get(edge[i][<span class="number">1</span>]).add(edge[i][<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//bfs</span></span><br><span class="line">        <span class="keyword">int</span>[] distance = <span class="keyword">new</span> <span class="keyword">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n+<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        q.add(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> root = q.poll();</span><br><span class="line">            visited[root] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> depth = distance[root]+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i : adj_list.get(root))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    distance[i] = depth;</span><br><span class="line">                    visited[i] = <span class="keyword">true</span>;</span><br><span class="line">                    q.add(i);</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; distance.length; i++)</span><br><span class="line">            max = Math.max(max, distance[i]);</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; distance.length; i++)</span><br><span class="line">            answer = distance[i] == max ? answer+<span class="number">1</span> : answer;</span><br><span class="line"></span><br><span class="line">        System.out.println(answer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> bfs를 이용해서 문제를 풀면 된다. 각 노드의 <code>depth</code>(깊이)를 계산하여 제일 큰 값을 가지는 노드가 총 몇 개인지 세어본다. 이번 문제에서는 간선이 많기 때문에 행렬형태로 연결을 포함할 수 없다. 그래서 adjacency list를 통해 구현하였다.</p>
<p>그래프를 모두 표시하고 난 뒤, bfs를 한다. 큐를 선언하고 각 노드의 깊이를 저장할 <code>distance</code>를 선언한다. 1번노드부터 bfs를 시작할 것이므로, 1을 큐에 삽입한다.</p>
<p>이제 큐에서 1을 꺼내 루트로 생각하고 방문여부를 나타내는 <code>visited</code>를 true로 한다. <code>root</code>와 인접한 노드들은 <code>root</code>+1의 깊이를 가지므로 이 값을 <code>depth</code>로 둔다. 이제 인접 리스트를 돌면서 방문하지 않았던 노드들의 깊이를 기록하고 방문기록을 true로 한다.</p>
<p>이 과정을 모두 마치면 <code>distance</code>값 중에 가장 큰 것을 <code>max</code>값으로 한다. 그리고 <code>distance</code>중에 <code>max</code>값이 몇 개가 있는지 세면 정답이다.</p>
<p>adjacency list를 사용하기 때문에, 노드 개수를 V, 간선의 개수를 E라고 한다면 최종 시간복잡도는 <span class="math inline">\(O(V+E)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/farthest_node.png" width="290" height="130">
</center>
<p><br></p>
<p>필자는 처음에 다익스트라로 풀었는데 구현이 잘못되었는지 계속 틀려서 결국 노트북을 닫았다. 약한 멘탈이 미울 지경이다. 문제점을 못찾겠어서 고민하다가 bfs로도 될 것 같은데라는 생각이 들었다. 하지만 어제는 기력이 다해서 집에서 뻗었다. 결국 다른 사람의 풀이를 찾아보니 다 bfs로 풀었다. 다익스트라로 푼 사람은 못 봤다. bfs로 풀어서 정답을 맞았지만 다익스트라로 풀었을 때 왜 틀렸는지는 아직 의문이다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level3</category>
      </categories>
  </entry>
  <entry>
    <title>실패율</title>
    <url>/2020/12/30/Fail-Rate/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>유저가 스테이지를 어디까지 완료하였는지 담아놓은 배열 stage와 총 스테이지 개수 N이 주어질 때, 실패율을 계산하여 내림차순으로 정렬한다. 만약 실패율이 같은 경우 스테이지 번호가 작은 순서를 우선으로 한다. 실패율을 계산하는 수식은 다음과 같다.</p>
<blockquote>
<p>(스테이지에 도달했으나 아직 클리어하지 못한 플레이어의 수) / (스테이지에 도달한 플레이어 수)</p>
</blockquote>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FailRate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level1 실패율</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> N = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span>[] stages = &#123;<span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        Integer[] answer = <span class="keyword">new</span> Integer[N];</span><br><span class="line">        <span class="keyword">int</span>[] clear = <span class="keyword">new</span> <span class="keyword">int</span>[N+<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">double</span>[] fail_rate = <span class="keyword">new</span> <span class="keyword">double</span>[N+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> stage : stages)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; stage; i++)</span><br><span class="line">                clear[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        clear[<span class="number">0</span>] = stages.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(clear[i-<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">                fail_rate[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                fail_rate[i] = (<span class="keyword">double</span>)(clear[i-<span class="number">1</span>]-clear[i]) / (<span class="keyword">double</span>)clear[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">            answer[i-<span class="number">1</span>] = i;</span><br><span class="line">        Arrays.sort(answer, <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(fail_rate[o1] &lt; fail_rate[o2])</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(fail_rate[o1] &gt; fail_rate[o2])</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> Integer.compare(o1, o2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 부분부분 살펴보자 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> stage : stages)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; stage; i++)</span><br><span class="line">        clear[i]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 스테이지를 클리어하는 사람 수를 저장해두는 배열 clear를 선언한다. stage-1이 여태까지 클리어해온 스테이지이므로 1부터 stage-1까지 clear를 1씩 올린다. 이 부분에서 시간복잡도는 stages의 길이를 m이라 할 때 <span class="math inline">\(O(N*m)\)</span>이다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">clear[<span class="number">0</span>] = stages.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(clear[i-<span class="number">1</span>] == <span class="number">0</span>)</span><br><span class="line">        fail_rate[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        fail_rate[i] = (<span class="keyword">double</span>)(clear[i-<span class="number">1</span>]-clear[i]) / (<span class="keyword">double</span>)clear[i-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>실패율을 계산하는 부분이다. i번째 스테이지에 도달한 사람은 clear[i-1]이다. 3레벨에 도달하는 사람이 2레벨을 통과한 사람인 것처럼(아직 3단계를 통과한 사람들은 아니다!). 지금은 성공률이 아닌 실패율을 계산하는 것이므로 이 사람들 중 통과한 사람의수가 분자에 들어가야한다. 따라서 clear[i-1]-clear[i]가 분자에 올라간다. 스테이지를 통과한 사람이 없을 경우엔 실패율을 0으로 한다. 이 부분에서 시간복잡도는 <span class="math inline">\(O(N)\)</span>이다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">    answer[i-<span class="number">1</span>] = i;</span><br><span class="line">Arrays.sort(answer, <span class="keyword">new</span> Comparator&lt;Integer&gt;()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Integer o1, Integer o2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(fail_rate[o1] &lt; fail_rate[o2])</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(fail_rate[o1] &gt; fail_rate[o2])</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> Integer.compare(o1, o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>정렬방식이 특이하게 주어진 경우에는 비교자를 직접 정의하는 것이 좋다. 대신 자바에서는 Integer, Double과 같은 Wrapper 클래스만 비교자 정의를 허용한다. 따라서 int라면 Integer로 꼭 바꿔주자. 자세한 비교 코드는 위 코드를 참고하자. 이 부분에서 시간복잡도는 <span class="math inline">\(O(NlogN)\)</span>이다.</p>
<p>따라서 최종적인 시간복잡도는 <span class="math inline">\(O(N*m)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/fail_rate.png" width="350" height="500">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>피보나치 수</title>
    <url>/2021/01/20/Fibo-Num/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>피보나치의 n번째 수열을 1234567로 나눈 나머지 값을 구하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 피보나치 수</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">1</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            a %= <span class="number">1234567</span>;</span><br><span class="line">            b %= <span class="number">1234567</span>;</span><br><span class="line">            c = a+b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">            c %= <span class="number">1234567</span>;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 숫자가 자칫 커질꺼라 long을 쓸 수도 있는데 나머지 연산은 분배법칙이 통한다는 것을 알면 문제가 쉽게 풀린다. 일반적인 피보나치 수를 구하는 공식에 나머지 연산만 취해주면 된다.</p>
<p>시간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/fibonacci.png" width="290" height="370">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>숫자의 표현</title>
    <url>/2021/01/20/Express-Num/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>한 자연수에 대해 연속한 자연수의 합으로 나타낼 수 있는 경우의 수를 구하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpressNum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 숫자의 표현</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">15</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> add = <span class="number">1</span>, sub = <span class="number">1</span>, sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(add &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += add++;</span><br><span class="line">            <span class="keyword">while</span>(sum &gt; n)</span><br><span class="line">            &#123;</span><br><span class="line">                sum -= sub;</span><br><span class="line">                sub++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(sum == n)</span><br><span class="line">                answer++;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 자칫 경우의 수가 많아 보일 수 있지만 생각해보면 연속한 숫자라는 것이 도움이 된다. 1부터 차례대로 더해가며 n에 딱 맞을 경우 answer를 늘려주면 되고, 만약 n을 초과했다면 뒤에서부터 작아지거나 같아질 때까지 빼주면 된다.</p>
<p>최종 시간복잡도는 숫자를 빼고 더하는 최대 횟수가 2n이므로 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/express_num.png" width="290" height="530">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>서울에서 김서방 찾기</title>
    <url>/2020/12/28/Find-Kim-In-Seoul/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>'김서방은 ?에 있다.'라는 형식으로 출력하면 된다. 여기서 ?는 배열에서 "Kim"이 있는 위치이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SeoulKim</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String[] seoul = &#123;<span class="string">&quot;Jane&quot;</span>, <span class="string">&quot;Kim&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> idx = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; seoul.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(seoul[i].equals(<span class="string">&quot;Kim&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                idx = i;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        StringBuffer buff = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        buff.append(<span class="string">&quot;김서방은 &quot;</span>);</span><br><span class="line">        buff.append(Integer.toString(idx));</span><br><span class="line">        buff.append(<span class="string">&quot;에 있다&quot;</span>);</span><br><span class="line">        String answer = buff.toString();</span><br><span class="line">        System.out.print(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 배열을 순회하면서 "Kim"이 있는 위치를 찾는다. Kim을 찾는 순간 더 이상 배열을 탐색할 필요가 없으므로 break문을 통해 탈출하고 정답을 출력한다. 총 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/seoul_kim.png" width="400" height="300">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>1920번 수 찾기</title>
    <url>/2021/04/05/Find-Num/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>이분 탐색을 이용한 수 탐색 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">binary_search</span>(<span class="params">A, key</span>):</span></span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = <span class="built_in">len</span>(A)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        mid = (l+r) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> A[mid] == key:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> A[mid] &gt; key:</span><br><span class="line">            r = mid</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            l = mid+<span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">N = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">A = <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, _ <span class="keyword">in</span> <span class="built_in">enumerate</span>(A):</span><br><span class="line">    A[i] = <span class="built_in">int</span>(A[i])</span><br><span class="line"></span><br><span class="line">A.sort()</span><br><span class="line"></span><br><span class="line">M = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"></span><br><span class="line">X = <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, _ <span class="keyword">in</span> <span class="built_in">enumerate</span>(X):</span><br><span class="line">    <span class="built_in">print</span>(binary_search(A, <span class="built_in">int</span>(X[i])))</span><br></pre></td></tr></table></figure></p>
<p>이분 탐색을 구현하는 문제이다. 입력을 받는 부분을 건너 뛰고 <code>binary_search</code>함수를 보면 된다. 인덱스를 기준으로 이분탐색을 진행한다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<figure>
<img src="/images/baekjoon/1920.png" alt="테스트 화면" /><figcaption aria-hidden="true">테스트 화면</figcaption>
</figure>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Beakjoon</category>
        <category>1000-1999</category>
      </categories>
  </entry>
  <entry>
    <title>소수 찾기</title>
    <url>/2021/01/11/Find-Prime-Num/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>숫자 카드가 주어지고, 각 숫자 카드를 조합하여 나온 숫자 중 소수가 몇 개 있는지 계산하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FindPrimeNum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 소수 찾기</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String numbers = <span class="string">&quot;17&quot;</span>;</span><br><span class="line">        Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;Integer&gt;();</span><br><span class="line">        StringBuilder buff = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        buff.append(numbers);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numbers.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            findKDigitPrimeNum(<span class="string">&quot;&quot;</span>, <span class="number">0</span>, set, i, buff);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(set.size());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findKDigitPrimeNum</span><span class="params">(String s, <span class="keyword">int</span> size, Set&lt;Integer&gt; set, <span class="keyword">int</span> k, StringBuilder buff)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(size == k)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n = Integer.parseInt(s);</span><br><span class="line">            <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Math.sqrt(n); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(n%i == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            set.add(n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buff.length(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="keyword">char</span> c = buff.charAt(i);</span><br><span class="line">                str.append(s);</span><br><span class="line">                str.append(c);</span><br><span class="line">                findKDigitPrimeNum(str.toString(), size+<span class="number">1</span>, set, k, buff.delete(i, i+<span class="number">1</span>));</span><br><span class="line">                str.delete(str.length()-<span class="number">1</span>, str.length());</span><br><span class="line">                buff.insert(i, c);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 카드 숫자로 만들 수 있는 모든 경우의 수를 조합하는 것이 이 문제의 핵심이다. 이 조합을 찾아내기 위해 다음과 같은 과정을 생각했다. 1. k개의 자릿수를 가지는 모든 숫자 조합을 만드는 함수를 만든다. 2. 조합을 완성할 때마다 소수인지 판별하여 소수라면 set에 삽입한다. 3. k값을 1부터 numbers의 크기만큼 반복한다. 4. set의 크기를 반환한다.</p>
<p>위 과정을 코드로 담은 것이 위에 코드다 여기서 1번 함수에 대한 세부설명을 하겠다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">findKDigitPrimeNum</span><span class="params">(String s, <span class="keyword">int</span> size, Set&lt;Integer&gt; set, <span class="keyword">int</span> k, StringBuilder buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(size == k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n = Integer.parseInt(s);</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Math.sqrt(n); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n%i == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        set.add(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; buff.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            StringBuilder str = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">char</span> c = buff.charAt(i);</span><br><span class="line">            str.append(s);</span><br><span class="line">            str.append(c);</span><br><span class="line">            findKDigitPrimeNum(str.toString(), size+<span class="number">1</span>, set, k, buff.delete(i, i+<span class="number">1</span>));</span><br><span class="line">            str.delete(str.length()-<span class="number">1</span>, str.length());</span><br><span class="line">            buff.insert(i, c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> s는 현재 만들어진 숫자를 의미한다. size는 s의 크기를 나타내고, k는 보고자하는 자릿수이다. buff는 현재 쓸 수 있는 숫자 카드를 담아둔 변수이다. 첫번째 if문은 크기가 k를 만족할 경우 소수인지 판별하고 소수라면 set에 해당 수를 넣는 부분이다. set을 사용한 이유는 중복을 방지하기 위함이다. 만약에 size가 k에 도달하지 못했다면, 문자를 추가해야한다. 이 경우 else문으로 빠진다. buff에 들어있는 문자들을 하나씩 넣었다 빼면서, 함수를 재호출한다.</p>
<p>시간복잡도는 문자열의 길이를 n이라 할 때, <span class="math inline">\(O(n^{n+1})\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/find_prime.png" width="290" height="340">
</center>
<p><br></p>
<p>완전 탐색이라 시간복잡도차 최악을 도는 것을 볼 수 있다. 이러한 문제는 보통 테스트 케이스의 수가 상대적으로 작다. 이런 문제가 나올 땐 효율성에 겁내지 말고 일단 해보는 것이 중요하다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>소수 찾기</title>
    <url>/2020/12/28/Find-Prim-Num/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>최대 자연수 값 n이 주어질 때 [1,n]에서 소수가 몇 개 있는지 출력하는 문제이다. 필자의 경우 첫번째 시도를 시간초과로 틀렸다. 그래서 질문하기를 보니 에라토테네스의 체(어떤 사람을 이걸 에라이체라고 하더라)를 활용하면 풀 수 있다고 했다. 이용했더니 한번에 풀림! 에라토테네스의 체는 큰 수가 소수가 맞는지 아닌지에 대한 판별을 할 때 유용하다고 한다. 간단히 설명을 하자면 25가 소수인지 알고 싶을 때, 2~24까지 전부 나눠보는 것이 아니라 그의 제곱근인 5를 2~5로 나눠보면 된다는 것이다. 왜 제곱근까지 나눠보면 되냐면 우리가 어떠한 수를 나눌 때 몫이 생긴다. 이 몫이 그 수의 제곱근이하이기 때문이라고 한다(더 자세히 알고 싶은 사람은 검색해보자.). 아무튼 이 원리를 이용하고 효율성 검사까지 모두 통과하였다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimeNum</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> add = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            add = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= Math.sqrt(i); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i%j==<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    add = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(add)</span><br><span class="line">                answer++;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 1은 소수가 아니므로 2부터 n까지 i가 소수인지 검토하는 프로그램을 짰다. 원래 두번째 for문에서 i-1까지 나눠보는 걸로 하였는데, 에라토테네스의 체로 제곱근까지 나눠본다. 이때 등호를 넣어준 이유는 제곱근이 자연수로 딱 떨어지는 경우가 있기 때문이다. 가령 4가 소수인지 판별하기 위해선 2까지 해당하는 약수가 있는지 봐야한다. 소수판별은 위와 같이 가능하다. 소수 판별을 한다는 것을 저장하기 위해 add라는 플래그를 세워두었다. 만약 약수가 하나라도 존재하면 add는 false가 되어 answer++문을 넘어간다. 총 시간복잡도는 <span class="math inline">\(O(n\sqrt{n})\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/find_prime_num.png" width="400" height="300">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>3진법 뒤집기</title>
    <url>/2020/12/28/Flip-3Digit/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>어떤 십진수 n이 들어올 때 이를 3진법으로 바꾼뒤 이를 뒤집는다. 뒤집은 3진법을 다시 10진수로 출력한다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>10진법을 2진법을 바꾸는 방법을 떠올려보자. 계속 나누어가다가 몫이 0이 되면 나머지들을 최근것부터 합치면 된다. 이 문제에서는 3진법을 거꾸로 뒤집으라 했으므로 나오는 나머지들을 스택에 쌓으면 원래 3진법에서 뒤집어진다. 뒤집은 수를 10진법으로 바꾸는 방법은 3^(자릿수)에 해당 값을 곱하면된다. 이를 다 합산하면 우리가 바라던 정답이다.</p>
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flip3Digit</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">45</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(q != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q = n/<span class="number">3</span>;</span><br><span class="line">            r = n%<span class="number">3</span>;</span><br><span class="line">            n /= <span class="number">3</span>;</span><br><span class="line">            s.push(r);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> digit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            answer += Math.pow(<span class="number">3</span>,digit) * Integer.parseInt(s.peek().toString());</span><br><span class="line">            digit++;</span><br><span class="line">            s.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 부분부분 살펴보자 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">45</span>;</span><br><span class="line"><span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> q = <span class="number">1</span>, r = <span class="number">0</span>;</span><br><span class="line">Stack&lt;Integer&gt; s = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"><span class="keyword">while</span>(q != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    q = n/<span class="number">3</span>;</span><br><span class="line">    r = n%<span class="number">3</span>;</span><br><span class="line">    n /= <span class="number">3</span>;</span><br><span class="line">    s.push(r);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 10진법을 3진수로 바꾸는 과정이다. q는 몫이고 r은 나머지이다. 몫이 0이 될 때 까지 나머지를 구하고 이를 스택에 쌓는다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!s.empty())</span><br><span class="line">&#123;</span><br><span class="line">    answer += Math.pow(<span class="number">3</span>,digit) * Integer.parseInt(s.peek().toString());</span><br><span class="line">    digit++;</span><br><span class="line">    s.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 스택에 나머지값이 쌓이면 스택에 쌓인 값 순서대로 10진수로 변환하는 과정을 거친다. 이 때 자릿수를 나타내는 digit은 0으로 초기화한다. 그리고 3*(자릿수)를 각 나머지에 곱하고 digit을 늘려간다.</p>
<p>총 시간복잡도는 3진수로 바꿨을 때 최대 자릿수를 n이라하면 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/flip3digit.png" width="400" height="300">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>자연수 뒤집어 배열로 만들기</title>
    <url>/2020/12/29/Flip-Nature-Num/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>자연수가 주어질때 각 자릿수를 뒤집어 배열로 만들어 반환하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlipNumtoArr</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level1 자연수 뒤집어 배열로 만들기</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">12345</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> r = n%<span class="number">10</span>;</span><br><span class="line">            list.add((<span class="keyword">int</span>)r);</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            answer[i] = Integer.parseInt(list.get(i).toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 어레이리스트를 만들어서 n%10한 값을 추가하고 n 나누기 10을 한다. 그리고 다시 배열로 바꾸면 된다. 총 시간복잡도는 <span class="math inline">\(O(log10(n))\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/flip_num_to_arr.png" width="400" height="300">
</center>
<p><br></p>
<p>long을 int로 캐스팅 하면서 overflow가 일어나 처음에 테스트케이스를 통과하지 못했다. 그래서 처음에 나머지 연산을 하는 부분은 long으로 유지하고 값을 집어넣기 전에 int로 바꿨다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>최대공약수와 최소공배수</title>
    <url>/2020/12/30/GCD-LCM/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>두 수의 최대공약수와 최소공배수를 구하는 문제이다 두 수의 대소 관계는 정의되지 않았다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDivSmallMul</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제 풀이 level1 최대공약수와 최소공배수</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">3</span>, m = <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> min, max;</span><br><span class="line">        min = Math.min(n, m);</span><br><span class="line">        max = Math.max(n, m);</span><br><span class="line">        <span class="keyword">int</span> big_div = -<span class="number">2</span>, small_mul = -<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(min%i == <span class="number">0</span> &amp;&amp; max%i == <span class="number">0</span>)</span><br><span class="line">                big_div = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = max;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(temp % min == <span class="number">0</span> &amp;&amp; temp % max == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                small_mul = temp;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            temp++;</span><br><span class="line">        &#125;</span><br><span class="line">        answer[<span class="number">0</span>] = big_div;</span><br><span class="line">        answer[<span class="number">1</span>] = small_mul;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 부분부분 보도록 하자 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">3</span>, m = <span class="number">12</span>;</span><br><span class="line"><span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> min, max;</span><br><span class="line">min = Math.min(n, m);</span><br><span class="line">max = Math.max(n, m);</span><br><span class="line"><span class="keyword">int</span> big_div = -<span class="number">2</span>, small_mul = -<span class="number">2</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= min; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(min%i == <span class="number">0</span> &amp;&amp; max%i == <span class="number">0</span>)</span><br><span class="line">        big_div = i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> n과 m중에 크고 작은 값을 각각 min, max에 담았다. 최대공약수는 min값보다 클 수 없으므로 1에서 min까지 보면서 나눌 수 있는 최대를 big_div에 담는다. 여기서 n,m중 더 작은 값을 a라고 하면 시간복잡도는 \(O(a)\)로 볼 수 있다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> temp = max;</span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(temp % min == <span class="number">0</span> &amp;&amp; temp % max == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        small_mul = temp;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    temp++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>최소공배수는 max값이상이어야 한다. temp값을 max로 한 뒤, temp를 증가하면서 처음으로 나누어떨어지는 수가 있으면 최소공배수 값을 업데이트하고 반복문을 탈출한다. 이 부분에서도 시간복잡도는 <span class="math inline">\(O(a)\)</span>라는 것을 알 수 있다. 왜냐하면 최소공배수가 가장 큰 경우가 n*m이기 때문이다. 따라서 총 알고리즘의 시간복잡도는 <span class="math inline">\(O(a)\)</span> <span class="math inline">\(a = min(n,m)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/big_div_samll_mul.png" width="350" height="500">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>체육복</title>
    <url>/2020/12/23/Gym-Suit/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>체육복을 도둑맞아 빌려야 하는 상황. 체육복을 빌려야 체육 수업이 가능하다. 자신의 앞이나 뒤에 있는 번호의 체육복만 빌릴 수 있는 경우, 체육 수업을 들을 수 있는 최대 학생 수를 구하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>앞에서부터 부족한 학생이 있을 때 마다 자신보다 앞에 있는 학생의 체육복을 먼저 확인한 다음 빌릴 수 없다면 뒤에 있는 학생의 체육복을 빌려보는 식으로 한다. 앞에 있는 학생의 체육복을 먼저 확인하는 이유는 자신보다 앞에 있는 학생의 경우 자신보다 뒤에 있는 학생들에게 절대 체육복을 못 빌려주기 때문이다.</p>
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span> <span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span>[] lost = &#123;<span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] reserve = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        Arrays.fill(cnt, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idx : lost)</span><br><span class="line">            cnt[idx-<span class="number">1</span>]--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> idx : reserve)</span><br><span class="line">            cnt[idx-<span class="number">1</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i] &gt; <span class="number">0</span>)</span><br><span class="line">                answer++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt[<span class="number">1</span>] &gt; <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        answer++;</span><br><span class="line">                        cnt[<span class="number">1</span>]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i == n-<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt[n-<span class="number">2</span>] &gt; <span class="number">1</span>)</span><br><span class="line">                        answer++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt[i-<span class="number">1</span>] &gt; <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        answer++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(cnt[i+<span class="number">1</span>] &gt; <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        answer++;</span><br><span class="line">                        cnt[i+<span class="number">1</span>]--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       System.out.print(answer);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>부분부분 살펴보자</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span>[] lost = &#123;<span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] reserve = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] cnt = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">Arrays.fill(cnt, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> idx : lost)</span><br><span class="line">    cnt[idx-<span class="number">1</span>]--;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> idx : reserve)</span><br><span class="line">    cnt[idx-<span class="number">1</span>]++;</span><br></pre></td></tr></table></figure>
<p>학생마다 가지고 있는 체육복의 개수를 알아내기 위해 cnt 배열을 선언한다. 초기화는 모두 1로 한다. 그리고 체육복을 도둑맞은 학생의 개수는 줄이고 여분을 가지고 있는 학생의 개수는 1 증가한다. 이 부분에서 시간이 제일 오래 걸리는 부분은 fill이 <span class="math inline">\(O(n)\)</span>만큼 걸리기 때문에 이 부분에서 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt[i] &gt; <span class="number">0</span>)</span><br><span class="line">        answer++;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[<span class="number">1</span>] &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                answer++;</span><br><span class="line">                cnt[<span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(i == n-<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[n-<span class="number">2</span>] &gt; <span class="number">1</span>)</span><br><span class="line">                answer++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt[i-<span class="number">1</span>] &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                answer++;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(cnt[i+<span class="number">1</span>] &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                answer++;</span><br><span class="line">                cnt[i+<span class="number">1</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>초기 answer를 0으로 한다. 그리고 모든 학생을 보며 만약 체육복을 가지고 있다면 answer를 증가하고 넘긴다. 만약 학생이 체육복을 가지고 있지 않다면 체육복을 빌린다. 맨 앞에 있는 학생의 경우 자신보다 앞이 없으므로 뒷번호의 학생에게 밖에 빌릴 수 없다(i == 0). 맨 뒤에 있는 학생의 경우 자신보다 뒷번호가 없으므로 앞에서 밖에 빌릴 수 없다(i == n-1). 사이에 있는 학생의 경우 둘 다 빌릴 수 있다. 따라서 자신보다 앞에 있는 학생한테 체육복을 빌릴 수 있는지 확인한 후, 빌릴 수 있는 경우에 answer를 증가한다. 만약 앞에 학생한테 체육복을 빌릴 수 없으면 뒤에 있는 학생한테 빌려본다. 전체 n만큼 반복하므로 최종 시간복잡도는 <span class="math inline">\(O(n)\)</span>이 된다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/gym_suit.png" width="400" height="300">
</center>
<p><br></p>
<p>코드를 보면 알겠지만, 약간 지저분한 느낌이 든다. 맨 첫번째 학생과 맨 뒤에 학생을 따로 처리해줘서 그런데, 이 경우 배열의 크기를 n+2로 하면 이러한 연산을 없앨 수 있다. 앞으로 코드를 작성할 때 기억해야겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>H Index</title>
    <url>/2021/01/14/H-Index/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>어떤 과학자의 H 인덱스를 구하는 문제이다. H 인덱스란 어떠한 학자가 발표한 논문 n편중에 h번이상 발표한 논문이 h편이상일 때 이 h의 최대값이다. 이해가 어려울 수도 있는데 그런 사람을 위해 질문하기에 있었던 <span class="exturl" data-url="aHR0cHM6Ly93d3cuaWJyaWMub3JnL215Ym9hcmQvcmVhZC5waHA/Qm9hcmQ9bmV3cyZhbXA7aWQ9MjcwMzMz">링크<i class="fa fa-external-link-alt"></i></span>를 첨부한다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HIndex</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 H-Index</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] citations = &#123;<span class="number">22</span>, <span class="number">42</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(citations);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = citations.length-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(citations.length-i &gt;= citations[i])</span><br><span class="line">            &#123;</span><br><span class="line">                answer = citations.length-i-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(citations[<span class="number">0</span>] &gt; citations.length)</span><br><span class="line">            answer = citations.length;</span><br><span class="line">        System.out.println(answer);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 필자의 경우 처음으로 h를 만족하지 않을 때를 찾아내어 그 값에 -1을 해주었다. 먼저 피인용수를 정렬한 뒤에, 피인용수보다 논문수가 많아지거나 같아지는 지점을 찾았다. 하지만 이렇게 짜면 문제점이 발생하는데 {22,42}와 같이 전부 만족하는 경우이다. 이 경우 가장 작은 피인용수가 논문 전체 수보다 큰 경우 이므로 이 때는 논문 수를 넣어주면 된다.</p>
<p>정렬을 사용하였으므로 최종 시간복잡도는 <span class="math inline">\(O(nlogn)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/h_index.png" width="290" height="400">
</center>
<p><br></p>
<p>실은 이 문제를 풀기전에 두 문제 정도 했었는데, 2시간 안에 둘다 풀지 못했다. 그리디는 나름 자신있다고 생각했는데, 새삼 겸손해진다. 나머지 레벨2 문제를 풀어보고 다시 도전해봐야겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>하샤드 수</title>
    <url>/2020/12/30/Hashard-Num/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>주어진 수가 하샤드 수인지 판별하는 문제이다. 하샤드 수란 각 자릿수의 합으로 나누어 떨어지는 수이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HarshardNum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level1 하샤드 수</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">boolean</span> answer = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> n = x;</span><br><span class="line">        <span class="keyword">int</span> q = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            q += n%<span class="number">10</span>;</span><br><span class="line">            n /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x % q != <span class="number">0</span>)</span><br><span class="line">            answer = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        System.out.print(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 나누는 수 q를 구하는 부분을 주목해서 보면 된다. 각 자릿수를 더하는 것은 10으로 나머지 연산을 하고 10으로 나누면 된다. 이 알고리즘의 총 시간복잡도는 자릿수만큼 반복하므로 \(O(log10(n))\)이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/hasard_num.png" width="350" height="500">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>입국심사</title>
    <url>/2021/03/09/Immigration/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>입국 심사관들이 승객들을 심사하는데 걸리는 가장 최소 시간을 구하는 문제이다. <span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvNDMyMzg=">문제 링크<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Immigration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level3 입국심사</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line">        <span class="keyword">int</span>[] times = &#123;<span class="number">7</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(times);</span><br><span class="line">        System.out.println(BinarySearch(times, n, times[times.length-<span class="number">1</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">BinarySearch</span><span class="params">(<span class="keyword">int</span>[] times, <span class="keyword">int</span> n, <span class="keyword">long</span> max)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> l = <span class="number">1</span>, r = max * n;</span><br><span class="line">        <span class="keyword">long</span> mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> ans = Long.MAX_VALUE;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (l+r)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isPassed(times, n, mid))</span><br><span class="line">            &#123;</span><br><span class="line">                ans = Math.min(ans, mid);</span><br><span class="line">                r = mid-<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                l = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPassed</span><span class="params">(<span class="keyword">int</span>[] times, <span class="keyword">int</span> n, <span class="keyword">long</span> mid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> amount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.length; i++)</span><br><span class="line">            amount +=  mid / times[i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(amount &gt;= n)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>전체 코드는 다음과 같다.</p>
<p>일단 심사하는데 걸리는 시간을 정렬한다. 이 문제를 해결하기 위한 큰 그림은 이분탐색을 활용하는 것이다. 이분탐색의 mid를 걸리는 최대 시간으로 가정한다. 그리고 이 최대시간을 적용했을 때 모든 승객들을 심사할 수 있는지 검사한다. 만약 모든 승객을 검사할 수 있다면 midr값을 줄이고, 아니라면 mid값을 늘린다.</p>
<p>이분 탐색에서 초기 <code>l</code>값은 1로 <code>r</code>값은 가장 오래 걸리는 심사기간에 n을 곱한다. 그 뒤로는 <code>isPassed</code>함수를 통해 모든 승객을 심할 수 있는지 검사하고 만약 검사할 수 있다면, 정답을 더 작은 쪽으로 업데이트하고 <code>r</code>값을 <code>mid+1</code>로 업데이트한다.</p>
<p>그렇지 않다면 <code>mid</code>값이 더 커져야 한다는 의미이므로 <code>l</code>을 <code>mid+1</code>로 업데이트한다.</p>
<p><code>isPassed</code>를 검사하는 방법은 들어온 <code>mid</code>값에 대해 심사위원의 시간을 나눠서 검사를 할 수 있는 사람의 수를 전부 더해본다. 만약 이 값이 <code>n</code>을 넘는다면, <code>true</code>를 반환하고, 그렇지 않으면 <code>false</code>를 반환한다.</p>
<p><code>times</code>의 길이를 <code>m</code>이라 하고, <code>times</code>에서 가장 큰 값을 <code>x</code>라 한다면, 최종 시간복잡도는 <span class="math display">\[O(mlognx)\]</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/immigration.png" width="290" height="230">
</center>
<p><br></p>
<p>처음 풀이를 틀려서 다른 사람의 풀이를 참고했는데, 이게 전형적인 이분탐색 문제라고 해서 알아보지 못한 내 자신이 원망스러웠다. 학교 수업 때 이러한 유형을 풀어본 적이 있기 때문이다. 보통 엄청 큰 수가 나오고 최소 또는 최대를 구하라는 문제가 이분탐색의 유형에 해당된다고 한다. 앞으로는 잘 기억해두어야 겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level3</category>
      </categories>
  </entry>
  <entry>
    <title>정수 제곱근 판별</title>
    <url>/2020/12/29/Integer-Sqrt/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>제곱근이 정수인지 판별하는 문제이다. 만약 제곱근이 정수라면 제곱근의+1의 제곱을 출력한다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerRoot</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level1 정수 제곱근 판별</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> n = <span class="number">121</span>;</span><br><span class="line">        <span class="keyword">long</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> fp;</span><br><span class="line">        <span class="keyword">int</span> ip;</span><br><span class="line">        <span class="keyword">double</span> root = Math.sqrt(n);</span><br><span class="line">        ip = (<span class="keyword">int</span>)root;</span><br><span class="line">        fp = root - ip;</span><br><span class="line">        <span class="keyword">if</span>(fp &gt; <span class="number">0</span>)</span><br><span class="line">            answer = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            answer = (<span class="keyword">long</span>)Math.pow(ip+<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.print(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 제곱근이 정수라는 것은 소수부분이 0이어야 한다는 것이다. 주어진 정수 n의 제곱근을 구해 정수부와 소수부로 나눈다. 만약 소수부가 0보다 크면 정수가 아니라는 의미이므로 -1을 반환한다. 만약 소수부가 0이라면 정수부분의 +1하여 제곱한 값을 넘겨준다. 총 시간복잡도는 <span class="math inline">\(O(1)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/integer_root.png" width="400" height="300">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>정수 삼각형</title>
    <url>/2021/02/25/Integer-Triangle/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>삼각형의 꼭대기부터 바닥까지 가는 경로 중에서 경로의 합이 가장 큰 것을 찾는 문제이다. 아래쪽으로 갈 때는 자신의 바로 왼쪽 아래나 오른쪽 아래로만 이동할 수 있다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerTriangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level3 정수 삼각형</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] triangle = &#123;</span><br><span class="line">            &#123;<span class="number">7</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>,<span class="number">8</span>&#125;,</span><br><span class="line">            &#123;<span class="number">8</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">2</span>,<span class="number">7</span>,<span class="number">4</span>,<span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">5</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] sum = <span class="keyword">new</span> <span class="keyword">int</span>[triangle.length][triangle.length];</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">2</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(triangle.length == <span class="number">1</span>)</span><br><span class="line">            System.out.println(triangle[<span class="number">0</span>][<span class="number">0</span>]);</span><br><span class="line">        </span><br><span class="line">        sum[<span class="number">0</span>][<span class="number">0</span>] = triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; triangle.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum[i][<span class="number">0</span>] = triangle[i][<span class="number">0</span>] + sum[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">            sum[i][len-<span class="number">1</span>] = triangle[i][len-<span class="number">1</span>] + sum[i-<span class="number">1</span>][len-<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len-<span class="number">1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> max = Math.max(sum[i-<span class="number">1</span>][j-<span class="number">1</span>], sum[i-<span class="number">1</span>][j]);</span><br><span class="line">                sum[i][j] = max + triangle[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        len--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            answer = Math.max(answer, sum[triangle.length-<span class="number">1</span>][i]);</span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 아이디어는 이렇다. 삼각형의 밑변을 길이로 하여 2차원 배열을 생성한다. 그리고 여기에 해당 위치에 오기까지의 합 중 가장 큰 것을 넣을 것이다. 필자는 이를 sum이라 하였다. sum[0][0]은 맨 꼭대기이므로 triangle[0][0]을 넣는다. 꼭대기에서 갈 수 있는 곳은 3과 8이다. 3의 위치에서 최대값은 3+7=10, 8위치에서 합의 최대는 7+8=15이다. 3번째 줄로 내려가보자. 8은 3의 위치에서 내려올 수 밖에 없으므로 최대값은 10+8=18이다. 1의 경우 2번째 줄의 3과 8에서 둘 다 내려올 수 있다. 이 문제는 최대를 찾는 문제이므로 10과 15중 15를 선택하여 15+1=16을 기록하면 된다.</p>
<p>이런식으로 sum을 채워나가고 가장 아래층의 수 중 가장 큰 수를 찾으면 된다. 이를 코드로 그대로 구현하였다. sum을 정사각형으로 선언했기 때문에 각 층에 있는 숫자의 개수를 len으로 알려주었다. 가장 꼭대기를 채워넣고 그 아래부터는 for문의 영향을 받는다. 각 층에서 맨 왼쪽과 오른쪽 원소는 내려오는 경로가 하나밖에 없기 때문에 이는 따로 처리한다. 이를 제외한 원소는 위층의 왼쪽 대각선과 오른쪽 대각선의 sum값을 비교 한뒤 큰 값을 취한다. 각 층에서의 연산이 끝나면 len을 증가한다.</p>
<p>반복이 끝나면 맨 아래층의 원소에서 최대값을 찾아 반환한다.</p>
<p>연산 횟수는 삼각형의 밑변을 n이라 할 때, <span class="math inline">\(n^2 \over 2\)</span>이므로, 최종 시간복잡도는 <span class="math inline">\(O(n^2)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/integer_triangle.png" width="290" height="500">
</center>
<p><br></p>
<p>다이나믹 프로그래밍에 약한 편이다. 이건 기초문제라 쉽게 해결했지만, 이 유형에 좀 더 익숙해져야겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level3</category>
      </categories>
  </entry>
  <entry>
    <title>JadenCase 문자열 만들기</title>
    <url>/2021/01/21/JadenCase-String/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>영어 문자열이 주어질 때 공백을 기준으로 첫문자만 대문자로 만드는 프로그램을 작성하는 문제이다. 만약 첫문자가 영어가 아니라면 이어지는 문자들은 모두 소문자로 한다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JadenCase</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 JadenCase 문자열 만들기</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;   s  ab &quot;</span>;</span><br><span class="line">        String[] words = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        StringBuilder buff = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(String str : words)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(str.equals(<span class="string">&quot;&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                buff.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;   </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str.charAt(<span class="number">0</span>) &lt; <span class="number">65</span> || str.charAt(<span class="number">0</span>) &gt; <span class="number">123</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                buff.append(str.toLowerCase());   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                buff.append(str.substring(<span class="number">0</span>,<span class="number">1</span>).toUpperCase());</span><br><span class="line">                buff.append(str.substring(<span class="number">1</span>).toLowerCase());</span><br><span class="line">            &#125;</span><br><span class="line">            buff.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(s.length() &lt; buff.length())</span><br><span class="line">            buff.delete(buff.length()-<span class="number">1</span>, buff.length());</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(s.length() &gt; buff.length())</span><br><span class="line">            buff.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(buff.toString()); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 공백이 하나가 아니라 여러개인 경우 고려할게 좀 더 많아진다. 어쨌든 스페이스 한칸을 기준으로 단어를 쪼갠다. 이때 만약 공백이 여러개이면 아무것도 들어있지 않은 문자열이 생성된다. 이제 잘려진 문자열별로 처리를 해주면된다. 1. 들어온 문자가 아무것도 없는 경우 원래 입력이 공백이므로 공백을 버퍼에 넣은 뒤 넘어간다. 2. 문자열의 맨 앞이 영어가 아닌 경우(아스키 코드로 판단), 영문을 모두 소문자로 만든 뒤 버퍼에 붙여넣는다. 3. 만약 첫문자가 영문인 경우 첫번째만 대문자로 바꾸고 나머지는 소문자로 변환하여 붙인다. 4. 한 문자열 처리를 마칠 때 마다 공백을 붙인다.</p>
<p>이 처리가 끝나면 한가지 예외 케이스가 생긴다 바로 문자열의 맨끝에 공백이 있을 경우와 없을 경우를 잡아내지 못하는 것이다. 따라서 조건을 하나 더 추가하여 원래 문자열보다 작은지 큰지를 비교하여 작다면 공백을 추가하고 크다면 공백을 한 칸 제거한다.</p>
<p>최종 시간복잡도는 문자열 s의 길이를 n이라 할 때 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/jadencase.png" width="290" height="410">
</center>
<p><br></p>
<p>공백 여러개를 처리하는 과정에서 약간 헤맸었는데, 다른 사람의 풀이를 보니 flag를 이용해서 코드를 더 간결하게 짠 것을 보고 감탄했다. 다음엔 나도 flag를 이용해 문제를 풀어야겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>점프와 순간이동</title>
    <url>/2021/01/22/Jump-And-Teleport/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>k칸 앞으로 점프하는 경우 k만큼 건전지를 사용하고 워프를 통해 현재위치의 두배에 해당하는 위치로 비용없이 간다고 할 때, 목표 지점 n으로 이동하는 최소 건전지 사용량을 구하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JumpAndTele</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 Level2 점프와 순간 이동</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5000</span>;</span><br><span class="line">        System.out.println(Integer.bitCount(n));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure> 코드가 너무 간단해서 황당할 수 있다. 자바에는 bitCount란 메소드가 있다. 수를 넘겨주고 이를 2진수로 바꿨을 때 1의 개수를 반환하는 프로그램이다. 이것이 왜 성립하는지 알아보자.</p>
<p>일단 워프를 최대한 많이 쓰는 것이 좋은 것은 자명하다. 그렇다면 이를 어떻게 쓰냐는 건데, 5를 예로 들어보자 5로 가는 가장 빠른 방법은 2에서 워프를 하고 1을 더하면 된다. 2에 도달하는 방법은 1에서 워프를 타면 된다. 그렇다면 0에서 1로는 1만 더하면 된다. 이 방법이 이진법에서 1의 개수를 세는 것과 같다.</p>
<p>최종 시간복잡도는 2진법을 계산하는 과정이 있기 때문에 <span class="math inline">\(O(log_{2}n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/jump_and_teleport.png" width="290" height="540">
</center>
<p><br></p>
<p>원래는 <span class="math inline">\(O(n)\)</span>까지 복잡도를 줄여봐도 효율성이 개선이 안되었다. 10억이나 되기 때문이다. 남자친구랑 점심먹으면서 이 얘기를 하다가 남자친구의 힌트로 허무하게 문제를 풀었다. 역시 수학은 중요하다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>카카오프렌즈 컬러링북</title>
    <url>/2021/01/11/Kakao-Friends-ColoringBook/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>상하좌우 중 한 방향으로라도 같은 색깔이 칠해진 곳을 같은 영역이라 정의할 때, 영역의 개수와 최대 영역 넓이를 반환하는 함수를 만드는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KaKaoFriendColoringBook</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 카카오프렌즈 컬러링북</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = <span class="number">6</span>, n = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] picture = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">3</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> numberOfArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> maxSizeOfOneArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">boolean</span>[][] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(visited[i][j] == <span class="keyword">false</span> &amp;&amp; picture[i][j] != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    numberOfArea++;</span><br><span class="line">                    maxSizeOfOneArea = Math.max(maxSizeOfOneArea, getRegion(visited, i, j, picture, <span class="number">0</span>, picture[i][j], m, n));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;        </span><br><span class="line">        answer[<span class="number">0</span>] = numberOfArea;</span><br><span class="line">        answer[<span class="number">1</span>] = maxSizeOfOneArea;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRegion</span><span class="params">(<span class="keyword">boolean</span>[][] visited, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span>[][] picture, <span class="keyword">int</span> area, <span class="keyword">int</span> c_id, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r == m || c == n || r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> area;</span><br><span class="line">        <span class="keyword">if</span>(picture[r][c] != c_id)</span><br><span class="line">            <span class="keyword">return</span> area;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(visited[r][c] == <span class="keyword">true</span>)</span><br><span class="line">            <span class="keyword">return</span> area;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            visited[r][c] = <span class="keyword">true</span>;</span><br><span class="line">            area++;</span><br><span class="line">            <span class="keyword">int</span> left = getRegion(visited, r, c-<span class="number">1</span>, picture, <span class="number">0</span>, c_id, m, n);</span><br><span class="line">            <span class="keyword">int</span> right = getRegion(visited, r, c+<span class="number">1</span>, picture, <span class="number">0</span>, c_id, m, n);</span><br><span class="line">            <span class="keyword">int</span> up = getRegion(visited, r-<span class="number">1</span>, c, picture, <span class="number">0</span>, c_id, m, n);</span><br><span class="line">            <span class="keyword">int</span> down = getRegion(visited, r+<span class="number">1</span>, c, picture, <span class="number">0</span>, c_id, m, n);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> area+left+right+up+down;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 단순 탐색이기 때문에 리컬시브 함수만 이용한다면 빠르게 풀 수 있다. 필자는 getRegion을 통해 한 영역의 넓이를 계산할 생각이다. 리컬시브 코드를 볼 때는 항상 종료 조건을 잘 봐야한다. 어떠한 로봇이 있다고 상상하고 그 로봇이 동시에 한 블럭에서 동시에 상하좌우로 뻗어나가며 같은 영역인지 판단한다고 해보자. 그렇다면 3가지의 종료 조건을 생각할 수 있다. 1. 로봇이 그림 밖으로 나갔을 경우 2. 다른 색깔이 칠해져있는 경우 3. 이미 다른 로봇이 지나갔던 곳일 경우 이를 세가지의 if문으로 표시하였다. c_id는 현재 영역의 색깔을 나타내고 visited는 그 영역이 첫방문인지 알려주는 변수이다. 이 종료조건을 모두 통과했을 경우 현재 로봇이 서 있는 곳은 같은 영역으로 표시해야하는 것이다. 이럴 경우 방문했다는 것을 알려주기 위해 해당 visited를 true로 바꿔주고, area를 늘린다. 그리고 그 위치에서 상하좌우로 로봇을 보내기 위해 함수를 호출한다. 전체 영역은 현재 영역에서 상하좌우로 이어진 영역의 합을 구하는 것이므로 left,up,down,right에 각각의 영역을 담아 더하면 된다.</p>
<p>시간복잡도는 모든 영역이 칠해져 있을 때가 최악의 경우이다. 왜냐하면 mxn영역을 다보는데 mxn번 만큼 함수가 계속 호출되기 때문이다. 따라서 최종 시간복잡도는 <span class="math inline">\(O((m*n)^2)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/kakaofriend_coloring_book.png" width="370" height="60">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>자물쇠와 열쇠</title>
    <url>/2021/02/24/Key-and-Lock/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>열쇠의 돌기부분이 자물쇠의 홈에 맞는지 판별하는 문제이다. 열쇠를 자물쇠에 맞출 때, 열쇠가 자물쇠 바깥으로 삐져나올 수 있다. 하지만 자물쇠와 열쇠의 돌기부분이 서로 맞물리면 안된다. 자세한 사항은 아래 링크에서 확인하길 바란다.</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvNjAwNTk=">문제 링크<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockandKey</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level3 자물쇠와 열쇠</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] key = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] lock = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> answer = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//get rotation</span></span><br><span class="line">        <span class="keyword">int</span>[][][] keys = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][key.length][key.length];</span><br><span class="line">        <span class="comment">//make keys</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; key.length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                keys[<span class="number">0</span>][i][j] = key[i][j];</span><br><span class="line">                keys[<span class="number">1</span>][i][j] = key[key.length-<span class="number">1</span>-j][i];</span><br><span class="line">                keys[<span class="number">2</span>][i][j] = key[key.length-<span class="number">1</span>-i][key.length-<span class="number">1</span>-j];</span><br><span class="line">                keys[<span class="number">3</span>][i][j] = key[j][key.length-<span class="number">1</span>-i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//count zero</span></span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lock.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; lock.length; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(lock[i][j] == <span class="number">0</span>)</span><br><span class="line">                    zero++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//find match key</span></span><br><span class="line">        <span class="keyword">int</span> m = key.length;</span><br><span class="line">        <span class="keyword">int</span> n = lock.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//4keys</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; m+n-<span class="number">1</span>; c++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m+n-<span class="number">1</span>; r++)<span class="comment">//right corner position</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">//check if key is matched</span></span><br><span class="line">                    <span class="keyword">boolean</span> match = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">int</span> zero_cnt = zero;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> y = c-m+<span class="number">1</span>; y &lt;= c; y++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> x = r-m+<span class="number">1</span>; x &lt;= r; x++)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">if</span>(y &lt; <span class="number">0</span> || x &lt; <span class="number">0</span> || y &gt;= lock.length || x &gt;= lock.length)</span><br><span class="line">                                <span class="keyword">continue</span>;</span><br><span class="line">                            <span class="keyword">int</span> v = keys[i][y-(c-m+<span class="number">1</span>)][x-(r-m+<span class="number">1</span>)];</span><br><span class="line">                            <span class="keyword">if</span>(v == <span class="number">1</span> &amp;&amp; lock[y][x] == <span class="number">1</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                match = <span class="keyword">false</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span>(v == <span class="number">1</span> &amp;&amp; lock[y][x] == <span class="number">0</span>)</span><br><span class="line">                                zero_cnt--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span>(!match)</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//if answer found</span></span><br><span class="line">                    <span class="keyword">if</span>(zero_cnt == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        answer = <span class="keyword">true</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                        </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(answer)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(answer)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 코드가 긴편이다. 전체적인 과정을 생각해보면 다음과 같다. 1. 열쇠는 회전이 가능하다 90도씩 회전한 4개 열쇠를 만든다. 2. 자물쇠에서 홈이 몇 개 있는지 센다. 3. 자물쇠에 각 열쇠를 끼워본다. 4. 자물쇠에 열쇠가 맞고 모든 홈을 채웠다면 답을 true로 한다. 5. 그렇지 않다면 다음 자리로 열쇠를 이동해본다.</p>
<p>1번 과정 코드부터 살펴보자 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//get rotation</span></span><br><span class="line"><span class="keyword">int</span>[][][] keys = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][key.length][key.length];</span><br><span class="line"><span class="comment">//make keys</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; key.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; key.length; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        keys[<span class="number">0</span>][i][j] = key[i][j];</span><br><span class="line">        keys[<span class="number">1</span>][i][j] = key[key.length-<span class="number">1</span>-j][i]; <span class="comment">//90</span></span><br><span class="line">        keys[<span class="number">2</span>][i][j] = key[key.length-<span class="number">1</span>-i][key.length-<span class="number">1</span>-j]; <span class="comment">//180</span></span><br><span class="line">        keys[<span class="number">3</span>][i][j] = key[j][key.length-<span class="number">1</span>-i]; <span class="comment">//270</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 회전 각에 따라 총 4개의 열쇠가 나올 수 있다. 회전을 구현하는 방법은 읽는 순서를 달리하면 된다. 이는 코드에 나와있으니 코드를 스스로 공부하고 그림을 그려가면서 알아보길 바란다. 이렇게 하면 4개의 열쇠꾸러미를 손에 쥘 수 있다.</p>
<p>2번 과정은 2차원 배열을 순회하면서 0인 부분을 세면 된다. 이 부분은 간단하므로 넘어가자.</p>
<p>3,4,5과정은 한 코드로 나타나 있다. 범위 설정에 주의하면서 코드를 보자. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//find match key</span></span><br><span class="line"><span class="keyword">int</span> m = key.length;</span><br><span class="line"><span class="keyword">int</span> n = lock.length;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) <span class="comment">//4keys</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; m+n-<span class="number">1</span>; c++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; m+n-<span class="number">1</span>; r++)<span class="comment">//right corner position</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//check if key is matched</span></span><br><span class="line">            <span class="keyword">boolean</span> match = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> zero_cnt = zero;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> y = c-m+<span class="number">1</span>; y &lt;= c; y++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> x = r-m+<span class="number">1</span>; x &lt;= r; x++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(y &lt; <span class="number">0</span> || x &lt; <span class="number">0</span> || y &gt;= lock.length || x &gt;= lock.length)</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">int</span> v = keys[i][y-(c-m+<span class="number">1</span>)][x-(r-m+<span class="number">1</span>)];</span><br><span class="line">                    <span class="keyword">if</span>(v == <span class="number">1</span> &amp;&amp; lock[y][x] == <span class="number">1</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        match = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(v == <span class="number">1</span> &amp;&amp; lock[y][x] == <span class="number">0</span>)</span><br><span class="line">                        zero_cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(!match)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//if answer found</span></span><br><span class="line">            <span class="keyword">if</span>(zero_cnt == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                answer = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(answer)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(answer)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 첫번째 반복은 열쇠 꾸러미에서 몇 번째 열쇠를 쓸 것인지 나타낸다. 열쇠는 총 4개이므로 4개의 열쇠에 대해 각각 수행해본다.</p>
<p>c와 r의 반복은 열쇠를 이동해보는 반복이다. c와 r은 열쇠의 오른쪽 아래 모서리가 위치하는 점을 기준으로 하였다. 모든 경우의 수를 해보려면 오른쪽 아래 모서리가 (0,0)에서 (m+n-2, m+n-2)까지 움직여야 한다(m은 열쇠의 가로, n은 자물쇠의 가로이다).</p>
<p>열쇠를 이동했다면 이제 홈에 들어맞는지 확인해야 한다. 이는 y와 x에 대한 반복문으로 나타냈다. 오른쪽 아래 모서리를 기준으로 움직였기 때문에, 열쇠가 들어맞는지 검사하기 위해선 위쪽 모서리 값을 알아야 한다. 이는 (c-m+1, r-m+1)이다. 그럼 여기부터 열쇠와 자물쇠가 들어맞는지 확인하면 된다.</p>
<p>일단 x나 y가 자물쇠 범위 밖을 벗어났다면 비교할 필요가 없으므로 continue를 한다. 만약 범위 이내라면 둘을 비교한다. 이때 열쇠는 [0][0]부터 비교하는 것이기 때문에, 현재 y와 x에서 왼쪽 모서리 값을 빼준다.</p>
<p>만약 비교하는 열쇠와 자물쇠가 모두 돌기부분이라면 들어맞지 않으므로 break를 통해 탈출한다. 이 때 match를 이용해 한 번더 반복을 탈출하여 열쇠가 바로 이동할 수 있도록 한다.</p>
<p>만약 열쇠는 돌기이고 자물쇠가 홈부분이면, zero_cnt를 하나씩 줄인다. 모든 검사를 마칠 때 이 값이 0이라면 열쇠가 자물쇠에 들어맞다는 뜻이므로, 모든 반복을 탈출하고 답을 출력한다.</p>
<p>반복 횟수를 계산해보자면 <span class="math inline">\((m+n-2)(m+n-2)m*m\)</span>이 된다. 따라서 최고차항을 따로 떼어내면 최종 시간복잡도는 <span class="math inline">\(O(m^2n^2)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/lockandkey.png" width="290" height="500">
</center>
<p><br></p>
<p>처음으로 2시간 안에 level3문제를 스스로 풀어서 기쁘다. 멘탈만 흔들리지 않으면 성장할 수 있다고 생각하는 오늘이다. 요새 네카라쿠배 2차테스트를 하는데 알고보니 실수를 해서 점수를 다 날려 먹게 생겼다 하... 2일차까지 테스트 점수가 다 꽝인데 그래도 포기하지 않고 끝까지 해보기로 했다. 학원의 힘을 빌리지 않고도 성장할 수 있으니까! 가벼운 마음으로 테스트에 임하자.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level3</category>
      </categories>
  </entry>
  <entry>
    <title>평범한 배낭</title>
    <url>/2021/04/06/Knapsack/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>0-1 knapsack 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>이번에는 내 코드와 강사님이 최적화를 거친 코드를 단계로 보며 DP에 대해 정리하려고 한다. 일단 필자의 코드는 아래와 같다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N, K = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>))</span><br><span class="line"></span><br><span class="line">values = []</span><br><span class="line">weights = []</span><br><span class="line"></span><br><span class="line">max_dict = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N):</span><br><span class="line">    w, v = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split(<span class="string">&quot; &quot;</span>))</span><br><span class="line">    values.append(v)</span><br><span class="line">    weights.append(w)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">knapsack</span>(<span class="params">values, weights, n, W</span>):</span></span><br><span class="line">    <span class="keyword">if</span> W &lt;= <span class="number">0</span> <span class="keyword">or</span> n == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (n-<span class="number">1</span>, W) <span class="keyword">in</span> max_dict:</span><br><span class="line">        <span class="keyword">return</span> max_dict[(n-<span class="number">1</span>, W)]</span><br><span class="line"></span><br><span class="line">    res = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> W &gt;= weights[n-<span class="number">1</span>]:</span><br><span class="line">        res =  <span class="built_in">max</span>(knapsack(values, weights, n-<span class="number">1</span>, W), </span><br><span class="line">        knapsack(values, weights, n-<span class="number">1</span>, W-weights[n-<span class="number">1</span>]) + values[n-<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        res = knapsack(values, weights, n-<span class="number">1</span>, W)</span><br><span class="line"></span><br><span class="line">    max_dict[(n-<span class="number">1</span>, W)] = res</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(knapsack(values, weights, N, K))</span><br></pre></td></tr></table></figure>
<p>재귀를 이용한 구현이다. 가용치를 <code>W</code>라하고, <code>n</code>을 넣을 물건의 고유번호라고 생각하면, 이 둘이 0일 때 반환하는 값은 0이다.</p>
<p>계산했던 값을 저장하기 위해 <code>max_dict</code> 딕셔너리를 이용하였다. 여기에 들어가는 키 값은 물건의 고유번호와 가용치가 묶인 튜플이다. 값으로는 최대가치를 반환한다.</p>
<p>이 값이 만약에 존재한다면 계산 해뒀던 값이므로 이 값을 반환한다. 그렇지 않은 경우 값을 새로 계산하여야 한다. 만약 가용치안에 현재 물건이 들어갈 수 있다면, 들어간 경우와 그렇지 않은 경우를 모두 고려하여 값을 계산한다.</p>
<p>가용치안에 물건이 들어갈 수 없다면 없는 경우만 고려하면 된다. 이 때 계산한 값을 딕셔너리에 저장하는 것을 잊지말자!</p>
<p>백준에 결과를 돌려보면 다음과 같다.</p>
<figure>
<img src="/images/baekjoon/12865.png" alt="테스트 화면" /><figcaption aria-hidden="true">테스트 화면</figcaption>
</figure>
<p>이제 여기서 최적화를 한 단계씩 해나갈 수 있다. 기존의 Top-down방식을 Bottom-up으로 구성하면 코드는 다음과 같이 변경할 수 있다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N, K = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>.split())</span><br><span class="line"></span><br><span class="line">W = [<span class="number">0</span>] * (N + <span class="number">1</span>)</span><br><span class="line">V = [<span class="number">0</span>] * (N + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">    W[i], V[i] = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>.split())</span><br><span class="line"></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(K+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, K+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> w &gt;= W[i]:</span><br><span class="line">            dp[i][w] = <span class="built_in">max</span>(dp[i-<span class="number">1</span>][w], dp[i-<span class="number">1</span>][w-W[i]] + V[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i][w] = dp[i-<span class="number">1</span>][w]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dp[N][K]) </span><br></pre></td></tr></table></figure>
<p><code>dp</code>라는 2차원 리스트를 만들어서 <code>i</code>번째 물건을 가중치 <code>W</code>에 따라 넣는 경우와 넣지 않는 경우, 넣지 못하는 경우를 전부 기록한다.</p>
<figure>
<img src="/images/baekjoon/12865-1.png" alt="테스트 화면" /><figcaption aria-hidden="true">테스트 화면</figcaption>
</figure>
<p>위와 비교하여 메모리도 늘고 시간도 늘었다. 실은 이건 재귀에 비하면 느릴 수 있는게 애초에 2차원 배열의 모든 요소를 사용하지 않기 때문에 메모리 낭비가 있기 때문이다. 그리고 표의 모든 요소를 채우기 때문에 시간도 그만큼 오래 걸린다. 하지만 재귀같은 경우 998번이 넘는 호출을 할수가 없기 떄문에 데이터 값이 큰 경우 재귀는 사용하기 어렵기 때문에 이걸 알아놔야 한다.</p>
<p>여기서 보이는 개선 방안은 크게 두가지 이다.</p>
<ol type="1">
<li>공간의 낭비</li>
<li>표의 모든 요소를 계산할 필요가 없는 것</li>
</ol>
<p>이 두가지를 최적화 시켜나가려고 한다. 일단 공간적인 면에서 최적화를 시켜보자. 코드를 자세히 보면 점화식을 사용하는 부분에서 <code>i-1</code>번째 줄만 사용하는 것을 볼 수 있다. 그럼 그 이전의 행은 더 이상 쓸 일이 없으므로 이 부분에 대해서 최적화를 하면 다음과 같은 코드로 변경할 수 있다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">N, K = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">W = [<span class="number">0</span>] * (N + <span class="number">1</span>)</span><br><span class="line">V = [<span class="number">0</span>] * (N + <span class="number">1</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">    W[i], V[i] = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(K+<span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N+<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, K+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> w &gt;= W[i]:</span><br><span class="line">            dp[i%<span class="number">2</span>][w] = <span class="built_in">max</span>(dp[(i-<span class="number">1</span>)%<span class="number">2</span>][w], dp[(i-<span class="number">1</span>)%<span class="number">2</span>][w-W[i]] + V[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i%<span class="number">2</span>][w] = dp[(i-<span class="number">1</span>)%<span class="number">2</span>][w]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dp[N%<span class="number">2</span>][K]) </span><br></pre></td></tr></table></figure>
<p>i값에 따라 번갈아 가면서 값을 쓸 수 있도록 하였다.</p>
<figure>
<img src="/images/baekjoon/12865-2.png" alt="테스트 화면" /><figcaption aria-hidden="true">테스트 화면</figcaption>
</figure>
<p>연산 횟수는 다르지 않기 때문에 걸리는 시간은 그대로지만, 메모리 사용량이 크게 준 것을 확인하였다.</p>
<p>여기서 이제 2번에 대한 최적화를 추가로 할 수 있다. 연산량을 줄이는 것인데, 재귀로 코드를 짰을 때 호출되는 <code>w</code> 값을 계산하여 이를 저장하고 for문에서 이 값들에 대한 계산만 하면 최적화를 할 수 있다.</p>
<p>코드는 아래와 같다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">N, K = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">W = [<span class="number">0</span>] * (N + <span class="number">1</span>)</span><br><span class="line">V = [<span class="number">0</span>] * (N + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">    W[i], V[i] = <span class="built_in">map</span>(<span class="built_in">int</span>, <span class="built_in">input</span>().split())</span><br><span class="line"></span><br><span class="line">need_calc = [<span class="built_in">set</span>() <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(N + <span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">need_calc[N].add(K)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(N, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> need_calc[i]:</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">0</span> <span class="keyword">or</span> w == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> w &gt;= W[i]:</span><br><span class="line">            need_calc[i-<span class="number">1</span>].add(w-W[i])</span><br><span class="line">        need_calc[i-<span class="number">1</span>].add(w)</span><br><span class="line"></span><br><span class="line">dp = [[<span class="number">0</span> <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(K + <span class="number">1</span>)] <span class="keyword">for</span> _ <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>)]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, N + <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> w <span class="keyword">in</span> need_calc[i]:</span><br><span class="line">        <span class="keyword">if</span> w &gt;= W[i]:</span><br><span class="line">            dp[i%<span class="number">2</span>][w] = <span class="built_in">max</span>(dp[(i-<span class="number">1</span>)%<span class="number">2</span>][w], dp[(i-<span class="number">1</span>)%<span class="number">2</span>][w-W[i]] + V[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dp[i%<span class="number">2</span>][w] = dp[(i-<span class="number">1</span>)%<span class="number">2</span>][w]</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(dp[N%<span class="number">2</span>][K])</span><br></pre></td></tr></table></figure>
<p>첫번째 for문을 주목하자. 우리는 이미 점화식을 통해 계산해야 하는 <code>w</code>값을 알 수 있다. 그래서 초기에 최종 가용치만을 넣어두고 여기에서 두 경우(선택하는 경우와 하지 않는 경우)로 나누어서 계산에 쓰이는 <code>w</code>값만 <code>need_calc</code>에 넣는다.</p>
<figure>
<img src="/images/baekjoon/12865-3.png" alt="테스트 화면" /><figcaption aria-hidden="true">테스트 화면</figcaption>
</figure>
<p>오버헤드가 없기 때문에 시간이 재귀보다 단축한 것을 볼 수 있다. 이렇게 최적화 과정에 대해 공부하였는데, 공부를 많이 해야겠다는 생각이 든다. 기죽지 말고 꾸준히 공부해야겠다. ✍️</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Beakjoon</category>
        <category>12000-12999</category>
      </categories>
  </entry>
  <entry>
    <title>k번째수</title>
    <url>/2020/12/23/Kth-Num/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>배열이 주어지고 명령어가 들어올 때 해당하는 숫자들을 배열에 모아 반환해야 한다. 명령어는 총 3부분인데 [i, j, k]라고 하면 배열의 i에서 j번째까지 자른 다음에 이를 정렬한다. 그리고 이 부분 배열중에서 k번째 숫자를 고르면 된다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>부분 배열을 얼마나 잘 만드는가의 문제인데 자바같은 경우 이미 라이브러리가 존재한다(그래서 1점밖에 득점을 못했나..). 논리자체는 어렵지 않다. 문제에서 요구하는 사항을 그대로 따라가면 된다.</p>
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KthNum</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] array = &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">7</span>, <span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] commands = &#123;</span><br><span class="line">            &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>, <span class="number">4</span>, <span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">7</span>, <span class="number">3</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        ArrayList&lt;Integer&gt; num = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; commands.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span>[] subarr = Arrays.copyOfRange(array, commands[i][<span class="number">0</span>]-<span class="number">1</span>, commands[i][<span class="number">1</span>]);</span><br><span class="line">            Arrays.sort(subarr);</span><br><span class="line">            num.add(subarr[commands[i][<span class="number">2</span>]-<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[num.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            answer[i] = Integer.parseInt(num.get(i).toString());</span><br><span class="line">            <span class="comment">//System.out.print(answer[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>부분부분 살펴보자</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;Integer&gt; num = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; commands.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>[] subarr = Arrays.copyOfRange(array, commands[i][<span class="number">0</span>]-<span class="number">1</span>, commands[i][<span class="number">1</span>]);</span><br><span class="line">    Arrays.sort(subarr);</span><br><span class="line">    num.add(subarr[commands[i][<span class="number">2</span>]-<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>부분배열 subarr를 만들기위해 copyOfRange를 사용한다. copyOfRange의 경우 [i,j)이기 때문에 i-1을 입력해야한다. 배열은 0부터 시작한다. 잊지말자. end부분에는 -1할 필요가 없다. 애초에 포함이 안된다. 그 다음 부분배열을 정렬해주고 k번째에 해당하는 수는 num에 넣어준다. 이 부분에서 시간복잡도는 일단 commands의 길이를 m이라하고 array의 길이를 n이라고 한다면, <span class="math inline">\(O(mnlogn)\)</span>이 된다. i와 j로인해 잘리는 최대 크기가 n이기 때문이다. copyOfRange에서 <span class="math inline">\(O(n)\)</span>의 시간이 걸리고 sort에서 <span class="math inline">\(O(nlogn)\)</span>의 시간복잡도를 가진다. add는 <span class="math inline">\(O(1)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/kth_num.png" width="400" height="300">
</center>
<p><br></p>
<p>이번 포스팅은 문제의 요구사항을 그대로 코드로 옮기는 것이라 그렇게 어려운 부분이 없다. 하지만 여전히 Integer를 int로 바꾸는 것은 익숙치 않다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>구명보트</title>
    <url>/2021/01/15/Life-Boat/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>최대 2명까지 탈 수 있고 무게 제한이 limit인 구명보트를 최대한 적게 사용해서 사람들을 보트에 태우는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LifeBoat</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 구명보트</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] people = &#123;<span class="number">70</span>, <span class="number">50</span>, <span class="number">80</span>, <span class="number">50</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> limit = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; small = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        PriorityQueue&lt;Integer&gt; big = <span class="keyword">new</span> PriorityQueue&lt;&gt;(Collections.reverseOrder());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w : people)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(w &lt;= limit/<span class="number">2</span>)</span><br><span class="line">                small.add(w);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                big.add(w);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>((!small.isEmpty()) &amp;&amp; (!big.isEmpty()))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> s = small.peek();</span><br><span class="line">            <span class="keyword">int</span> b = big.peek();</span><br><span class="line">            <span class="keyword">if</span>(s+b &gt; limit)</span><br><span class="line">            &#123;</span><br><span class="line">                big.remove();</span><br><span class="line">                answer++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                small.remove();</span><br><span class="line">                big.remove();</span><br><span class="line">                answer++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!small.isEmpty())</span><br><span class="line">            answer += small.size() % <span class="number">2</span> == <span class="number">0</span> ? small.size()/<span class="number">2</span> : small.size()/<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            answer += big.size();</span><br><span class="line"></span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 정렬을 사용할 수 있고 우선순위큐를 활용할 수도 있지만, 필자는 우선순위 큐를 활용하였다. 15-21번째 줄은 limit/2를 기준으로 작은것과 큰 것으로 무게를 나눠담는 과정이다. small은 오름차순으로 정렬하고 big은 내림차순으로 정렬한다. 22-37번째 줄은 두 큐에서 사람을 하나씩 뽑아 보트에 태울 수 있는지 보는것이다. 만약 태우지 못한다면 큰 사람 하나를 보트에 태워보내고, 다음으로 무거운 사람을 같이 태울 수 있는지 비교한다. 만약 같이 탈 수 있으면 둘 다 큐에서 제거하고 answer를 1증가한다. 반복문을 탈출하는 경우는 두 큐 모두 비었거나, 둘 중 하나만 빈 것이므로 이에 대한 나머지 처리도 해야한다. 만약 small이 남은 경우 무조건 둘씩 태워 보낼 수 있으므로 (small 총 개수)/2를 한다. 이때 홀수명이 남는다면 1을 추가하는 것을 잊지말자. big에 속한 사람들은 한 사람씩 밖에 못 타므로 사람수만큼 추가해주면 된다.</p>
<p>우선 순위 큐를 활용했으므로 총 시간복잡도는 <span class="math inline">\(O(nlogn)\)</span>이 된다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/lifeboat.png" width="290" height="530">
</center>
<p><br></p>
<p>처음에 40번째 줄에 else가 아니라 else if문을 썼는데 효율성 테스트를 하나 통과하지 못했다. 그래서 else로 바꾸니 통과가 되었다. size를 한번 더 호출하냐 마냐가 차이인 것 같은데, 효율성 테스트가 조금 빡빡하단 생각이 들었다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>기능개발</title>
    <url>/2021/01/07/Make-Feature/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>먼저 배포해야하는 작업의 진행률과 작업속도가 주어진다. 뒤에 있는 개발이 완료되지 않더라도 앞순서의 개발이 완료되면 배포해야한다. 각 배포 시기마다 몇 개의 기능이 배포되는지 계산하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FunctionDevelope</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 level2 문제풀이 기능 개발</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] progresses = &#123;<span class="number">93</span>, <span class="number">30</span>, <span class="number">55</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] speeds = &#123;<span class="number">1</span>, <span class="number">30</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        ArrayList&lt;Integer&gt; answer = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> r_date;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; progresses.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            r_date = (<span class="keyword">int</span>)Math.ceil((<span class="number">100</span>-progresses[i])/(<span class="keyword">double</span>)speeds[i]);</span><br><span class="line">            q.add(r_date);</span><br><span class="line">        &#125;</span><br><span class="line">        r_date = q.peek();</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(r_date &gt;= q.peek())</span><br><span class="line">            &#123;</span><br><span class="line">                cnt++;</span><br><span class="line">                q.remove();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                answer.add(cnt);</span><br><span class="line">                cnt = <span class="number">1</span>;</span><br><span class="line">                r_date = q.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        answer.add(cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 일단 각 기능이 언제 개발이 완료하는지 계산해야한다. 이 때, 배포는 하루의 끝에 완료된다는 가정이 있기 때문에 올림으로 처리해야한다. 정수간의 나눗셈은 정수만 반환하므로, 실수로 캐스팅하는 걸 잊어선 안된다. 그리고 큐에 완성일을 추가한다.</p>
<p>이 문제는 쉽게 큐에서 오름차순을 찾아내는 문제이다. 배포일 r_date를 큐의 첫번째 원소로 초기화한다. 그리고 배포되는 기능의 개수를 저장하는 cnt를 같이 선언한다. 큐에서 원소들을 보면서 r_date보다 빠른 것들은 같이 배포해야하는 것들이므로 cnt를 늘린다. 만약 r_date보다 늦게 배포하는 것은 배포일을 따로 하는 것이므로, 그 때 cnt를 어레이리스트에 저장하고 cnt를 1로 초기화한다. 비교할 r_date는 해당 원소로 업데이트한다.</p>
<p>이 문제의 시간복잡도는 큐에 들어갔다 나오는 최대 반복을 생각하면 된다. progresses의 길이를 n이라 했을 때, 총 삽입과 삭제의 수는 2n이다. 따라서 시간복잡도는 <span class="math inline">\(O(n)\)</span>이 된다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/function_develope.png" width="340" height="400">
</center>
<p><br></p>
<p>이 문제같은 경우 시간을 너무 많이 소요했다. 두번째 조건을 생각하기 힘들었는데, 질문하기에서 누군가가 올려준 테스트케이스 덕분에 통과할 수 있었다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>최솟값 만들기</title>
    <url>/2021/01/20/Make-Min/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>두 배열에서 한 숫자씩 뽑아 둘의 곱을 더해나갈 때 최솟값을 구하는 문제이다. 단 중복으로 숫자를 뽑는 것은 허용하지 않는다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MakeMin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 최솟값 만들기</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] A = &#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] B = &#123;<span class="number">5</span>, <span class="number">4</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(A);</span><br><span class="line">        Arrays.sort(B);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; A.length; i++)</span><br><span class="line">            answer += A[i] * B[A.length-i-<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 최솟값을 만들기 위해선 각각의 배열에서 가장작은수와 가장큰수가 곱해져 나가야한다. 이를 생각해내면 코드는 단순하다. 두 배열을 정렬하고 하나는 앞에서부터 하나는 뒤에서부터 뽑아 곱해서 더하면 된다.</p>
<p>최종적인 시간복잡도는 배열의 길이를 n이라고 할 때, 정렬을 사용하였으므로 <span class="math inline">\(O(nlogn)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/make_min.png" width="290" height="530">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>이상한 문자 만들기</title>
    <url>/2020/12/29/Make-Strange-String/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>공백을 기준으로 만든 단어의 홀수번째는 소문자 짝수번째는 대문자로 바꾸어 출력하는 문제이다. 필자는 문제를 읽고 당연히 모든 문자는 알파벳이라 가정하고 풀었는데 틀렸다,, 알고보니 여러 공백이 들어가 있을 수도 있다는 글을 읽고 다시 풀어서 정답을 얻었다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MakeStrangeStr</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 level1 이상한 문자 만들기</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;try hello world&quot;</span>;</span><br><span class="line">        StringBuffer buff = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c = s.charAt(i);</span><br><span class="line">            String st = Character.toString(c);</span><br><span class="line">            <span class="keyword">if</span>(st.equals(<span class="string">&quot; &quot;</span>))</span><br><span class="line">                j = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (c &gt;=<span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;Z&#x27;</span> || c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;z&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(j%<span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                    st = st.toUpperCase();</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    st = st.toLowerCase();</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            buff.append(st);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        String answer = buff.toString();</span><br><span class="line">        System.out.print(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 문자열에서 문자를 하나하나 뗀다. 또는 toCharArray()로 char배열을 생성해도 된다. 여기서 j라는 숫자는 단어를 공백에 맞춰 잘랐을 때, 단어의 인덱스를 나타내기 위함이다. 공백을 만났을 경우 이 j는 0으로 초기화된다. 알파벳을 만났을 경우 짝수나 홀수냐에 따라 대문자 또는 소문자로 바꿔준다. 나중에 다른사람의 풀이를 보니 단어를 이루고있는 요소들 중에 숫자나 특수문자는 없는 것 같았다. 하지만 테스트 케이스를 정확히 알 수 없기 때문에 필자는 문자인가에 대한 확인도 추가로 해주었다. 이렇게 변환한 문자열을 버퍼에 넣어 스트링으로 바꾸면 완성이다. 총 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/make_strange_str.png" width="400" height="300">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>소수 만들기</title>
    <url>/2021/01/21/Make-Prime-Num/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>nums에 있는 수 중 3가지를 뽑아 그 합이 소수인 경우의 수를 출력하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MakePrime</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 소수 만들기</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> answer = ReturnPrimeCnt(nums, <span class="number">0</span>, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ReturnPrimeCnt</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> idx, <span class="keyword">int</span> sum, <span class="keyword">int</span> cnt)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= Math.sqrt(sum); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(sum % i == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = idx; i &lt;= nums.length-cnt; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                res += ReturnPrimeCnt(nums, i+<span class="number">1</span>, sum+nums[i], cnt-<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 숫자 3개를 뽑는 재귀를 이용해 문제를 풀었다. ReturnPrimeCnt는 다음과 같이 동작한다. 1. 만약 cnt가 0이면 3개를 다 뽑았다는 의미이므로 소수인지 판별한다. 필자는 에라토테네스의 체를 활용해 시간을 단축했다. 소수면 1, 아니면 0을 반환한다. 2. 아직 숫자를 더 뽑을 수 있다면 idx부터 nums길이 - cnt까지 숫자를 모두 뽑아본다. 경우의수에서 가지를 쳐나가는 것과 비슷하다고 생각하면 된다. for문의 범위는 중복없이 수를 뽑을 수 있게 한것이므로 앞으로의 코딩에도 참고하면 많은 도움이 될 것이다.</p>
<p>이 함수는 3개만 아니라 4개, 5개로 영역을 뻗어나갈 수 있다. 하지만 속도가 좀 느릴 수 있다. 이 문제에선 오히려 3중 루프가 더 빠르다.</p>
<p>최종 시간복잡도는 3개 수를 뽑는 모든 수를 탐색하므로 <span class="math inline">\(O(n^3)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/make_prime.png" width="290" height="540">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>최댓값과 최솟값</title>
    <url>/2021/01/20/Max-Min/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>공백으로 구분된 문자열에서 최댓값과 최솟값을 찾는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaxMin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 최댓값과 최솟값</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;1 2 3 4&quot;</span>;</span><br><span class="line">        String[] arr = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> max = -<span class="number">2000000000</span>;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">2000000000</span>;</span><br><span class="line">        <span class="keyword">for</span>(String str : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> i = Integer.parseInt(str);</span><br><span class="line">            <span class="keyword">if</span>(i &gt; max)</span><br><span class="line">                max = i;</span><br><span class="line">            <span class="keyword">if</span>(min &gt; i)</span><br><span class="line">                min = i;</span><br><span class="line">        &#125;</span><br><span class="line">        StringBuilder buff = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        buff.append(min);</span><br><span class="line">        buff.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        buff.append(max);</span><br><span class="line"></span><br><span class="line">        System.out.println(buff.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 2단계라 테스트케이스가 int를 넘어가지 않을 것이라 생각했다. 그래서 max와 min에 int안에서 한계값에 가까운 큰 수를 할당한 뒤, 숫자들을 하나씩 보면서 max와 min값을 갱신하였다.</p>
<p>최종적인 시간복잡도는 문자열 s의 길이를 n이라 할 때, <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/max_min.png" width="290" height="310">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>수식 최대화</title>
    <url>/2021/01/21/Maximize-Formula/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>(+,-,*)로 이루어진 수식이 있다. 이 수식의 우선순위를 정하여 수식 결과의 최대 절대값을 구하는 문제이다. 단 세 연산자 간의 우선순위는 같을 수 없다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.Queue;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MaximizeExpression</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 수식 최대화</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String expression = <span class="string">&quot;100-200*300-500+20&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span>[] price = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">6</span>];</span><br><span class="line">        Queue&lt;String&gt; q1 = ReturnPostfix(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, expression);</span><br><span class="line">        Queue&lt;String&gt; q2 = ReturnPostfix(<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, expression);</span><br><span class="line">        Queue&lt;String&gt; q3 = ReturnPostfix(<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, expression);</span><br><span class="line">        Queue&lt;String&gt; q4 = ReturnPostfix(<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, expression);</span><br><span class="line">        Queue&lt;String&gt; q5 = ReturnPostfix(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, expression);</span><br><span class="line">        Queue&lt;String&gt; q6 = ReturnPostfix(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, expression);</span><br><span class="line">        </span><br><span class="line">        price[<span class="number">0</span>] = ReturnPrice(q1);</span><br><span class="line">        price[<span class="number">1</span>] = ReturnPrice(q2);</span><br><span class="line">        price[<span class="number">2</span>] = ReturnPrice(q3);</span><br><span class="line">        price[<span class="number">3</span>] = ReturnPrice(q4);</span><br><span class="line">        price[<span class="number">4</span>] = ReturnPrice(q5);</span><br><span class="line">        price[<span class="number">5</span>] = ReturnPrice(q6);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : price)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(answer &lt; n)</span><br><span class="line">                answer = n;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(answer);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ReturnPriority</span><span class="params">(<span class="keyword">int</span> p_rank, <span class="keyword">int</span> s_rank, <span class="keyword">int</span> m_rank, <span class="keyword">char</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> p_rank;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> s_rank;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> m_rank;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;String&gt; <span class="title">ReturnPostfix</span><span class="params">(<span class="keyword">int</span> p_rank, <span class="keyword">int</span> s_rank, <span class="keyword">int</span> m_rank, String expression)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        StringBuilder buff = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : expression.toCharArray())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c &gt;= <span class="number">48</span> &amp;&amp; c &lt;=<span class="number">57</span>)</span><br><span class="line">                buff.append(c);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                q.add(buff.toString());</span><br><span class="line">                buff.delete(<span class="number">0</span>, buff.length());</span><br><span class="line">                <span class="keyword">if</span>(stack.empty())</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> rank = ReturnPriority(p_rank, s_rank, m_rank, c);</span><br><span class="line">                    <span class="keyword">while</span>(!stack.empty() &amp;&amp; ReturnPriority(p_rank, s_rank, m_rank, stack.peek()) &lt;= rank)</span><br><span class="line">                    &#123;</span><br><span class="line">                        q.add(String.valueOf(stack.peek()));</span><br><span class="line">                        stack.pop();</span><br><span class="line">                    &#125;</span><br><span class="line">                    stack.push(c);</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        q.add(buff.toString());</span><br><span class="line">        <span class="keyword">while</span>(!stack.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            q.add(String.valueOf(stack.peek()));</span><br><span class="line">            stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ReturnPrice</span><span class="params">(Queue&lt;String&gt; q)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!q.isEmpty())</span><br><span class="line">        &#123;</span><br><span class="line">            String s = q.poll();</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> n = Integer.parseInt(s);</span><br><span class="line">                stack.push(n);</span><br><span class="line">            &#125;<span class="keyword">catch</span>(NumberFormatException e)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> n2 = stack.peek();</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">int</span> n1 = stack.peek();</span><br><span class="line">                stack.pop();</span><br><span class="line">                <span class="keyword">if</span>(s.equals(<span class="string">&quot;+&quot;</span>))</span><br><span class="line">                    stack.push(n1+n2);</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;-&quot;</span>))</span><br><span class="line">                    stack.push(n1-n2);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    stack.push(n1*n2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(stack.peek());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 코드가 좀 긴 편인데 과정을 설명하자면 다음과 같다. 1. 중위표기식(infix)를 후위표기식(postfix)로 고친다. 2. 후위표기식을 계산하고 절대값을 반환한다. 3. 3가지 연산자로 만들 수 있는 모든 우선순위인 6가지에 대해서 1,2과정을 반복하고 가장 큰 값을 반환한다.</p>
<p>main에 있는 것이 3번과정이다. 우리는 1번과 2번에 대한 상세한 내용을 보려고 한다. 일단 중위표기식을 후위표기식으로 변환하는 코드를 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Queue&lt;String&gt; <span class="title">ReturnPostfix</span><span class="params">(<span class="keyword">int</span> p_rank, <span class="keyword">int</span> s_rank, <span class="keyword">int</span> m_rank, String expression)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    Queue&lt;String&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    StringBuilder buff = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : expression.toCharArray())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c &gt;= <span class="number">48</span> &amp;&amp; c &lt;=<span class="number">57</span>)</span><br><span class="line">            buff.append(c);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            q.add(buff.toString());</span><br><span class="line">            buff.delete(<span class="number">0</span>, buff.length());</span><br><span class="line">            <span class="keyword">if</span>(stack.empty())</span><br><span class="line">                stack.push(c);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> rank = ReturnPriority(p_rank, s_rank, m_rank, c);</span><br><span class="line">                <span class="keyword">while</span>(!stack.empty() &amp;&amp; ReturnPriority(p_rank, s_rank, m_rank, stack.peek()) &lt;= rank)</span><br><span class="line">                &#123;</span><br><span class="line">                    q.add(String.valueOf(stack.peek()));</span><br><span class="line">                    stack.pop();</span><br><span class="line">                &#125;</span><br><span class="line">                stack.push(c);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    q.add(buff.toString());</span><br><span class="line">    <span class="keyword">while</span>(!stack.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        q.add(String.valueOf(stack.peek()));</span><br><span class="line">        stack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>받은 매개변수에 대해 간단히 살펴보면 p가 더하기 s가 빼기 m을 곱하기로 보면 된다. 이들에 대한 우선순위를 main에서 받아오는 것이며, 숫자가 작을 수록 우선순위가 높은 것으로 가정했다. expression은 중위표기식이다. 이제 중위표기식을 문자단위로 쪼갠다. 이 문자들을 살펴보면서 변환과정을 할 예정이다. for문의 첫번째 if문을 보면 c가 숫자인 경우 버퍼에다 문자를 담아준다. 주어진 식이 한자리 수만 주어진 것이 아니기 때문에 이렇게 한다. 만약 연산자가 주어진 경우 여태까지 버퍼에 담긴것이 한 숫자이므로 이를 스트링으로 바꿔 큐에 삽입한다. 삽입하고 난 뒤 버퍼에 있는 내용은 지운다. 이제 연산자에 대한 처리를 할 차례이다. 만약 스택이 비어있다면 연산자를 그대로 넣어준다. 그렇지 않다면 스택에 있는 연산자들과의 비교가 필요하다. 이들의 우선순위를 비교하여 우선순위가 자신보다 같거나 작다면 스택에서 꺼내서 큐에 넣는다. 이때, 우선순위가 같아도 꺼내는 이유는 같은 연산자일 때, 왼쪽에 있는 연산자가 더 우세하기 때문이다. 꺼내는 과정을 모두 마치면 해당 연산자를 넣는다(ReturnPriority에 대한 코드는 각자가 보길 바란다.). 모든 문자에 대해 이 과정을 마치면 버퍼에는 마지막 피연산자가 있으므로 이를 넣어주고 스택에 남은 모든 연산자를 꺼내어 큐에 넣어준다.</p>
<p>스택에서 푸쉬와 팝이 이루어지지만 전체 중위표기식의 길이를 n이라 할 때, 이것보단 미미한 수이므로 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<p>이렇게 바꾼 후위표기식을 연산해보자. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ReturnPrice</span><span class="params">(Queue&lt;String&gt; q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span>(!q.isEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        String s = q.poll();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> n = Integer.parseInt(s);</span><br><span class="line">            stack.push(n);</span><br><span class="line">        &#125;<span class="keyword">catch</span>(NumberFormatException e)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> n2 = stack.peek();</span><br><span class="line">            stack.pop();</span><br><span class="line">            <span class="keyword">int</span> n1 = stack.peek();</span><br><span class="line">            stack.pop();</span><br><span class="line">            <span class="keyword">if</span>(s.equals(<span class="string">&quot;+&quot;</span>))</span><br><span class="line">                stack.push(n1+n2);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.equals(<span class="string">&quot;-&quot;</span>))</span><br><span class="line">                stack.push(n1-n2);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                stack.push(n1*n2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Math.abs(stack.peek());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 연산은 간단하다 큐에서 원소들을 하나씩 빼서 숫자인 경우 스택에 넣는다. 만약 연산자인 경우 스택에서 두 수를 꺼내어 연산을 해준 뒤 다시 스택에 넣어주면 된다. 큐가 비어있으면 스택에 남은 원소 하나가 결과값이다(이 코드를 작성할 때 첫번째로 꺼내는 수가 n1이 아니라 n2라는 것에 주의하자.).</p>
<p>이 부분의 시간복잡도 역시 <span class="math inline">\(O(n)\)</span>이라 볼 수 있다. 최종 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/maximize_expression.png" width="290" height="530">
</center>
<p><br></p>
<p>후위표기식으로 변환하는 방법과 연산을 다 까먹어서 다시 공부하는데 애를 먹었다. 대학교 2학년 때 과제만 치중해서 원리를 제대로 공부하지 못한 내 자신이 살짝 원망스럽다. 그래도 이번 기회에 제대로 공부했으니 앞으로는 잊지 말아야겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>더 맵게</title>
    <url>/2021/01/12/More-Spicy/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>모든 음식이 스코빌 지수 k를 넘기게 하기 위해 맵지 않은 음식을 섞어서 더 맵게 만들려고 한다.</p>
<blockquote>
<p>섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 * 2)</p>
</blockquote>
<p>모든 음식을 K이상의 스코빌 지수로 만들려고 할 때 섞어야 하는 최소 횟수를 계산하는 문제이다. 만약 불가능하다면 -1을 반환한다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MoreSpicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 level2 문제풀이 더 맵게</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] scoville = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">12</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> K = <span class="number">7</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isPossible = <span class="keyword">true</span>;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> food : scoville)</span><br><span class="line">            pq.add(food);</span><br><span class="line">        <span class="keyword">while</span>(pq.size() &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pq.peek() &gt;= K)</span><br><span class="line">            &#123;</span><br><span class="line">                isPossible = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                Integer food1 = pq.poll();</span><br><span class="line">                Integer food2 = pq.poll();</span><br><span class="line">                pq.add(food1 + food2*<span class="number">2</span>);</span><br><span class="line">                answer++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pq.peek() &lt; K)</span><br><span class="line">            answer = -<span class="number">1</span>;</span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 이 문제는 우선순위 큐만 알면 쉽게 해결할 수 있다. 일단 모든 음식을 큐에 넣은 다음 맨 앞 음식을 확인하여 K미만 이라면 큐에서 두 음식을 꺼내 계산식에 넣은 결과를 다시 넣는다. 만약 가장 안 매운 음식이 K를 넘는다면 반복문을 탈출하고 else문에 들어간 횟수를 반환한다. 만약 모든 음식을 섞어도 스코빌 지수를 만족하지 못한다면 큐에는 하나의 음식만 남게 되고 while문 조건에 의해 반복문을 탈출한다. 큐에서 가장 안 매운 음식을 꺼냈을 때 K보다 작으므로 -1이 된다. 만약 모든 음식이 K를 넘는다면 answer은 0이 될 것이다.</p>
<p>우선순위 큐를 활용했으므로 최종 시간복잡도는 <span class="math inline">\(O(nlogn)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/more_spicy.png" width="290" height="540">
</center>
<p><br></p>
<p>질문하기를 둘러보니 직접 힙을 구현한 경우 통과가 안되고 라이브러리 힙을 사용해야 통과되는 경우가 더러 있었다고 한다. 이 부분에서는 효율성 평가 개선이 이루어져야 한다고 생각한다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>행렬의 곱셈</title>
    <url>/2021/01/20/Multiply-Matrix/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>두 행렬 arr1, arr2가 주어질 때 arr1에 arr2가 곱해진 결과를 반환하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MatrixMultiply</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 행렬의 곱셈</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] arr1 = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">4</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>, <span class="number">2</span>&#125;,</span><br><span class="line">            &#123;<span class="number">4</span>, <span class="number">1</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] arr2 = &#123;</span><br><span class="line">            &#123;<span class="number">3</span>, <span class="number">3</span>&#125;,</span><br><span class="line">            &#123;<span class="number">3</span>, <span class="number">3</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span>[][] answer = <span class="keyword">new</span> <span class="keyword">int</span>[arr1.length][arr2[<span class="number">0</span>].length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; arr1.length; r++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; arr2[<span class="number">0</span>].length; c++)</span><br><span class="line">            &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> idx = <span class="number">0</span>; idx &lt; arr1[<span class="number">0</span>].length; idx++)</span><br><span class="line">                    temp += arr1[r][idx] * arr2[idx][c]; </span><br><span class="line">                </span><br><span class="line">                answer[r][c] = temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 행렬의 곱셈을 안다면 그대로 코드에 옮기면 된다.</p>
<p>시간복잡도는 arr1의 크기를 nxc라 하고 arr2의 크기를 cxm이라 할 때 <span class="math inline">\(O(cnm)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/matrix_multiple.png" width="290" height="410">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>N개의 최소공배수</title>
    <url>/2021/01/21/N-LCM/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>N개의 수가 주어지고 이 수 전체의 최소공배수를 구하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.math.BigInteger;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NNumLCM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 Level2 n개의 최소공배수</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">14</span>&#125;;</span><br><span class="line">        <span class="keyword">if</span>(arr.length == <span class="number">1</span>)</span><br><span class="line">            System.out.println(arr[<span class="number">0</span>]); </span><br><span class="line"></span><br><span class="line">        BigInteger n1 = <span class="keyword">new</span> BigInteger(Integer.toString(arr[<span class="number">0</span>]));</span><br><span class="line">        BigInteger n2 = <span class="keyword">new</span> BigInteger(Integer.toString(arr[<span class="number">1</span>]));</span><br><span class="line">        BigInteger gcd = n1.gcd(n2);</span><br><span class="line">        n1 = n1.multiply(n2).divide(gcd);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; arr.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            n2 = <span class="keyword">new</span> BigInteger(Integer.toString(arr[i]));</span><br><span class="line">            gcd = n1.gcd(n2);</span><br><span class="line">            n1 = n1.multiply(n2).divide(gcd);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> answer = Integer.parseInt(String.valueOf(n1));</span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 1. 두 수의 곱은 두 수의 최소공배수와 최대공약수의 곱과 같다. 2. 최소공배수는 모두의 배수이다.</p>
<p>이 두 가지만 알면 문제를 풀 수 있다. 2번이 무슨 말이냐고 할 수 있는데, 코드에 나와있는 것을 예시로 들면 2와 6의 최소공배수는 12이고 12와 8의 최소공배수가 24이고, 24와 14의 최소공배수는 168이다. 즉, 최소공배수를 앞에 두개씩 구해나가다보면 그것이 모든 수의 최소공배수가 된다는 것이다. 최소공배수를 구하는 방법은 1번식을 활용하면 된다.</p>
<p>이제 코드를 보자. 배열의 길이가 1인 경우에는 공배수라는 개념이 없으므로 원소 하나를 프린트하면된다. 그렇지 않은 경우 두 수의 촤대공약수를 구해 두 수의 곱에서 나눠주는 과정을 반복하면 된다.</p>
<p>최종 시간복잡도는 arr의 길이를 n이라 할 때 <span class="math inline">\(O(nlog_{2}n)\)</span>이다. 왜냐하면 n번 동안 gcd를 사용하기 때문인데, 정확한 시간복잡도는 나와있지 않지만, 두 수를 a,b라 할때 한 쪽의 절반보다 크냐 작냐에 따라 연산이 달라지므로 <span class="math inline">\(log_{2}n\)</span>이라 생각한다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/nnum_lcm.png" width="290" height="260">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>N진수 게임</title>
    <url>/2021/02/03/N-Digit-Game/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>0부터 1씩 증가하는 수를 n진수로 표현하고 이를 돌아가면서 한명씩 말하는게 n진수 게임이다. 이 게임에서 주어진 순서의 플레이어가 앞으로 말해야 할 숫자를 계산해주는 프로그램을 짜는 문제이다. 게임 참여 인원과 내가 보고자하는 플레이어의 순서가 주어진다. <span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvMTc2ODY=">문제 링크<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NthGame</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 n진수 게임</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=<span class="number">2</span>, t=<span class="number">4</span>, m=<span class="number">2</span>, p=<span class="number">1</span>; </span><br><span class="line">        String answer = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String answer = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt &lt; t)</span><br><span class="line">        &#123;</span><br><span class="line">            Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">            <span class="keyword">int</span> t_num = num;</span><br><span class="line">            <span class="keyword">do</span></span><br><span class="line">            &#123;</span><br><span class="line">                stack.push(t_num%n);</span><br><span class="line">                t_num /= n;</span><br><span class="line">                </span><br><span class="line">            &#125;<span class="keyword">while</span>(t_num &gt; <span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">while</span>(!stack.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(p == idx)</span><br><span class="line">                &#123;</span><br><span class="line">                    String add_num = String.valueOf(stack.peek());</span><br><span class="line">                    <span class="keyword">if</span>(add_num.equals(<span class="string">&quot;10&quot;</span>))</span><br><span class="line">                        add_num = <span class="string">&quot;A&quot;</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(add_num.equals(<span class="string">&quot;11&quot;</span>))</span><br><span class="line">                        add_num = <span class="string">&quot;B&quot;</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(add_num.equals(<span class="string">&quot;12&quot;</span>))</span><br><span class="line">                        add_num = <span class="string">&quot;C&quot;</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(add_num.equals(<span class="string">&quot;13&quot;</span>))</span><br><span class="line">                        add_num = <span class="string">&quot;D&quot;</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(add_num.equals(<span class="string">&quot;14&quot;</span>))</span><br><span class="line">                        add_num = <span class="string">&quot;E&quot;</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(add_num.equals(<span class="string">&quot;15&quot;</span>))</span><br><span class="line">                        add_num = <span class="string">&quot;F&quot;</span>;</span><br><span class="line">                    </span><br><span class="line">                    answer += add_num;</span><br><span class="line">                    p += m;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="keyword">if</span>(cnt == t)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                idx++;</span><br><span class="line">                stack.pop();</span><br><span class="line">            &#125;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> cnt는 알려준 숫자이며 이것이 t가 될 때까지 숫자를 n진수로 바꿔볼 것이다. num은 0부터 시작한다. num은 1씩 계속 증가해야 하므로, 실제 연산을 할 땐 t_num에 복사한 값을 쓴다. 0도 진수로 바꾸어야 하기 때문에 do-while문을 사용하였다. n진수로 바꾼 숫자들은 스택에 쌓는다. idx는 현재 몇번째 숫자인지 알려주는 지표이다. 이 idx값이 p값과 일치한다면 그 값을 문자열에 추가하고 p에 m을 더해 다음 차례를 알려준다. idx는 pop을 할 때마다 1씩 증가하도록 한다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/nth_game.png" width="290" height="510">
</center>
<p><br></p>
<p>카카오톡 인턴 시험을 봤는데, 역시 정말 어려웠다. 공부한지 얼마 되지도 않았는데 벌써 기죽지말고 차근차근 해나가자. 발전하고 있다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>네트워크</title>
    <url>/2021/02/24/Network/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>네트워크의 개수가 몇 개인지 판별하는 문제이다. 기본적인 탐색문제이다.</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvNDMxNjI=">문제 링크<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Network</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level3 네트워크</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] computers = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            &#123;</span><br><span class="line">                answer++;</span><br><span class="line">                visited[i] = <span class="keyword">true</span>;</span><br><span class="line">                Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">                stack.push(i);</span><br><span class="line">                <span class="keyword">while</span>(!stack.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> t = stack.peek();</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(computers[t][j] == <span class="number">1</span> &amp;&amp; !visited[j])</span><br><span class="line">                        &#123;</span><br><span class="line">                            visited[j] = <span class="keyword">true</span>;</span><br><span class="line">                            stack.push(j);</span><br><span class="line">                        &#125; </span><br><span class="line">                            </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 전형적인 탐색문제라 어렵지 않다. 일단 각 컴퓨터를 한번이라도 체크했는지 확인하는 불리안 배열을 생성한다. 그리고 이 배열을 순회하며 만약 한 번도 체크하지 않은 컴퓨터라면 dfs를 실시 한다. 필자는 스택을 이용해서 dfs를 구현했다.</p>
<p>반복 횟수를 계산해보자면 <span class="math inline">\((m+n-2)(m+n-2)m*m\)</span>이 된다. 따라서 최고차항을 따로 떼어내면 최종 시간복잡도는 <span class="math inline">\(O(m^2n^2)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/network.png" width="290" height="500">
</center>
<p><br></p>
<p>예전만 해도 dfs가 왜 스택이고 bfs는 왜 큐인지 이해가 잘 안갔는데 어느 새, 혼자서 아무것도 참고하지 않고 dfs를 구현할 수 있게 되었다. 늦은 감이 없지 않아 있지만, 그래도 성장했음을 느낀다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level3</category>
      </categories>
  </entry>
  <entry>
    <title>다음 큰 숫자</title>
    <url>/2021/01/19/Next-Big-Num/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>어떠한 자연수 n이 주어질 때 다음으로 큰 숫자를 찾으면 된다. 다음으로 큰 숫자에 대한 조건은 3가지를 만족해야 한다. 1. n보다 커야 한다. 2. n과 해당 수를 이진수로 바꿨을 때, 1의 개수가 같아야 한다. 3. 1과 2를 동시에 만족하는 가장 작은 수여야 한다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NextBigNum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 다음 큰 숫자</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">78</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = n;</span><br><span class="line">        <span class="keyword">int</span> one = <span class="number">0</span>, t_one = <span class="number">0</span>;</span><br><span class="line">        String binary = Integer.toBinaryString(n);</span><br><span class="line">        <span class="keyword">char</span>[] arr = binary.toCharArray();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                one++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(one != t_one)</span><br><span class="line">        &#123;</span><br><span class="line">            answer++;</span><br><span class="line">            t_one = <span class="number">0</span>;</span><br><span class="line">            String temp = Integer.toBinaryString(answer);</span><br><span class="line">            <span class="keyword">char</span>[] t_arr = temp.toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c : t_arr)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">                    t_one++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 풀이는 간단하다 n에서 1씩 늘려가며 1의 개수를 비교하며 같아질 때 답을 출력하는 것이다.</p>
<p>여기서 시간복잡도를 계산하기가 굉장히 애매한데 1이 같아지는 경우가 언제인지 잘 모르겠기 때문이다. 이 부분에서는 더 공부가 필요하다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/next_big_num.png" width="290" height="530">
</center>
<p><br></p>
<p>java에 bitCount로 1을 세주는 함수가 있었다. 자바에는 무궁무진한 메소드의 세계가 있는 것 같다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>뉴스 클러스터링</title>
    <url>/2021/01/22/News-Clustering/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>두 문자열을 두글자씩 쪼개어(이 때 영문외의 다른 문자가 끼어있으면 버린다.) 자카드 유사도를 구하는 문제이다. 아래 링크에 원문을 붙였으니 참고 바란다.</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvMTc2Nzc=">문제 링크<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsClustering</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 Level2 뉴스 클러스터링</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="string">&quot;aa1+aa2&quot;</span>;</span><br><span class="line">        String str2 = <span class="string">&quot;AAAA12&quot;</span>;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">char</span>[] arr1 = str1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] arr2 = str2.toCharArray();</span><br><span class="line">        </span><br><span class="line">        HashMap&lt;String, Integer&gt; a = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, Integer&gt; b = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, Integer&gt; inter = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, Integer&gt; union = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length-<span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((arr1[i] &lt; <span class="string">&#x27;A&#x27;</span> || arr1[i] &gt; <span class="string">&#x27;Z&#x27;</span>) &amp;&amp; (arr1[i] &lt; <span class="string">&#x27;a&#x27;</span> || arr1[i] &gt; <span class="string">&#x27;z&#x27;</span>))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>((arr1[i+<span class="number">1</span>] &lt; <span class="string">&#x27;A&#x27;</span> || arr1[i+<span class="number">1</span>] &gt; <span class="string">&#x27;Z&#x27;</span>) &amp;&amp; (arr1[i+<span class="number">1</span>] &lt; <span class="string">&#x27;a&#x27;</span> || arr1[i+<span class="number">1</span>] &gt; <span class="string">&#x27;z&#x27;</span>))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            StringBuilder buff = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            buff.append(arr1[i]);</span><br><span class="line">            buff.append(arr1[i+<span class="number">1</span>]);</span><br><span class="line">            String key = buff.toString().toLowerCase();</span><br><span class="line">            a.put(key, a.getOrDefault(key, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr2.length-<span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((arr2[i] &lt; <span class="string">&#x27;A&#x27;</span> || arr2[i] &gt; <span class="string">&#x27;Z&#x27;</span>) &amp;&amp; (arr2[i] &lt; <span class="string">&#x27;a&#x27;</span> || arr2[i] &gt; <span class="string">&#x27;z&#x27;</span>))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>((arr2[i+<span class="number">1</span>] &lt; <span class="string">&#x27;A&#x27;</span> || arr2[i+<span class="number">1</span>] &gt; <span class="string">&#x27;Z&#x27;</span>) &amp;&amp; (arr2[i+<span class="number">1</span>] &lt; <span class="string">&#x27;a&#x27;</span> || arr2[i+<span class="number">1</span>] &gt; <span class="string">&#x27;z&#x27;</span>))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            StringBuilder buff = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            buff.append(arr2[i]);</span><br><span class="line">            buff.append(arr2[i+<span class="number">1</span>]);</span><br><span class="line">            String key = buff.toString().toLowerCase();</span><br><span class="line">            b.put(key, b.getOrDefault(key, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        Iterator&lt;String&gt; keys = a.keySet().iterator();</span><br><span class="line">        <span class="keyword">while</span>(keys.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            String key = keys.next();</span><br><span class="line">            <span class="keyword">int</span> b_value = b.getOrDefault(key, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(b_value != <span class="number">0</span>)</span><br><span class="line">                inter.put(key, Math.min(b_value, a.get(key)));</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            union.put(key, a.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        Iterator&lt;String&gt; b_keys = b.keySet().iterator();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(b_keys.hasNext())</span><br><span class="line">        &#123;</span><br><span class="line">            String key = b_keys.next();</span><br><span class="line">            union.put(key, Math.max(b.get(key), union.getOrDefault(key, <span class="number">0</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        Iterator&lt;String&gt; inter_keys = inter.keySet().iterator();</span><br><span class="line">        Iterator&lt;String&gt; union_keys = union.keySet().iterator();</span><br><span class="line">        <span class="keyword">double</span> inter_size = <span class="number">0</span>, union_size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(inter_keys.hasNext())</span><br><span class="line">            inter_size += inter.get(inter_keys.next());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(union_keys.hasNext())</span><br><span class="line">            union_size += union.get(union_keys.next());</span><br><span class="line"></span><br><span class="line">        union_size--;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">double</span> similarity = inter_size/union_size;</span><br><span class="line"></span><br><span class="line">        similarity *= <span class="number">65536</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = (<span class="keyword">int</span>)Math.floor(similarity);</span><br><span class="line">        <span class="keyword">if</span>(inter.size() == <span class="number">0</span>)</span><br><span class="line">            answer = <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 코드가 길지만 진정하고 차근차근 따라가보자 과정에 따라 나누면 코드는 다음과 같이 나눠진다. 1. 집합 A를 만든다. 2. 집합 B를 만든다. 3. 집합 A와 집합 B의 교집합을 구한다. 4. 집합 A와 집합 B의 합집합을 구한다. 5. 교집합과 합집합에 들어있는 원소의 개수로 답을 구한다.</p>
<p>과정을 나누니 어렵지 않다. 1,2번 코드는 같은 논리로 동작하므로 하나만 떼어서 보자.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length-<span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((arr1[i] &lt; <span class="string">&#x27;A&#x27;</span> || arr1[i] &gt; <span class="string">&#x27;Z&#x27;</span>) &amp;&amp; (arr1[i] &lt; <span class="string">&#x27;a&#x27;</span> || arr1[i] &gt; <span class="string">&#x27;z&#x27;</span>))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    <span class="keyword">if</span>((arr1[i+<span class="number">1</span>] &lt; <span class="string">&#x27;A&#x27;</span> || arr1[i+<span class="number">1</span>] &gt; <span class="string">&#x27;Z&#x27;</span>) &amp;&amp; (arr1[i+<span class="number">1</span>] &lt; <span class="string">&#x27;a&#x27;</span> || arr1[i+<span class="number">1</span>] &gt; <span class="string">&#x27;z&#x27;</span>))</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">    StringBuilder buff = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    buff.append(arr1[i]);</span><br><span class="line">    buff.append(arr1[i+<span class="number">1</span>]);</span><br><span class="line">    String key = buff.toString().toLowerCase();</span><br><span class="line">    a.put(key, a.getOrDefault(key, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>필자는 hashmap을 사용해서 문제를 풀었다. 일단 arr1에 문자열을 쪼개어 문자 배열로 만든 다음 두글자씩 보면서 영어가 아닌 것이 있으면 map에 추가되지 않도록 continue를 사용했다. 만약 두 문자다 영어라면 버퍼에 문자들을 넣어주고 전부 소문자로 바꾸어주었다. 이유는 대문자 소문자를 구별하지 않는다고 문제에 나와있기 때문이다. 이후 맵에 문자를 key값으로 하고 값은 만약 이미 값이 있다면 기존값에 +1을 없다면 1을 삽입하도록 한다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; keys = a.keySet().iterator();</span><br><span class="line"><span class="keyword">while</span>(keys.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">    String key = keys.next();</span><br><span class="line">    <span class="keyword">int</span> b_value = b.getOrDefault(key, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(b_value != <span class="number">0</span>)</span><br><span class="line">        inter.put(key, Math.min(b_value, a.get(key)));</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    union.put(key, a.get(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1,2번 과정이 끝났으니 이제 교집합을 구할 차례이다. 교집합은 두 집합 모두에게 존재해야 한다. 따라서 필자는 a의 key값을 b에 대입해 볼 것이다. 만약 b에 값이 존재한다면 a와 b에 있는 값 중 작은 값이 들어가도록 했다. 아래에 보면 union은 합집합인데 a를 일단 넣어두려고 반복문안에 넣었다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; b_keys = b.keySet().iterator();</span><br><span class="line">        </span><br><span class="line"><span class="keyword">while</span>(b_keys.hasNext())</span><br><span class="line">&#123;</span><br><span class="line">    String key = b_keys.next();</span><br><span class="line">    union.put(key, Math.max(b.get(key), union.getOrDefault(key, <span class="number">0</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이제 합집합을 구하는데 아까 위에서 a에 대한 값은 미리 넣어주었으므로 이제 b에 대해서 삽입하면 된다. 합집합에 공통원소가 있을 경우 더 큰 값을 쓰기 때문에 max를 이용하여 값을 넣는다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Iterator&lt;String&gt; inter_keys = inter.keySet().iterator();</span><br><span class="line">Iterator&lt;String&gt; union_keys = union.keySet().iterator();</span><br><span class="line"><span class="keyword">double</span> inter_size = <span class="number">0</span>, union_size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(inter_keys.hasNext())</span><br><span class="line">    inter_size += inter.get(inter_keys.next());</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(union_keys.hasNext())</span><br><span class="line">    union_size += union.get(union_keys.next());</span><br><span class="line"></span><br><span class="line">union_size--;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> similarity = inter_size/union_size;</span><br><span class="line"></span><br><span class="line">similarity *= <span class="number">65536</span>;</span><br><span class="line"><span class="keyword">int</span> answer = (<span class="keyword">int</span>)Math.floor(similarity);</span><br><span class="line"><span class="keyword">if</span>(inter.size() == <span class="number">0</span>)</span><br><span class="line">    answer = <span class="number">65536</span>;</span><br></pre></td></tr></table></figure>
<p>이제 자카드 유사도를 구할 차례이다. inter_size와 union_size를 선언하고 value들을 전부 합한 값을 담는다. 이때 union_size를 0으로 초기화하지 않은 이유는 0으로 나눴을 때 예외가 발생하기 때문에 컴파일을 애초에 해주지 않기 떄문이다. 그래서 1로 선언하고 나중에 다시 1을 감소시킨다. 나눈 두 값으로 자카드 유사도를 구했다.</p>
<p>최종 시간복잡도는 공비가 <span class="math inline">\(1\over2\)</span>인 등비수열의 합이므로, 2진법을 계산하는 과정이 있기 때문에 <span class="math inline">\(O(n*{1\over2}^n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/expect_tournament.png" width="290" height="540">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>멀쩡한 사각형</title>
    <url>/2021/01/05/Nice-Square/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>1x1cm가 단위인 모눈종이에 그린 사각형의 가로, 세로길이가 주어진다. 여기에 꼭짓점을 잇는 대각선을 그었을 때, 선이 그이지 않은 1x1크기의 사각형의 개수를 구하는 문제이다. 이 문제는 직선의 방정식을 이용하여 문제를 풀었다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FineRectangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 멀쩡한 사각형</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> w = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">12</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">double</span> a = h*(-<span class="number">1</span>)/(<span class="keyword">double</span>)w;</span><br><span class="line">        <span class="keyword">int</span> b = h;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; h; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> x = (i-b)/a;</span><br><span class="line">            answer += (<span class="keyword">long</span>)x;</span><br><span class="line">        &#125;</span><br><span class="line">        answer *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        System.out.print(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 코드의 길이는 짧은 편이다. 일단 필자는 사각형을 2차원 좌표로 나타냈을 때, (0,h) 와 (w,0)을 지나는 직선으로 생각했다. 그러면 기울기 a와 y절편 b를 구할 수 있다. 그리고 y좌표가 1부터 h-1까지(왜냐하면 y좌표가 h이면 어차피 멀쩡한 사각형이 없다.) 각각의 x좌표를 구한다. 그렇다면 그 x좌표가 해당 높이의 대각선이 존재하는 위치이다. 그렇다면 계산한 x가 만약 6.12xxxxx 라면 멀쩡한 사각형은 해당 위치에서 12(6*2)개가 있을 수 있다. 필자는 직각삼각형에 존재하는 사각형을 모두 구한 뒤 이를 2배 했다. 필자와 비슷한 생각을 했다면 아마 프로그래머스에서 테스트 케이스 6번을 틀렸을 수도 있는데, 이는 부동소수점 오차가 영향을 줬기 때문이다. 필자도 x값을 구하는 과정에서 (i/a) - (b/a)를 썼는데 틀렸었다. 그래서 나누기를 최소화하는 방향으로 둘을 합치니 통과가 되었다. 실수형 연산을 할 땐 조심 또 조심하자.</p>
<p>최종적인 시간복잡도는 <span class="math inline">\(O(h)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/fine_rectangle.png" width="350" height="500">
</center>
<p><br></p>
<p>최대공약수를 통해서 이 문제를 푼 사람도 있었다. 도대체 그런 규칙은 어떻게 알아내는 지 신기하다. 패턴이 존재하는 것 같은 느낌은 받았지만, 필자는 그 규칙까지 찾아내지 못했다. 덕분에 유클리드 호제법도 익힐 수 있었다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>같은 숫자는 싫어</title>
    <url>/2020/12/28/No-Same-Num/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>배열이 주어졌을 때, 중복을 제거한 배열을 반환하는 문제이다. 단, 배열의 순서는 유지되어야 한다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>디큐를 활용하여 문제를 풀자 디큐는 스택과 큐의 성질을 동시에 가지고 있는 자료구조이다. 그렇다면 이 문제는 스택과 큐의 성질을 둘다 이용하고 싶기 때문에 이용했다고 보면된다. 중복을 제거하는 방법은 조금만 생각해보면 쉽게 알 수 있다. 바로 그 전 숫자와 같은지 같지 않은지 확인하면 된다. 그러면 스택으로만 풀 수 있다고 반문하는 사람이 있겠지만 이 역시 아니다 스택을 활용할 경우 중복은 제거할 수 있지만, 순서를 유지할 수 없다. 스택은 LIFO이기 때문이다. 그래서 큐의 성질이 FIFO가 필요하고 이것이 디큐를 사용한 이유이다. 물론 스택을 굳이 사용하겠다면 방법은 있다. 스택을 통해 중복을 제거한뒤 배열에 거꾸로 담거나, 역전을 시켜주거나 방법은 많다. 여러 방법으로 이 문제를 풀어보고 시간복잡도도 함께 계산해보면 좋은 공부가 될 수 있을 것이다.</p>
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoSameNum</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        Deque&lt;Integer&gt; dq = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">        dq.add(arr[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(Integer.parseInt(dq.getLast().toString()) != arr[i])</span><br><span class="line">                dq.add(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[dq.size()];</span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(dq.size() != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">           answer[j++] = Integer.parseInt(dq.poll().toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 부분부분 살펴보자 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Deque&lt;Integer&gt; dq = <span class="keyword">new</span> ArrayDeque&lt;&gt;();</span><br><span class="line">dq.add(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(Integer.parseInt(dq.getLast().toString()) != arr[i])</span><br><span class="line">        dq.add(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 디큐를 선언하고 0번째 값을 디큐에 넣어놓는다. 디큐의 add는 끝부터 채워진다. 디큐의 가장 마지막 원소와 현재 들어갈 원소값을 비교하여 연달아 나타나지 않을 때 값을 집어넣는다. 이 부분에서 시간 복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[dq.size()];</span><br><span class="line"><span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(dq.size() != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    answer[j++] = Integer.parseInt(dq.poll().toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이제 디큐의 앞에서부터 값을 꺼내서 int형태로 바꾸어 answer에 저장하면 된다. 이부분 역시 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다. 이로써 총 시간복잡도는 <span class="math inline">\(O(n)\)</span>이 된다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/no_same_number.png" width="400" height="300">
</center>
<p><br></p>
<p>화면이 작아 약간 잘렸는데 아무튼 다 맞았다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>완주하지 못한 선수</title>
    <url>/2020/12/23/Not-Finished-Runner/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>두 배열이 주어진다. 한 배열은 참가자 명단(동명이인이 존재할 수도 있다.) 한 배열은 완주한 사람의 명단이 주어진다. 물론 순서는 뒤죽박죽인 것 같고 이 두 배열을 비교하여 완주하지 못한 한 명의 선수를 출력하면 된다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>문제 유형에는 해시라고 적혀있지만 해시가 익숙하지 않아 정렬을 이용하여 풀었다. 아래에 해시에 대한 얘기를 조금 써놓을 테니 이 풀이말고 해시를 이용해 풀고 싶은 분들은 참고하면 좋겠다.</p>
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NotCompletePlayer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String[] participant = &#123;<span class="string">&quot;leo&quot;</span>, <span class="string">&quot;kiki&quot;</span>, <span class="string">&quot;eden&quot;</span>&#125;;</span><br><span class="line">        String[] completion = &#123;<span class="string">&quot;eden&quot;</span>, <span class="string">&quot;kiki&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        String answer = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        PriorityQueue&lt;String&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        PriorityQueue&lt;String&gt; comp = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; participant.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            pq.add(participant[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; completion.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            comp.add(completion[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; completion.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            String name1 = pq.poll();</span><br><span class="line">            String name2 = comp.poll();</span><br><span class="line">            <span class="keyword">if</span>(!name1.equals(name2))</span><br><span class="line">            &#123;</span><br><span class="line">                answer = name1;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(answer.equals(<span class="string">&quot;&quot;</span>))</span><br><span class="line">            answer = pq.poll();</span><br><span class="line"></span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>부분부분 살펴보자</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PriorityQueue&lt;String&gt; pq = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br><span class="line">PriorityQueue&lt;String&gt; comp = <span class="keyword">new</span> PriorityQueue&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>자바에서 기본적으로 정렬함수를 제시하지만 필자는 우선순위 큐를 활용하였다. 이건 각자의 취향인듯하니 넘기자. 이렇게 선언하면 알파벳이 낮은 순서(오름차순)로 정렬된다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; participant.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    pq.add(participant[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; completion.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    comp.add(completion[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이제 참가자와 완주자명단을 우선순위 큐에 차례대로 집어넣는다. 우선순위큐에 넣는 것은 <span class="math inline">\(O(logn)\)</span>만큼 걸린다. 따라서 participant의 길이를 n이라고 하면 시간복잡도는 <span class="math inline">\(O(nlogn)\)</span>이다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; completion.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    String name1 = pq.poll();</span><br><span class="line">    String name2 = comp.poll();</span><br><span class="line">    <span class="keyword">if</span>(!name1.equals(name2))</span><br><span class="line">    &#123;</span><br><span class="line">        answer = name1;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(answer.equals(<span class="string">&quot;&quot;</span>))</span><br><span class="line">    answer = pq.poll();</span><br></pre></td></tr></table></figure>
<p>둘 다 정렬되어 있는 상태라면 완주하지 못한 선수가 끼어있는 부분부터 이름이 다를 것이다는 것을 이용하였다. 큐에서 이름을 하나하나 빼면서 처음으로 이름이 안맞는 부분이 있으면 정답에 참가자 이름을 넣고 반복문을 탈출하도록 한다. 하지만 이러한 케이스는 어떨까?</p>
<p>participation : [aaa, bbb, ccc]</p>
<p>completion : [aaa, bbb]</p>
<p>이 경우 반복을 마쳐도 answer에 아무것도 들어가지 않는다. completion의 길이만큼 반복이 진행됨을 눈여겨 보자. 이 경우를 고려하여 if문이 들어간다. 이렇게 되면 ccc도 완주하지 못한 선수로 골라낼 수 있다.</p>
<p>시간복잡도는 <span class="math inline">\(O(nlogn)\)</span>이며, 최종 시간복잡도 역시 같다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/not_complete_player.png" width="400" height="300">
</center>
<p><br></p>
<h2 id="해시">해시</h2>
<p>문제의 유형이 해시로 나타나 있는데 hashmap를 이용할 경우 <span class="math inline">\(O(n)\)</span>으로 문제를 풀 수 있다. hashmap에 선수의 이름을 key값으로 하고 value를 1로 하여 넣는다. 만약에 동명이인이 있는 선수라면 getOrDefault를 이용하여 2,3,4...이런식으로 value를 업데이트한다. 참가자 명단에 대해 위 과정을 수행하면 다음엔 완주자 명단에 있는 사람들의 이름을 key값으로 (value-1)값을 다시 hashmap에 넣는다. 이렇게 되면 value가 1인 사람은 한명이 남는다. 완주하지 못한 선수를 찾기 위해 hashmap의 keySet을 이용하여 value가 1인 선수를 answer에 담으면 된다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>오픈채팅방</title>
    <url>/2021/02/01/Open-Chat/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>오픈채팅방에 사람들이 들어왔다 나가는 관리자 창을 작성하는 프로그램을 만드는 문제이다. 닉네임간에 중복을 허용하며, 이름을 바꾸면 바꾼 시점부터가 아니라 모든 시점의 닉네임이 변경된다. 유저들은 uid로 구분한다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OpenChatting</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 오픈채팅방</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String[] record = &#123;</span><br><span class="line">            <span class="string">&quot;Enter uid1234 Muzi&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Enter uid4567 Prodo&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Leave uid1234&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Enter uid1234 Prodo&quot;</span>,</span><br><span class="line">            <span class="string">&quot;Change uid4567 Ryan&quot;</span>&#125;;</span><br><span class="line">        ArrayList&lt;String&gt; answer = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">     </span><br><span class="line">        <span class="keyword">for</span>(String s : record)</span><br><span class="line">        &#123;</span><br><span class="line">            String[] arr = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">if</span>(!arr[<span class="number">0</span>].equals(<span class="string">&quot;Leave&quot;</span>))</span><br><span class="line">                map.put(arr[<span class="number">1</span>], arr[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span>(String s : record)</span><br><span class="line">        &#123;</span><br><span class="line">            String[] arr = s.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            </span><br><span class="line">            StringBuilder buff = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="keyword">if</span>(!arr[<span class="number">0</span>].equals(<span class="string">&quot;Change&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                buff.append(map.get(arr[<span class="number">1</span>]));</span><br><span class="line">            </span><br><span class="line">                <span class="keyword">if</span>(arr[<span class="number">0</span>].equals(<span class="string">&quot;Enter&quot;</span>))</span><br><span class="line">                    buff.append(<span class="string">&quot;님이 들어왔습니다.&quot;</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(arr[<span class="number">0</span>].equals(<span class="string">&quot;Leave&quot;</span>))</span><br><span class="line">                    buff.append(<span class="string">&quot;님이 나갔습니다.&quot;</span>);</span><br><span class="line"></span><br><span class="line">                answer.add(buff.toString());</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 문제에서 원하는 것은 최종 단톡방의 관리창이기 때문에 중간에 몇 번을 바꾸었든 최종적으로 바꾼 닉네임만 가지고 있으면 된다. 필자는 map을 활용하여 문제를 풀고자 한다. map의 키는 uid이며, 값은 닉네임이다. 배열을 순회하며 Enter나 Change가 들어오면 맵에 값을 추가한다. 이미 있는 값이면 최근 값으로 업데이트한다.</p>
<p>이 과정을 끝내면 각 uid마다 최종 닉네임이 무엇인지 알 수 있다. 이제 이를 활용하여 문제에서 원하는 형식으로 답을 내면 된다. 들어오고 나간다는 문자에 따라 적절한 형식을 버퍼에 삽입하고 이를 어레이리스트에 삽입한다.</p>
<p>최종시간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/open_chatting.png" width="290" height="500">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>짝지어 제거하기</title>
    <url>/2021/01/21/Pair-Removing/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>연달아 등장하는 알파벳을 짝지어 삭제한다고 할 때, 모든 문자열을 삭제할 수 있는지 확인하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PairRemove</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 Level2 짝지어 제거하기</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;baabaa&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!stack.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(stack.peek() == c)</span><br><span class="line">                &#123;</span><br><span class="line">                    stack.pop();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                    </span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(stack.empty())</span><br><span class="line">            answer = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 처음에는 리스트에 넣고 remove를 통해 제거했는데 아무래도 시간이 오래 걸려서 효율성을 통과하지 못했다. 그래서 고민하던 도중 스택을 활용하면 되겠다는 생각이 들어 코드를 위와 같이 작성했다.</p>
<ol type="1">
<li>스택이 비어있다면 문자를 넣는다.</li>
<li>스택이 비어있지 않다면 top을 확인한다. 만약 스택의 탑과 들어올려는 값이 같으면 짝지어 지는 경우이므로 스택에서 제거하고 다음 원소에 대해 1,2번과정을 본다.</li>
<li>모든 과정을 마쳤을 때, 스택이 비어있다면 1을 반환한다.</li>
</ol>
<p>최종 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/pair_remove.png" width="290" height="540">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>전화번호 목록</title>
    <url>/2021/01/14/Phone-List/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>전화번호 목록이 주어질 때 어떤 번호가 다른 번호의 접두사인지 파악하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneBook</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 전화번호 목록</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] phone_book = &#123;<span class="string">&quot;119&quot;</span>, <span class="string">&quot;97674223&quot;</span>, <span class="string">&quot;1195524421&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">boolean</span> answer = <span class="keyword">true</span>;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;String&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;ArrayList&lt;String&gt;&gt;(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">            list.add(<span class="keyword">new</span> ArrayList&lt;String&gt;());</span><br><span class="line">        <span class="keyword">for</span>(String s : phone_book)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> idx = Integer.parseInt(s.substring(<span class="number">0</span>,<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.get(idx).size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                String comp = list.get(idx).get(i);</span><br><span class="line">                <span class="keyword">if</span>(s.indexOf(comp) == <span class="number">0</span> || comp.indexOf(s) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    answer = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            list.get(idx).add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 해쉬를 활용하라고 해서 많이 고민했다. 딱 맞는 Key값을 찾는다는게 결국 접두어를 찾는것이기 때문이다. 고민을 하다 2중 for문을 통해 brute force를 해봤는데 효율성에서 나아지지 않았다. 그래서 시간을 조금이라도 줄여보고자 adjacency list를 활용했다. 0~9로 시작하는 번호들을 각각 저장할 10개의 list를 생성하고 그 안에서 비교하도록 했다.</p>
<p>실은 이것도 모두 같은 숫자로 시작하면서 서로 접두사가 아닌 케이스인 경우 결국 <span class="math inline">\(O(n^2)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/phone_book.png" width="290" height="400">
</center>
<p><br></p>
<p>시간복잡도가 준 것은 아닌데 테스트를 통과해서 떨떠름하다. 다른 풀이를 보니 그냥 이중 포문을 사용해서 푼 경우도 있었다. 필자의 경우 indexOf를 했는데 그 분은 stratWith로 한 차이 밖에 없었다. 사용한 함수에 따라 달라질 수도 있다는건지,, 효율성을 평가하는 부분에서 약간 의아함이 들었다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>폰켓몬</title>
    <url>/2021/01/20/PhoneKetMon/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>폰켓몬의 갯수 중 절반을 가져갈 수 있을 때, 최대로 가져갈 수 있는 폰켓몬의 종류를 반환하는 문제이다. 같은 종류의 폰켓몬은 같은 자연수 값을 갖는다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ponketmon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 폰켓몬</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] nums = &#123;<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(n, map.getOrDefault(n, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(map.size() &lt; nums.length/<span class="number">2</span>)</span><br><span class="line">            answer = map.size();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            answer = nums.length/<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 필자는 맵을 활용하여 문제를 풀었다. 종류마다 폰켓몬이 몇 마리가 있는지 센 다음에, 종류가 폰켓몬의 종류의 절반보다 작으면 맵의 사이즈를 반환하고 아닌 경우, 전체 폰켓몬 수의 절반을 답으로 하였다.</p>
<p>최종 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/ponketmon.png" width="290" height="530">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
      </categories>
  </entry>
  <entry>
    <title>풍선 터트리기</title>
    <url>/2021/02/22/Pop-Ballon/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>나란히 있는 두 풍선을 임의로 선택하여 그 중에 큰 쪽을 터트린다. 단, 한번은 더 작은 숫자의 풍선을 터트릴 수 있다. 풍선이 1개가 남을 때 까지 터트릴 때, 최후에 남을 수 있는 풍선의 갯수를 반환하라.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BallonPop</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level3 풍선 터트리기</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = &#123;<span class="number">9</span>,<span class="number">1</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] left = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        <span class="keyword">int</span>[] right = <span class="keyword">new</span> <span class="keyword">int</span>[a.length];</span><br><span class="line">        </span><br><span class="line">        left[<span class="number">0</span>] = a[<span class="number">0</span>];</span><br><span class="line">        right[a.length-<span class="number">1</span>] = a[a.length-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; a.length; i++)</span><br><span class="line">            left[i] = left[i-<span class="number">1</span>] &gt; a[i] ? a[i] : left[i-<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = a.length-<span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">            right[i] = right[i+<span class="number">1</span>] &gt; a[i] ? a[i] : right[i+<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.length; i++)</span><br><span class="line">            answer = (left[i] &lt; a[i]) &amp;&amp; (right[i] &lt; a[i]) ? answer : answer+<span class="number">1</span>;</span><br><span class="line">        </span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 한 풍선을 선택하고 그 풍선이 최후로 남을 수 있는 경우의 수를 생각해보면 자신을 기준으로 좌우에서 풍선의 최소값을 각각 구한다. 만약 좌우의 풍선값보다 기준 풍선값의 값이 작다면, 이 풍선은 절대 터트릴 수 없다. 이를 코드로 구현한 것이 위와 같다.</p>
<p>시간 복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/ballonpop.png" width="290" height="380">
</center>
<p><br></p>
<p>요새 문제풀이를 통 못했는데 일단 난이도가 어려워져서 고민하는 시간이 많아 포스팅 하는 텀이 길어진다. 물론 이 풀이도 질문하기에서 본 접근방법을 참고한 거라 공부가 많이 필요하다고 느낀다. 패스트캠퍼스에서 주관하는 네카라쿠배 교육과정의 2차테스트를 치르고 있는 중인데, 혼자 공부하는 것보단 학원이 나을 것 같아서 최선을 다해 테스트에 임하려고 한다. 그래도 혼자 공부하는 시간을 줄이진 말아야지. 화이팅!</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level3</category>
      </categories>
  </entry>
  <entry>
    <title>문자열 내 p와 y의 개수</title>
    <url>/2020/12/28/P-Num-In-String/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>문자열 내에 p와 y의 개수를 세어 둘 다 동일하면 true를 그렇지 않다면 false를 반환한다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CntpCnty</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;pPoooyY&quot;</span>;</span><br><span class="line">        <span class="keyword">boolean</span> answer = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="number">0</span>, y = <span class="number">0</span>;</span><br><span class="line">        s = s.toLowerCase();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;p&#x27;</span>)</span><br><span class="line">                p++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(s.charAt(i) == <span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">                y++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(p!=y)</span><br><span class="line">            answer = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> toLowerCase를 이용해 문자열에 있는 모든 문자를 소문자로 바꾸었다. 그리고 하나씩 비교하여 p와 y의 개수를 센다. 만약 두 수가 같지 않다면 answer를 false로 바꾼다. 총 시간복잡도는 \(O(n)\)이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/pcnt_ycnt.png" width="400" height="300">
</center>
<p><br></p>
<p>p와 y의 변수를 따로 해서 계산하였는데, 다른 사람의 풀이를 보니 변수르 하나로 하여 증감을 이용해 푸는 것을 보았다. 변수 하나 차이긴 하지만 코드를 줄일 수 있는 방법 중에 하나로 기억해놔야겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>키패드 누르기</title>
    <url>/2020/12/29/Press-Keypad/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>키패드를 어느 쪽 손으로 눌러야 하는 가에 대한 문제이다. 초기 왼손의 위치는 *에 오른손의 위치는 #에 위치해있다. 1,4,7은 무조건 왼손으로 누르고 3,6,9는 오른손으로 누른다. 손가락은 상하좌우로만 움직일 수 있다. 2,5,8,0은 왼손과 오른손 중 더 가까이 있는 손가락으로 누르며, 만약 두 손가락이 움직이는 거리가 같은 경우 주로 쓰는 손으로 누른다. 눌러야할 번호들이 주어지면 어느쪽 손으로 누르는지 "L"과 "R"로 구성된 문자열로 나타내라.</p>
<p><br></p>
<center>
<img src="/images/programmers/keypad.png" width="450" height="500">
</center>
<p><br></p>
<h2 id="문제풀이">## 문제풀이</h2>
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyPad</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        String hand = <span class="string">&quot;right&quot;</span>;</span><br><span class="line"></span><br><span class="line">        StringBuilder buff = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">int</span> left_pos = <span class="number">10</span>, right_pos = <span class="number">11</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isleft = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] moves = &#123;</span><br><span class="line">            &#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;, <span class="comment">//0</span></span><br><span class="line">            &#123;<span class="number">4</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>&#125;, <span class="comment">//1</span></span><br><span class="line">            &#123;<span class="number">3</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>&#125;, <span class="comment">//2</span></span><br><span class="line">            &#123;<span class="number">4</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>&#125;, <span class="comment">//3</span></span><br><span class="line">            &#123;<span class="number">3</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>&#125;, <span class="comment">//4</span></span><br><span class="line">            &#123;<span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;, <span class="comment">//5</span></span><br><span class="line">            &#123;<span class="number">3</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>&#125;, <span class="comment">//6</span></span><br><span class="line">            &#123;<span class="number">2</span>, -<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;, <span class="comment">//7</span></span><br><span class="line">            &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;, <span class="comment">//8</span></span><br><span class="line">            &#123;<span class="number">2</span>, -<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;, <span class="comment">//9</span></span><br><span class="line">            &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">4</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>&#125;, <span class="comment">//10(*)</span></span><br><span class="line">            &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">4</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>&#125; <span class="comment">//11(#)</span></span><br><span class="line">        &#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num : numbers)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(num == <span class="number">1</span> || num == <span class="number">4</span> || num == <span class="number">7</span>)</span><br><span class="line">                isleft = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">3</span> || num == <span class="number">6</span> || num == <span class="number">9</span>)</span><br><span class="line">                isleft = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> left_dist = moves[left_pos][num];</span><br><span class="line">                <span class="keyword">int</span> right_dist = moves[right_pos][num];</span><br><span class="line">                <span class="keyword">if</span>(left_dist &lt; right_dist)</span><br><span class="line">                    isleft = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(right_dist &lt; left_dist)</span><br><span class="line">                    isleft = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(hand.equals(<span class="string">&quot;left&quot;</span>))</span><br><span class="line">                        isleft = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        isleft = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isleft)</span><br><span class="line">            &#123;</span><br><span class="line">                buff.append(<span class="string">&quot;L&quot;</span>);</span><br><span class="line">                left_pos = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                buff.append(<span class="string">&quot;R&quot;</span>);</span><br><span class="line">                right_pos = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        String answer = buff.toString();</span><br><span class="line">        System.out.print(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 부분부분 보도록 하자 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuilder buff = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"><span class="keyword">int</span> left_pos = <span class="number">10</span>, right_pos = <span class="number">11</span>;</span><br><span class="line"><span class="keyword">boolean</span> isleft = <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">int</span>[][] moves = &#123;</span><br><span class="line">    &#123;<span class="number">0</span>, -<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;, <span class="comment">//0</span></span><br><span class="line">    &#123;<span class="number">4</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>&#125;, <span class="comment">//1</span></span><br><span class="line">    &#123;<span class="number">3</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>&#125;, <span class="comment">//2</span></span><br><span class="line">    &#123;<span class="number">4</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>&#125;, <span class="comment">//3</span></span><br><span class="line">    &#123;<span class="number">3</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>&#125;, <span class="comment">//4</span></span><br><span class="line">    &#123;<span class="number">2</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;, <span class="comment">//5</span></span><br><span class="line">    &#123;<span class="number">3</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>&#125;, <span class="comment">//6</span></span><br><span class="line">    &#123;<span class="number">2</span>, -<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;, <span class="comment">//7</span></span><br><span class="line">    &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;, <span class="comment">//8</span></span><br><span class="line">    &#123;<span class="number">2</span>, -<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">1</span>, -<span class="number">1</span>&#125;, <span class="comment">//9</span></span><br><span class="line">    &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">4</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>&#125;, <span class="comment">//10(*)</span></span><br><span class="line">    &#123;<span class="number">1</span>, -<span class="number">1</span>, <span class="number">4</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">3</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="number">2</span>, -<span class="number">1</span>&#125; <span class="comment">//11(#)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 정답을 담을 StringBuilder buff를 선언한다. 초기 왼손은 *에 있고 오른손은 #에 있을때 이를 각각 10과 11로 지정한다. 그리고 moves를 작성한다. 번거로울 수 있지만, 마땅한 식이 떠오르지 않을 때 빠르게 문제를 풀 수 있다. 행이 시작점을 나타내고 열을 끝나는 점이라고 했을 때, 움직이는 횟수를 기록하였다. 예를들면 1에서 0으로 가기까지는 moves[1][0]에 해당하는 수이므로 4가 된 것을 볼 수 있다. 다음으로 boolean값에 해당하는 isleft를 선언한다. 이는 왼손으로 키패드를 눌러야하는지 나타내는 변수로 초기화는 아무렇게나 해도 상관없다. 필자는 false로 초기화하였다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> num : numbers)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(num == <span class="number">1</span> || num == <span class="number">4</span> || num == <span class="number">7</span>)</span><br><span class="line">        isleft = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(num == <span class="number">3</span> || num == <span class="number">6</span> || num == <span class="number">9</span>)</span><br><span class="line">        isleft = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> left_dist = moves[left_pos][num];</span><br><span class="line">        <span class="keyword">int</span> right_dist = moves[right_pos][num];</span><br><span class="line">        <span class="keyword">if</span>(left_dist &lt; right_dist)</span><br><span class="line">            isleft = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(right_dist &lt; left_dist)</span><br><span class="line">            isleft = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(hand.equals(<span class="string">&quot;left&quot;</span>))</span><br><span class="line">                isleft = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                isleft = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isleft)</span><br><span class="line">    &#123;</span><br><span class="line">        buff.append(<span class="string">&quot;L&quot;</span>);</span><br><span class="line">        left_pos = num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        buff.append(<span class="string">&quot;R&quot;</span>);</span><br><span class="line">        right_pos = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">String answer = buff.toString();</span><br></pre></td></tr></table></figure>
<p>논리적으로 어려운 부분은 없다. 1,4,7인경우에는 왼손으로 누르므로 isleft를 true값으로 변경한다. 3,6,9인 경우 false로 바꾼다. 만약 중간에 있는 키패드인 경우 moves 값을 비교하여 판별한다. 만약 값이 같은 경우 어느 손잡이인지 보면 된다. 키패드를 누를 때마다 현재 있어야 하는 위치값을 업데이트 하는 것을 잊지 말자. numbers의 길이를 n이라고 하면 이 알고리즘의 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/keypad_result.png" width="350" height="500">
</center>
<p><br></p>
<p>옛날에 멋모르고 인턴에 지원했다가 이 문제만 2-3시간 풀고 포기한 경험이 있다. 그래서 그 때의 안 좋은 감정이 차올랐는데, 이번에는 30분정도 걸렸다. 내가 성장하고 있는 걸 느껴서 기쁘다. 첨언을 하자면 키패드를 자세히 보면 3으로 나머지연산과 나누기 연산을 하면 키패드의 어느 위치에 있는지 쉽게 알 수 있다. 이걸 활용하면 코드를 더 간결하게 만들 수 있을거라 생각한다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>직사각형 별찍기</title>
    <url>/2020/12/30/Rectangle-Star/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>a를 가로길이로 b를 세로길이로 하는 직사각형을 만드는 문제이다. 직사각형을 별문자를 통해 나타낸다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MakeRectangle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제 풀이 level1 직사각형 별찍기</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">int</span> a = sc.nextInt();</span><br><span class="line">        <span class="keyword">int</span> b = sc.nextInt();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; b; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a; j++)</span><br><span class="line">                System.out.print(<span class="string">&quot;*&quot;</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 열(a)만큼 별을 찍어준 다음에는 줄바꾸기를 해야하므로 위와 같이 코드를 작성하였다. 시간복잡도는 <span class="math inline">\(O(a*b)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/star_rectangle.png" width="350" height="500">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>쿼드압축 후 개수 세기</title>
    <url>/2021/01/15/QuadCompress-Count-Num/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>정사각형의 0,1로 이루어진 2차원 배열을 압축하는 문제이다. 정사각형 영역 S가 한숫자로만 이루어져 있으면 그 숫자로 압축할 수 있다. 만약 그렇지 않으면 4개의 정사각형으로 나누어 압축할 수 있는지 확인한다. 이 과정을 반복했을 때 0의 개수와 1의 개수를 배열로 담아 반환하면 된다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuadCompress</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 쿼드압축 후 개수 세기</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] arr = &#123;</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>&#125;,</span><br><span class="line">            &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        answer[<span class="number">0</span>] = ReturnCnt(<span class="number">0</span>, arr.length-<span class="number">1</span>, <span class="number">0</span>, arr.length-<span class="number">1</span>, arr, <span class="number">0</span>);</span><br><span class="line">        answer[<span class="number">1</span>] = ReturnCnt(<span class="number">0</span>, arr.length-<span class="number">1</span>, <span class="number">0</span>, arr.length-<span class="number">1</span>, arr, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ReturnCnt</span><span class="params">(<span class="keyword">int</span> start_r, <span class="keyword">int</span> end_r, <span class="keyword">int</span> start_c, <span class="keyword">int</span> end_c, <span class="keyword">int</span>[][] arr, <span class="keyword">int</span> comp_num)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(start_r == end_r)</span><br><span class="line">            <span class="keyword">return</span> arr[start_r][start_c] == comp_num ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">boolean</span> canCompress = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> r = start_r; r &lt;= end_r; r++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> c = start_c; c &lt;= end_c; c++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(arr[r][c] != comp_num)</span><br><span class="line">                        canCompress = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(canCompress)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> middle_r = (end_r-start_r)/<span class="number">2</span> + start_r;</span><br><span class="line">            <span class="keyword">int</span> middle_c = (end_c-start_c)/<span class="number">2</span> + start_c;</span><br><span class="line">            <span class="keyword">int</span> first = <span class="number">0</span>, sec = <span class="number">0</span>, third = <span class="number">0</span>, fourth = <span class="number">0</span>;</span><br><span class="line">            first += ReturnCnt(start_r, middle_r, start_c, middle_c, arr, comp_num);</span><br><span class="line">            sec += ReturnCnt(start_r, middle_r, middle_c+<span class="number">1</span>, end_c, arr, comp_num);</span><br><span class="line">            third += ReturnCnt(middle_r+<span class="number">1</span>, end_r, start_c, middle_c, arr, comp_num);</span><br><span class="line">            fourth += ReturnCnt(middle_r+<span class="number">1</span>, end_r, middle_c+<span class="number">1</span>, end_c, arr, comp_num);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> first+sec+third+fourth;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;    </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 전형적인 리컬시브를 활요하는 문제이다. 필자는 0이나 1이 몇개인지 알려주는 함수 ReturnCnt를 만든 뒤, 0의 개수와 1의 개수를 각각 구하였다. 함수의 매개변수로는 사각형의 시작행과 열, 끝행과 열을 알기 위해 start_r, end_r, start_c, end_c로 선언했다. comp_num은 0 또는 1이 들어간다. 압축하는 숫자가 무엇인지 알려주는 역할이다. 리컬시브 함수가 종료되는 순간은 가로 세로가 1인 정사각형이 들어왔을 때이다. 첫행과 끝행이 같을 때가 이 경우 이므로, 이때 비교하는 수가 comp_num과 같으면 1을 그렇지 않으면 0을 반환한다. 다른 종료조건으로는 영역 전체가 comp_num으로 이루어진 경우이다. 이 조건은 2중 루프를 통해 파악한다. 이 모두가 아니라면 영역을 4개로 쪼개어 확인해야한다. 영역을 쪼개기 위해 정사각형을 쪼개는 가운데 점을 찾아야하는데 그건 35-36번째 줄을 참고하길 바란다. 이렇게 만들어진 중간열과 행을 middle_r과 middle_c로 선언한다. 다음에 자른 영역으로 함수를 재호출하여 4개의 영역값을 모두 더하여 반환한다.</p>
<p>시간복잡도에 대해 고민을 해보았는데, 최악의 경우는 단 하나도 압축이 안되는 경우이다. 일단 함수가 쪼개지는 횟수는 정사각형의 한 변의 길이를 <span class="math inline">\(n(n \ge 2)\)</span>일 때, 등비수열의 합 공식에 의해 <span class="math inline">\(4*(4^n-1)\over(4-1)\)</span>번이다. 쪼개진 영역들을 검사하는 횟수를 다 합하면 한번에 <span class="math inline">\(n^2\)</span>이다. 따라서 총 시간복잡도는 <span class="math inline">\(O(n^2*4^n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/quad_compress.png" width="290" height="410">
</center>
<p><br></p>
<p>이번 문제는 시간복잡도를 계산하는 것이 까다로웠다. 이제 재귀에 익숙해져 가는 것 같아 뿌듯하다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>프린터</title>
    <url>/2021/01/07/Printer/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>각 인쇄할 용지의 우선순위가 주어진다. 용지는 앞에서부터 인쇄하되, 만약 인쇄대기목록에 우선순위가 높은 것이 있다면 맨 뒤로 보내진다. 내가 인쇄를 처음에 요청한 문서의 인덱스가 주어질 때 언제 그 문서가 인쇄될 지 계산하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Printer</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 프린터</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] priorities = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> location = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        ArrayList&lt;Integer&gt; papers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> order = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isFirst;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; priorities.length; i++)</span><br><span class="line">            papers.add(i);</span><br><span class="line">        <span class="keyword">while</span>(papers.size() != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            isFirst = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">int</span> idx = papers.get(<span class="number">0</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; papers.size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(priorities[papers.get(i)] &gt; priorities[idx])</span><br><span class="line">                &#123;</span><br><span class="line">                    papers.remove(<span class="number">0</span>);</span><br><span class="line">                    papers.add(idx);</span><br><span class="line">                    isFirst = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isFirst)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(idx == location)</span><br><span class="line">                &#123;</span><br><span class="line">                    answer = order;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    papers.remove(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                order++;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 필자는 어레이리스트로 문제를 풀었다. 시간을 줄이고 싶었지만, 잘 모르겠어서 문제가 시키는 그대로 했다. papers에 각 문서의 위치를 담고, 맨 앞부터 차례대로 보는 것이다. 22-31번째 줄을 보면, 우선순위를 탐색하는 코드가 있다. 만약 현재 맨 앞에 있는 것보다 우선순위가 큰 문서가 있으면, 현재 문서를 맨 뒤로 보내고, 대기문서의 첫번째에 있지 않기 때문에 isFisrt를 false로 한다. 만약에 인쇄될 문서보다 우선순위가 높은 것이 없으면 isFirst는 true가 될 것이다. 이때 이 문서가 내가 인쇄요청한 문서라면, 답을 반환하고 그렇지 않다면 order를 증가하고 해당 문서를 제거(출력)한다.</p>
<p>이 문제의 시간복잡도는 내가 인쇄 요청한 문서가 오름차순 우선순위의 가장 마지막 문서일 경우이다. 이 경우 문서의 개수를 n이라 하면, <span class="math inline">\(O(n^2)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/printer.png" width="350" height="450">
</center>
<p><br> 다른 사람의 풀이를 보니 answer를 앞에서부터 볼 인덱스로 하고 l을 내가 요청한 문서가 현재 위치한 곳을 나타내는 것으로 하여 일일이 priority를 다 비교하지 않아도 문제를 풀었다. 정말 대단하다고 생각한다. 나도 멋진 아이디어가 생각날 때까지 갈고 닦아야겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>제일 작은 수 제거하기</title>
    <url>/2020/12/29/Remove-Min/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>배열에서 제일 작은 수를 제거하여 출력한다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RemoveMin</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level1 제일 작은 수 제거하기</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        ArrayList&lt;Integer&gt; sorted_list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> n : arr)</span><br><span class="line">            sorted_list.add(n);</span><br><span class="line">        ArrayList&lt;Integer&gt; unsorted_list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">        unsorted_list = (ArrayList&lt;Integer&gt;)sorted_list.clone();</span><br><span class="line">        Collections.sort(sorted_list);</span><br><span class="line">        </span><br><span class="line">        Integer min = sorted_list.get(<span class="number">0</span>);</span><br><span class="line">        unsorted_list.remove(min);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[unsorted_list.size() == <span class="number">0</span> ? <span class="number">1</span> : unsorted_list.size()];</span><br><span class="line">        <span class="keyword">if</span>(answer.length == <span class="number">1</span>)</span><br><span class="line">            answer[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; unsorted_list.size(); i++)</span><br><span class="line">                answer[i] = Integer.parseInt(unsorted_list.get(i).toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 부분부분 살펴보자 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] arr = &#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">    ArrayList&lt;Integer&gt; sorted_list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> n : arr)</span><br><span class="line">        sorted_list.add(n);</span><br><span class="line">    ArrayList&lt;Integer&gt; unsorted_list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">    unsorted_list = (ArrayList&lt;Integer&gt;)sorted_list.clone();</span><br><span class="line">    Collections.sort(sorted_list);</span><br></pre></td></tr></table></figure> 어레이리스트를 두개 선언하였다. 하나는 정렬을 하고 하나는 정렬하지 않은 것이다. 배열 내에서 제일 작은 수를 알기 위해 정렬을 하는 것인데, 결과 배열은 순서가 흐트러지면 안되므로 두개의 배열을 선언한것이다. 여기서의 시간복잡도는 <span class="math inline">\(O(nlogn)\)</span>이다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer min = sorted_list.get(<span class="number">0</span>);</span><br><span class="line">unsorted_list.remove(min);</span><br></pre></td></tr></table></figure> 정렬한 배열의 첫번째 값을 가져와서 정렬하지 않은 배열에서 그 값을 제거한다. 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[unsorted_list.size() == <span class="number">0</span> ? <span class="number">1</span> : unsorted_list.size()];</span><br><span class="line"><span class="keyword">if</span>(answer.length == <span class="number">1</span>)</span><br><span class="line">    answer[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; unsorted_list.size(); i++)</span><br><span class="line">        answer[i] = Integer.parseInt(unsorted_list.get(i).toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 제거한 값을 배열로 만들기 위해 위 코드와 같이 처리한다. 값을 제거한 배열이 빈 배열일 경우 -1을 집어넣어야 하므로 사이즈를 1로 지정하고 그게 아니라면 결과 사이즈로 int배열을 선언한다. 정답 배열의 크기가 1일 경우 -1을 넣고 그게 아니라면 배열을 그대로 담는다. 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다. 따라서 전체 시간복잡도는 <span class="math inline">\(O(nlogn)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/remove_min.png" width="400" height="300">
</center>
<p><br></p>
<p>테스트케이스는 전부 통과하였지만 만약 테스트케이스가 [1,1,3]인 경우 내 알고리즘은 틀리게 된다. 그래도 통과가 된걸보니 그러한 케이스는 없었던 것 같다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>이진 변환 반복하기</title>
    <url>/2021/01/20/Repeat-Binary-Transform/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>문자열 x에 대한 이진변환을 1이 될 때까지 시행한다. 이진 변환은 아래와 같이 정의한다. 1. x의 모든 0을 제거한다. 2. x의 길이를 c라 하면, x를 c를 2진법으로 표현한 문자열로 바꾼다.</p>
<p>시행 뒤에 시행 횟수와 제거된 0의 개수를 반환하면 된다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RepeatBinary</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 이진 변환 반복하기</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;110010101001&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>, l, zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!s.equals(<span class="string">&quot;1&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            l = s.length();</span><br><span class="line">            s = s.replace(<span class="string">&quot;0&quot;</span>, <span class="string">&quot;&quot;</span>);</span><br><span class="line">            zero += l - s.length();</span><br><span class="line">            s = Integer.toBinaryString(s.length());</span><br><span class="line">        &#125;</span><br><span class="line">        answer[<span class="number">0</span>] = cnt;</span><br><span class="line">        answer[<span class="number">1</span>] = zero;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> cnt는 반복횟수이고, zero는 제거된 0의 개수이다. 문자열이 1이 될 때까지 cnt를 1씩 늘려가며 2진변환을 반복한다. 0의 개수를 세기 위해 문자열에서 0을 제거하고, 그전 문자열의 길이에서 1번과정을 거친 문자열의 길이를 제거한 값을 더한다. 그리고 2번과정을 시행한다.</p>
<p>시간복잡도를 정하기엔 애매한 부분이 있다. 0이 몇개나 생길지 모르기 때문에 절대적으로 얼마나 n이 커질지 단정짓기가 힘들다. 더 공부가 필요하다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/binary_repeat.png" width="290" height="310">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>비밀지도</title>
    <url>/2020/12/30/Secret-Map/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>암호를 해독하는 문제이다. 10진수 배열 2개를 받아 2진수로 변환한다. 같은 인덱스에 해당하는 원소끼리 bit연산(or)을 한다. 연산 결과로 나온 2진수에서 1은 #으로 0은 공백으로 처리하여 문자열 배열에 저장한다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecretMap</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level1 비밀지도</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span>[] arr1 = &#123;<span class="number">9</span>, <span class="number">20</span>, <span class="number">28</span>, <span class="number">18</span>, <span class="number">11</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] arr2 = &#123;<span class="number">30</span>, <span class="number">1</span>, <span class="number">21</span>, <span class="number">17</span>, <span class="number">28</span>&#125;;</span><br><span class="line"></span><br><span class="line">        String[] answer = <span class="keyword">new</span> String[n];</span><br><span class="line">        String[] map1 = <span class="keyword">new</span> String[n];</span><br><span class="line">        String[] map2 = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            map1[i] = Integer.toBinaryString(arr1[i]);</span><br><span class="line">            map2[i] = Integer.toBinaryString(arr2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">char</span>[] code1_char = map1[i].toCharArray();</span><br><span class="line">            <span class="keyword">char</span>[] code2_char = map2[i].toCharArray();</span><br><span class="line">            <span class="keyword">int</span>[] code1 = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">int</span>[] code2 = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">            <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n-code1_char.length; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                code1[j] = Integer.parseInt(String.valueOf(code1_char[k]));</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            k = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n-code2_char.length; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                code2[j] = Integer.parseInt(String.valueOf(code2_char[k]));</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            StringBuffer buff = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(code1[j] == <span class="number">1</span> || code2[j] == <span class="number">1</span>)</span><br><span class="line">                    buff.append(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    buff.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            answer[i] = buff.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 부분부분 살펴보자 <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    map1[i] = Integer.toBinaryString(arr1[i]);</span><br><span class="line">    map2[i] = Integer.toBinaryString(arr2[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 처음에 10진수를 2진수로 바꿔주는 작업을 한다. 자바에는 2진수로 바꿔주는 메소드가 있으니 이를 활용한다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>[] code1_char = map1[i].toCharArray();</span><br><span class="line"><span class="keyword">char</span>[] code2_char = map2[i].toCharArray();</span><br><span class="line"><span class="keyword">int</span>[] code1 = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span>[] code2 = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = n-code1_char.length; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">    code1[j] = Integer.parseInt(String.valueOf(code1_char[k]));</span><br><span class="line">    k++;</span><br><span class="line">&#125;</span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = n-code2_char.length; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">    code2[j] = Integer.parseInt(String.valueOf(code2_char[k]));</span><br><span class="line">    k++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>살짝 복잡할 수 있는데 천천히 읽어보면 이해할 수 있다. 일단 map1에 들어있는 스트링은 한뭉텅이니 char 배열로 쪼개준다. 배열로 쪼개고 나서 이 2진수의 길이가 n이라고 단정할 수 없기 때문에, for문의 범위가 위와 같다. 만약 n=5인데 만들어진 2진수는 010이면 이는 code의 2부터 집어넣어야한다. code1에는 n-code_char.length부터 넣지만 char 배열에선 0부터 값을 꺼내오는 것이므로 k라는 인덱스르 따로 선언해준다. map2에 대해서도 똑같이 해준다. 이 때 손쉬운 비교를 위해 char를 int형식으로 고쳤다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">StringBuffer buff = <span class="keyword">new</span> StringBuffer();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(code1[j] == <span class="number">1</span> || code2[j] == <span class="number">1</span>)</span><br><span class="line">        buff.append(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        buff.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line">answer[i] = buff.toString();</span><br></pre></td></tr></table></figure>
<p>이제 만들어진 n길이의 2진수로 비교해가며 # 또는 공백을 넣어주면 된다. StringBuffer를 선언하여 append를 해준 뒤, 문자열로 형변환을 한다.</p>
<p>시간복잡도는 2중 for문을 돌기 때문에 \(O(n^2)\)이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/secret_map.png" width="350" height="500">
</center>
<p><br></p>
<p>다른 사람은 단 3줄안에 이 문제를 푼 것을 보고 약간 자괴감이 들었다. 하지만 성장해 나가고 있는 필자의 모습에 위안을 얻기로 했다. 화이팅!!</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>가사 검색</title>
    <url>/2021/04/09/Song-Search/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>가사에 사용된 모든 단어들이 담긴 배열 <code>words</code>에서 <code>queries</code>에 해당되는 단어가 몇 개가 있는지 반환하는 문제이다. <code>queries</code>에는 와일드 카드 <code>?</code>가 하나 이상 존재하며, 이 와일드 카드는 문자의 앞부분을 차지하거나 뒷부분만을 차지한다(<code>fr?do</code>와 같은 형식이 없다.).</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvNjAwNjA=">문제 링크<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>trie 자료구조를 이용하여 문제를 풀 수 있다. 이번에는 다른 분의 핵심 아이디어를 듣고 코드로 구현하였다. 코드는 아래와 같다.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">words, queries</span>):</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value=<span class="literal">None</span></span>):</span></span><br><span class="line">            self.value = value</span><br><span class="line">            self.child = <span class="built_in">dict</span>()</span><br><span class="line">            self.len_dict = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Trie</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">            self.root = Node()</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">add</span>(<span class="params">self, value:<span class="built_in">str</span></span>):</span></span><br><span class="line">            node = self.root</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> value:</span><br><span class="line">                <span class="comment"># add dictionary for wildcard</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">len</span>(value) <span class="keyword">not</span> <span class="keyword">in</span> node.len_dict:</span><br><span class="line">                    node.len_dict[<span class="built_in">len</span>(value)] = <span class="number">0</span></span><br><span class="line">                node.len_dict[<span class="built_in">len</span>(value)] += <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">not</span> <span class="keyword">in</span> node.child: <span class="comment"># There is no child</span></span><br><span class="line">                    new_node = Node(c)</span><br><span class="line">                    node.child[c] = new_node</span><br><span class="line">                    node = new_node</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    node = node.child[c]</span><br><span class="line">            node.child[<span class="string">&#x27;*&#x27;</span>] = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">search</span>(<span class="params">self, queri</span>):</span></span><br><span class="line">            node = self.root</span><br><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> queri:</span><br><span class="line">                <span class="keyword">if</span> c == <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">                    <span class="keyword">return</span> node.len_dict[<span class="built_in">len</span>(queri)] <span class="keyword">if</span> <span class="built_in">len</span>(queri) <span class="keyword">in</span> node.len_dict <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">                <span class="keyword">if</span> c <span class="keyword">in</span> node.child:</span><br><span class="line">                    node = node.child[c]</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># def print(self):</span></span><br><span class="line">        <span class="comment">#     node = self.root</span></span><br><span class="line">        <span class="comment">#     queue = []</span></span><br><span class="line">        <span class="comment">#     queue.append(node)</span></span><br><span class="line">        <span class="comment">#     while queue:</span></span><br><span class="line">        <span class="comment">#         root = queue[0]</span></span><br><span class="line">        <span class="comment">#         del queue[0]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#         if root.value is not None:</span></span><br><span class="line">        <span class="comment">#             print(root.value, end = &quot; &quot;)</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#         if  &#x27;*&#x27; in root.child:</span></span><br><span class="line">        <span class="comment">#             print(&#x27;*&#x27;)</span></span><br><span class="line">        <span class="comment">#             continue</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">#         for node in root.child.values():</span></span><br><span class="line">        <span class="comment">#             queue.append(node)</span></span><br><span class="line">    </span><br><span class="line">    reversed_words = [word[::-<span class="number">1</span>] <span class="keyword">for</span> word <span class="keyword">in</span> words]</span><br><span class="line"></span><br><span class="line">    trie = Trie()</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">        trie.add(word)</span><br><span class="line"></span><br><span class="line">    reversed_trie = Trie()</span><br><span class="line">    <span class="keyword">for</span> word <span class="keyword">in</span> reversed_words:</span><br><span class="line">        reversed_trie.add(word)</span><br><span class="line"></span><br><span class="line">    answer = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> queri <span class="keyword">in</span> queries:</span><br><span class="line">        <span class="keyword">if</span> queri[<span class="number">0</span>] == <span class="string">&#x27;?&#x27;</span>:</span><br><span class="line">            answer.append(reversed_trie.search(queri[::-<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            answer.append(trie.search(queri))</span><br><span class="line">    <span class="keyword">return</span> answer</span><br></pre></td></tr></table></figure>
<p>일단 Trie에 대해서 알아야 하는데 이에 대한 <span class="exturl" data-url="aHR0cHM6Ly9ob29vbmdzLnRpc3RvcnkuY29tLzI4">링크<i class="fa fa-external-link-alt"></i></span>를 첨부해 두었으니 참고하면 좋을 것 같다. 이에 대해 안다고 가정하고 설명을 진행한다.</p>
<p>이 문제에서 제한 시간내에 문제를 풀기 위한 핵심 요소는 와일드 카드의 사용이다. 문자 사이에 와일드 카드가 올 일은 없기 때문에 만약 접미사가 와일드 카드이면 더 이상 Trie를 탐색하지 않도록 해야 문제가 풀린다.</p>
<p>이를 풀기 위해 <code>len_dict</code>를 생성하였다. <code>len_dict</code>는 해당 노드에서 뻗어나가는 단어들을 길이에 따라 몇 개의 단어가 있는지 알려주는 딕셔너리이다. 문제 테스트 케이스에 대해 len_dict를 그려보자면 다음과 같다.</p>
<figure>
<img src="/images/programmers/trie.jpeg" alt="Trie와 len_dict" /><figcaption aria-hidden="true">Trie와 len_dict</figcaption>
</figure>
<p>그림을 보면 root에 5글자를 가진 단어 5개 6글자를 가진 단어 1개를 표시해두고 아래로 뻗어 나가면서 각자의 위치에 자신의 하위 위치에 있는 단어들의 개수를 길이에 따라 저장해둔 것을 볼 수 있다. 이런식으로 했을때 만약 <code>fro??</code>와 같은 쿼리가 들어오면 o까지만 순회를 하고 5를 key값으로 하는 value 3을 리턴해주면 된다.</p>
<p>이렇게 하면 해결하지 못하는 케이스가 여전히 있는데 바로 와일드 카드가 앞쪽에 붙는 경우다. 이렇게 하면 모든 단어를 순회해봐야 알 수 있게 되기 때문에 역시나 효율성에서 애를 먹는다. 이를 해결하는 방법은 간단한다. 단어를 거꾸로 하여 새로운 Trie를 만들고 쿼리도 역으로 하여 <code>search</code>를 진행하면 된다.</p>
<p>시간복잡도를 계산하자면, words의 길이를 n, 개수를 m이라 하면 trie를 생성하는데에 <span class="math inline">\(O(nm)\)</span>이 든다. 이를 만들고 쿼리를 진행하므로 <code>queries</code>의 길이를 q라하고 개수를 p라하면, <span class="math inline">\(O(pq)\)</span>만큼 소요된다. 따라서 최종 시간복잡도는 <span class="math inline">\(O(nm) + O(pq)\)</span>이다.</p>
<p>너무 시간복잡도가 어마어마하게 느껴질 수도 있지만, 와일드카드와 단어간의 중첩이 있어 실질적인 시간은 좀 더 짧다고 생각한다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<figure>
<img src="/images/programmers/song_search.png" alt="테스트 화면" /><figcaption aria-hidden="true">테스트 화면</figcaption>
</figure>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level4</category>
      </categories>
  </entry>
  <entry>
    <title>스킬트리</title>
    <url>/2021/01/04/SkillTree/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>스킬트리의 순서를 만족하는 문자열이 몇개가 되는지 반환하는 문제이다. 롤에서 먼저가야할 템트리를 생각하면 쉬울 것 같다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SkillTree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 스킬트리</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String skill = <span class="string">&quot;CBD&quot;</span>;</span><br><span class="line">        String[] skill_trees = &#123;<span class="string">&quot;BACDE&quot;</span>, <span class="string">&quot;CBADF&quot;</span>, <span class="string">&quot;AECB&quot;</span>, <span class="string">&quot;BDA&quot;</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isAdd = <span class="keyword">true</span>;</span><br><span class="line">        HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">char</span>[] skill_arr = skill.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : skill_arr)</span><br><span class="line">        &#123;</span><br><span class="line">            map.put(c, v);</span><br><span class="line">            v++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(String s : skill_trees)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> pre_v = -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">char</span>[] skill_tree_arr = s.toCharArray();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c : skill_tree_arr)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> value = map.getOrDefault(c, -<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(value != -<span class="number">1</span> &amp;&amp; value - pre_v != <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    isAdd = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(value != -<span class="number">1</span>)</span><br><span class="line">                    pre_v = value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isAdd)</span><br><span class="line">                answer++;</span><br><span class="line">            isAdd = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 필자는 해시를 이용하여 문제를 풀었다. 자세한 사항은 부분부분 보면서 따라가자. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> isAdd = <span class="keyword">true</span>;</span><br><span class="line">HashMap&lt;Character, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">char</span>[] skill_arr = skill.toCharArray();</span><br><span class="line"><span class="keyword">int</span> v = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c : skill_arr)</span><br><span class="line">&#123;</span><br><span class="line">    map.put(c, v);</span><br><span class="line">    v++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> isAdd는 문자열이 조건을 만족하는지 여부를 저장하는 변수이다. 해쉬를 쓰기 위해 해시 맵을 선언했다. skill의 문자 하나하나를 hash에 매핑 시킨다. 예를 들어 "CBD"가 주어진다면, [C:0, B:1, D:2]와 같이 매핑된다. 이렇게 매핑해두면 각 키의 값을 비교하여 1씩 증가하는 지 확인하면 된다. 매핑하지 않은 키는 -1을 반환하도록 하여 이 연산에서 빠지도록 한다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(String s : skill_trees)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> pre_v = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span>[] skill_tree_arr = s.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : skill_tree_arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> value = map.getOrDefault(c, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span>(value != -<span class="number">1</span> &amp;&amp; value - pre_v != <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            isAdd = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(value != -<span class="number">1</span>)</span><br><span class="line">            pre_v = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(isAdd)</span><br><span class="line">        answer++;</span><br><span class="line">    isAdd = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure> 위에서 설명한 부분의 코드이다. pre_v의 초기값으로 -1을 넣어준 뒤, 주어진 스킬트리에서 문자를 하나씩 꺼내본다. 만약 맵에 있는데 초기값과 1차이가 나지 않는다면, 조건을 만족하지 않으므로 isAdd를 false하고 반복문을 탈출한다. 맵에 있는 값이면 pre_v를 업데이트 해주는 것을 잊지 않도록 하자. 다음엔 isAdd를 통해 정답을 세나간다. 최종적인 시간복잡도를 계산해보면 skill_trees의 길이를 n이라하고 skill_trees에 있는 문자열의 길이를 m이라하면, <span class="math inline">\(O(n*m)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/skill_tree.png" width="350" height="500">
</center>
<p><br></p>
<p>정규식을 통해 문제를 푼 사람도 있어서 신기했다. skill_trees의 각 원소에서 skill이 아닌 문자들을 지운뒤, indexOf를 활용하여 순서를 유지하는지 확인하였다. 이럴 경우 코드 수가 많이 줄어들어 가독성이 좋았다. 나도 정규식을 좀 더 공부해 봐야겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>파일명 정렬</title>
    <url>/2021/02/03/Sort-FileName/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>파일명 정렬 알고리즘을 짜는 문제이다 자세한 문제 설명은 아래 링크를 참고하도록 하자.</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvMTc2ODY=">문제 링크<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortFileName</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 level2 파일명 정렬</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] files = &#123;</span><br><span class="line">            <span class="string">&quot;img12.png&quot;</span>, <span class="string">&quot;img10.png&quot;</span>, <span class="string">&quot;img02.png&quot;</span>, <span class="string">&quot;img1.png&quot;</span>, <span class="string">&quot;IMG01.GIF&quot;</span>, <span class="string">&quot;img2.JPG&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        HashMap&lt;String, Integer&gt; order_map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap&lt;String, Integer&gt; head_map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; num_map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        </span><br><span class="line">        String[] head_arr = <span class="keyword">new</span> String[files.length];</span><br><span class="line">        <span class="keyword">int</span>[] num_arr = <span class="keyword">new</span> <span class="keyword">int</span>[files.length];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String file : files)</span><br><span class="line">        &#123;</span><br><span class="line">            order_map.put(file, i);</span><br><span class="line"></span><br><span class="line">            String[] arr = ReturnHeadNumber(file);</span><br><span class="line">            head_arr[i] = arr[<span class="number">0</span>].toLowerCase();</span><br><span class="line">            <span class="keyword">int</span> number = Integer.parseInt(arr[<span class="number">1</span>]);</span><br><span class="line">            num_arr[i++] = number;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(head_arr);</span><br><span class="line">        <span class="keyword">for</span>(String s : head_arr)</span><br><span class="line">            head_map.put(s, head_map.getOrDefault(s, head_map.size()));</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(num_arr);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> s: num_arr)</span><br><span class="line">            num_map.put(s, num_map.getOrDefault(s, num_map.size()));</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(files, <span class="keyword">new</span> Comparator&lt;String&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String o1, String o2)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                String[] o1_arr = ReturnHeadNumber(o1);</span><br><span class="line">                String[] o2_arr = ReturnHeadNumber(o2);</span><br><span class="line">                <span class="keyword">if</span>(head_map.get(o1_arr[<span class="number">0</span>]) &lt; head_map.get(o2_arr[<span class="number">0</span>]))</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(head_map.get(o1_arr[<span class="number">0</span>]) &gt; head_map.get(o2_arr[<span class="number">0</span>]))</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(num_map.get(Integer.parseInt(o1_arr[<span class="number">1</span>])) </span><br><span class="line">                       &lt; num_map.get(Integer.parseInt(o2_arr[<span class="number">1</span>])))</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(num_map.get(Integer.parseInt(o1_arr[<span class="number">1</span>])) </span><br><span class="line">                       &gt; num_map.get(Integer.parseInt(o2_arr[<span class="number">1</span>])))</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> order_map.get(o1) - order_map.get(o2);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line"></span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[] ReturnHeadNumber(String s)</span><br><span class="line">    &#123;</span><br><span class="line">        String[] res = <span class="keyword">new</span> String[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> head_idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> tail_idx = s.length();</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">boolean</span> isnum = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : s.toCharArray())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((c &gt;= <span class="string">&#x27;0&#x27;</span>) &amp;&amp; (c &lt;= <span class="string">&#x27;9&#x27;</span>) &amp;&amp; (!isnum))</span><br><span class="line">            &#123;</span><br><span class="line">                isnum = <span class="keyword">true</span>;</span><br><span class="line">                head_idx = idx;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(isnum)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((c &lt; <span class="string">&#x27;0&#x27;</span>) || (c &gt; <span class="string">&#x27;9&#x27;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    tail_idx = idx;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            idx++;</span><br><span class="line">        &#125;</span><br><span class="line">        String head = s.substring(<span class="number">0</span>, head_idx).toLowerCase();</span><br><span class="line">        String number = s.substring(head_idx, tail_idx);</span><br><span class="line">    </span><br><span class="line">        res[<span class="number">0</span>] = head;</span><br><span class="line">        res[<span class="number">1</span>] = number;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 코드가 긴데 핵심 아이디어는 간단하다. head별로 정리하여 사전을 만들어놓고 number별로 사전을 만들어놓고 들어온 순서대로 사전을 만들어 3개의 사전을 준비한다. 이제 두 대상을 비교할 때, head로 된 사전을 찾아보고 만약 두 값이 같으면 number사전을 찾아본다 number사전에서의 값도 같다면 순서를 기록해둔 사전을 참고하여 순서를 알아내면 된다. main은 이 세가지 사전을 만드는 과정이다.</p>
<p>22번째 줄에서 순서 사전을 만드는 것을 볼 수 있다 들어온 파일명대로 순서대로 i를 증가하며 저장한다. 이와 동시에 head사전과 number사전을 만들기 위한 준비를 한다. 정렬은 하지 않은 채 배열에 넣는다. 이때 head는 모두 소문자로 바꾸어 넣고 number는 모두 int로 변환하여 넣는다.</p>
<p>이제 head를 정렬한다. 정렬하고 이를 사전에 넣어야하는데, 만약 사전에 이미 있는 경우라면 값을 바꾸면 안되기 때문에 getOrDefault함수를 활용하였다. 사전에 없는 경우라면 사전의 크기를 값으로 지정한다. number또한 똑같은 원리로 한다. 이제 모든 사전이 완성되었다.</p>
<p>파일들을 정렬하기 위해 비교자를 새로 정의하였다. 비교자 선언은 어렵지 않다. 아까 말한 우선순위를 그대로 코드에 적었으니 찬찬히 보면 이해가 갈 것이다. ReturnHeadNumber에서 head와 number값을 받아올 수 있다.</p>
<p>ReturnHeadNumber를 보자. head_idx와 tail_idx가 있다. head_idx에는 head가 끝나는 인덱스를 너흘 것이고 tail_idx는 tail이 시작되는 지점을 넣을 것이다. isnum은 flag인데 코드를 살펴보면서 설명하겠다. 일단 문자열에서 문자를 하나씩 떼와서 처음으로 숫자가 나올 경우 이곳부터 number가 시작되므로 head_idx에 해당 인덱스 값을 넣고 isnum을 true로 해준다. isnum이 없다면 숫자가 여러자리 일 때도 head_idx가 계속 증가하기 때문이다.</p>
<p>isnum이 true로 바뀌면 이제 tail값을 찾아야한다. 처음으로 숫자가 아닌 구간이 나온다면 그곳부터는 tail이므로 tail_idx에 해당 idx를 넣고 반복문을 탈출한다. 이제 두 값으로 문자열을 잘라주면 우리가 원하는 head와 number를 가져올 수 있다.</p>
<p>최종 시간복잡도는 파일들의 개수를 n개라 할 때, <span class="math inline">\(O(nlogn)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/filename_sort.png" width="290" height="510">
</center>
<p><br></p>
<p>비교자를 새로하는 부분에서 테스트케이스가 많으면 간혹 논리가 맞아도 정렬이 꼬이는 경우가 있어서 불안했었는데, 무사히 통과해서 다행이다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>주식가격</title>
    <url>/2021/01/07/Stock-Price/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>자신의 주가가 언제 적자가 나는지 계산하는 문제이다. 예를 들면 문제에서 가격이 4일 때 주식을 사면 4초동안 주가가 떨어지지 않으므로 4이다. 필자는 처음에 문제를 잘못 이해하여 하나 빼고 다 틀렸다. 질문하기를 보니 다른 사람도 똑같이 그런 것 같았다. 지문의 개선이 필요해보인다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StockPrice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 주식가격</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] prices = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[prices.length];</span><br><span class="line">        <span class="keyword">int</span> n = prices.length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n-<span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(prices[i] &gt; prices[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    answer[i] = j-i;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(answer[i] == <span class="number">0</span>)</span><br><span class="line">                answer[i] = prices.length-(i+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 스택과 큐를 활용하라는 문제라고 나와있긴 하지만, 필자는 활용하진 않았다. 최대 길이가 만개이기 때문에 <span class="math inline">\(n^2\)</span>의 시간복잡도도 충분히 돌아갈거라 생각했기 때문이다. 코드는 간단하다. 각 주식 가격에서 처음으로 주가가 떨어지는 포인트를 발견하면, 그 두 값의 차를 기록하는 것이다. 만약 if문을 거치치 않았다면 끝까지 주가가 떨어지지 않는다는 것이므로 전체에서 인덱스+1을 빼준다.</p>
<p>이 문제의 시간복잡도는 <span class="math inline">\(O(n^2)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/stock_price.png" width="350" height="450">
</center>
<p><br></p>
<p>이걸 스택 큐로 분류해 놓은 이유를 잘 모르겠다. 스택/큐를 이용하면 더 빠른 시간안에 풀 수 있는것일까?</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>징검다리</title>
    <url>/2021/04/02/Stepping-Stone/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>징검다리에서 돌을 빼냈을 때 벌어지는 간격의 최솟값이 가장 큰 것을 구하는 것이다. 문제는 <span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvNDMyMzg=">여기<i class="fa fa-external-link-alt"></i></span>에서 볼 수 있다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>이진 탐색을 이용한 문제이다. 유형을 익히면 반가운 문제이지만, 처음에 보면 전혀 감이 안 잡힌다.</p>
<p>전체 코드는 다음과 같다. <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">distance, rocks, n</span>):</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isFeasable</span>(<span class="params">distance, rocks, n, k</span>):</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        pos = <span class="number">0</span></span><br><span class="line">        total = <span class="built_in">len</span>(rocks)</span><br><span class="line">        <span class="keyword">for</span> rock <span class="keyword">in</span> rocks:</span><br><span class="line">            <span class="keyword">if</span> rock - pos &gt;= k:</span><br><span class="line">                cnt += <span class="number">1</span></span><br><span class="line">                pos = rock</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> total-cnt &lt;= n:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    answer = <span class="number">0</span></span><br><span class="line">    l = <span class="number">0</span></span><br><span class="line">    r = distance</span><br><span class="line">    rocks.sort()</span><br><span class="line">    <span class="keyword">while</span> l &lt; r:</span><br><span class="line">        mid = (l+r) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span>(isFeasable(distance, rocks, n, mid)):</span><br><span class="line">            answer = mid</span><br><span class="line">            l = mid+<span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = mid</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">return</span> answer</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(solution(<span class="number">25</span>, [<span class="number">2</span>, <span class="number">14</span>, <span class="number">11</span>, <span class="number">21</span>, <span class="number">17</span>], <span class="number">2</span>))</span><br></pre></td></tr></table></figure> 전체적인 코드의 흐름은 다음과 같다. 1. 간격에 대해서 이분 탐색을 해볼 것이다. 이를 <code>k</code>라고 두자. 2. <code>k</code>의 가장 작은 경우는 0이고 가장 큰 경우는 <code>distance</code>이므로 <code>l</code>과 <code>r</code>로 둔다. 3. 이분 탐색을 하면서 만약 <code>isFeasable</code>을 만족한다면, 돌을 더 빼도 된다는 의미이다. 따라서 mid 값을 늘린다. 4. 아니라면 mid 값을 줄인다. 5. 아니면 answer를 반환한다.</p>
<p>여기서 왜 돌을 더 빼도 된다는 의미에 대해 알아보기 위해 <code>isFeasable</code>을 살펴보자</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isFeasable</span>(<span class="params">distance, rocks, n, k</span>):</span></span><br><span class="line">    cnt = <span class="number">0</span></span><br><span class="line">    pos = <span class="number">0</span></span><br><span class="line">    total = <span class="built_in">len</span>(rocks)</span><br><span class="line">    <span class="keyword">for</span> rock <span class="keyword">in</span> rocks:</span><br><span class="line">        <span class="keyword">if</span> rock - pos &gt;= k:</span><br><span class="line">            cnt += <span class="number">1</span></span><br><span class="line">            pos = rock</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> total-cnt &lt;= n:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>
<p>매개변수로 <code>distance</code>, <code>rocks</code>, <code>n</code>, <code>k</code>를 받는다. <code>cnt</code>는 돌의 개수를 의미하고 <code>pos</code>는 현재 선택한 돌의 위치를 본다. <code>total</code>은 총 돌의 개수를 의미한다.</p>
<p>for 문의 의미는 최솟값 <code>k</code>만큼의 간격에 포함되는 돌들을 세겠다는 의미이다. 프로그래머스에서 나온 예제를 보면 돌이 [2, 11, 14, 17, 21]의 순서로 놓여있다. 가령 <code>k</code>가 6이라면 [11, 17]에 위치한 돌이 선택되고 <code>cnt</code>는 2가 된다. <code>total</code>에서 <code>cnt</code>를 빼면 몇 개의 돌이 빠졌는지 볼 수 있고 이 값이 <code>n</code>보다 같거나 작으면 <code>True</code>를 반환한다.</p>
<p>이하에서 <code>True</code>를 반환하는 이유가 있다. 아래의 그림을 보자.</p>
<figure>
<img src="/images/programmers/stepping.jpeg" alt="k와 n의 관계" /><figcaption aria-hidden="true">k와 n의 관계</figcaption>
</figure>
<p><code>k</code>값이 증가하면 <code>n</code>값도 증가한다. 최솟값이 증가하니 돌 사이의 간격이 더 넓어져야 하기 때문이다. 여기서 우리는 <code>n</code>을 만족하는 최대를 구하려고 한다. 그러면 <code>l</code>이 증가해야 하는 경우를 살펴보아야 한다. 그림을 보면 <code>n</code>의 값이 요구하는 값보다 작을 때 <code>k</code>가 증가해야 함을 볼 수 있다. 이 이유로 인해 비교 연산자 <code>&lt;=</code>를 사용한 것이다.</p>
<h2 id="테스트">테스트</h2>
<figure>
<img src="/images/programmers/stepping_stone.png" alt="테스트 화면" /><figcaption aria-hidden="true">테스트 화면</figcaption>
</figure>
<p>자바로 하다가 파이썬으로 넘어오니까 코드가 훨씬 간결해서 놀랐다. 이제부터라도 열심히 애용하겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level4</category>
      </categories>
  </entry>
  <entry>
    <title>도둑질</title>
    <url>/2021/04/06/Stolen/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>인접한 집을 털지 않으면서 최대한 많은 돈을 도둑질하는 문제이다. 이 때 집은 원형으로 이어져 있다고 가정하기 때문에 첫번째 인덱스와 마지막 인덱스가 이어져있다. <span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvNDI4OTc=">문제 링크<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">solution</span>(<span class="params">money</span>):</span></span><br><span class="line">    dp1 = [<span class="number">0</span>] * (<span class="built_in">len</span>(money)-<span class="number">1</span>)</span><br><span class="line">    dp1[<span class="number">0</span>] = money[<span class="number">0</span>]</span><br><span class="line">    dp1[<span class="number">1</span>] = <span class="built_in">max</span>(money[<span class="number">0</span>], money[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(money)-<span class="number">1</span>):</span><br><span class="line">        dp1[i] = <span class="built_in">max</span>(dp1[i-<span class="number">1</span>], money[i]+dp1[i-<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    dp2 = [<span class="number">0</span>] * <span class="built_in">len</span>(money)</span><br><span class="line">    dp2[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line">    dp2[<span class="number">1</span>] = money[<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(money)):</span><br><span class="line">        dp2[i] = <span class="built_in">max</span>(dp2[i-<span class="number">1</span>], money[i]+dp2[i-<span class="number">2</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(dp1[-<span class="number">1</span>], dp2[-<span class="number">1</span>])</span><br></pre></td></tr></table></figure></p>
<p>집이 원형으로 이어져있을 때의 조건을 생각하지 못해서 결국 풀이를 봤다. 결론적으로 말하면 첫번째집과 마지막집은 동시에 선택하지 못한다! 그래서 이 경우를 둘로 나눠서 생각한다.</p>
<ol type="1">
<li>마지막 집을 제외하고 도둑질 할 수 있는 최대 금액을 찾는다.</li>
<li>첫번째 집을 제외하고 도둑질 할 수 있는 최대 금액을 찾는다.</li>
<li>위의 두 값 중에서 큰 값을 반환한다.</li>
</ol>
<p>이렇게 하면 겹치는 케이스가 존재할 수 있지만 적어도 피하려고 하는 케이스만을 제외하고 나머지 경우의 수를 다 구할 수 있다.</p>
<p>시간 복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<figure>
<img src="/images/programmers/stolen.png" alt="테스트 화면" /><figcaption aria-hidden="true">테스트 화면</figcaption>
</figure>
<p><br></p>
<p>DP는 너무 어렵다.. 유형중에 제일 해보지 않아서 어색하다. 백준에서 DP문제만 골라 풀어봐야겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level4</category>
      </categories>
  </entry>
  <entry>
    <title>문자열을 정수로 바꾸기</title>
    <url>/2020/12/29/String-To-Int/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>문자열을 정수로 변환하는 문제이다. 앞에는 부호(+,-)가 붙을 수 있다. 이 문제는 앞에 부호가 붙어있는지 확인한 다음, 그에 따라 달리 처리를 해주면 된다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrtoInt</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) == <span class="string">&#x27;+&#x27;</span>)</span><br><span class="line">            answer = Integer.parseInt(s.substring(<span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span>(s.charAt(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span>)</span><br><span class="line">            answer = Integer.parseInt(s.substring(<span class="number">1</span>)) * (-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            answer = Integer.parseInt(s);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> '+'가 붙은 경우, 부호를 뺀 나머지를 int로 바꿔준다. '-'가 붙은 경우 '+'와 마찬가지로 문자열을 잘라내지만 int로 바꾼뒤에 -1을 곱해준다. 만약 아무 부호도 없을 경우 자연수이므로 문자열 전체를 int로 바꿔준다. 총 시간복잡도는 <span class="math inline">\(O(1)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/str_to_int.png" width="400" height="300">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>문자열 압축</title>
    <url>/2021/01/11/String-Compress/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>문자열을 일정 단위로 끊어서 압축하려고 한다(ex. abab -&gt; 2ab). 몇 개 단위로 끊어서 압축이 가장 많이 된 문자열의 길이를 계산하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringCompress</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 문자열 압축</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;aabbcc&quot;</span>;</span><br><span class="line">        StringBuffer buff = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">2000</span>;</span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.length() == <span class="number">1</span>)</span><br><span class="line">            answer = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cut = <span class="number">1</span>; cut &lt;= s.length()/<span class="number">2</span>; cut++)</span><br><span class="line">        &#123;</span><br><span class="line">            String key = s.substring(<span class="number">0</span>, cut);</span><br><span class="line">            buff.delete(<span class="number">0</span>, buff.length());</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = cut; i &lt; s.length(); i += cut)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i + cut &gt; s.length())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt &gt; <span class="number">1</span>)</span><br><span class="line">                        buff.append(cnt);</span><br><span class="line">                    buff.append(key);</span><br><span class="line">                    buff.append(s.substring(i, s.length()));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(key.equals(s.substring(i, i+cut)))</span><br><span class="line">                &#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    <span class="keyword">if</span>(i == s.length()-<span class="number">1</span> || i+cut == s.length())</span><br><span class="line">                    &#123;</span><br><span class="line">                        buff.append(String.valueOf(cnt));</span><br><span class="line">                        buff.append(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cnt &gt; <span class="number">1</span>)</span><br><span class="line">                        buff.append(String.valueOf(cnt));</span><br><span class="line">                    buff.append(key);</span><br><span class="line">                    <span class="keyword">if</span>(i + cut &gt;= s.length())</span><br><span class="line">                    &#123;</span><br><span class="line">                        buff.append(s.substring(i, s.length()));</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    key = s.substring(i, i+cut);</span><br><span class="line">                    cnt = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            String str = buff.toString();</span><br><span class="line">            answer = Math.min(answer, str.length());</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 필자는 이 코드가 굉장히 마음에 안드는데 일단 많이 조잡하다. 핵심 아이디어는 간단하다. 앞에서부터 문자열을 끊어서 key으로 만든 뒤, 압축이 가능하다면 cnt를 계산하여, 넣어주고 아니면 문자열 그대로를 넣어준다. 만약 문자열이 남아버리면 한꺼번에 넣어준다. 필자는 세부적인 구현에서 if문을 덕지덕지 붙여서 통과했다. 질문하기에서 봤던 테스트 케이스를 참고해서 통과했으니, 세부적인 구현 능력을 좀 더 길러야겠다.</p>
<p>시간복잡도는 문자열의 길이를 n이라 할 때, 최대 <span class="math inline">\(n^2/2\)</span> 만큼 반복하므로 <span class="math inline">\(O(n^2)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/string_compress.png" width="320" height="480">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>약수의 합</title>
    <url>/2020/12/29/Sum-dividor/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>어떤 자연수 n이 주어졌을 때, 약수들의 합을 구하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SumDivisor</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level1 약수의 합</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">12</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(n%i == <span class="number">0</span>)</span><br><span class="line">                answer += i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 간단한 문제이다. 1부터 n까지 가면서 만약 나누어 떨어지는 수라면 정답에 해당 약수를 더해나가면 된다. 총 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/sum_divisor.png" width="400" height="300">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>타겟 넘버</title>
    <url>/2021/01/15/Target-Number/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>자연수 배열이 주어지고, 이 수들을 적절히 더하거나 빼서 타겟 넘버를 만들 수 있는 경우의 수를 구하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetNumber</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 타겟 넘버</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] numbers = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        answer = ReturnAnswer(numbers, <span class="number">0</span>, target, <span class="number">0</span>);</span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ReturnAnswer</span><span class="params">(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> n, <span class="keyword">int</span> target, <span class="keyword">int</span> idx)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n == target &amp;&amp; idx == numbers.length)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(idx == numbers.length)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> plus = <span class="number">0</span>, minus = <span class="number">0</span>;</span><br><span class="line">                plus += ReturnAnswer(numbers, n+numbers[idx], target, idx+<span class="number">1</span>);</span><br><span class="line">                minus += ReturnAnswer(numbers, n-numbers[idx], target, idx+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> plus+minus;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 이 문제가 왜 dfs인지 한참 고민했는데, 생각해보니 분기를 두개로 나누어가면서 탐색해 나가는 것으로 생각할 수 있다는 결론이 났다. 이를 리컬시브를 통해 구현하였다. 만약 배열의 끝에 도달했을 때 n이 타겟 넘버라면 1을 반환한다. 만약 끝에 도달해도 타겟 넘버를 만들지 못했다면 0을 반환한다. 아직 배열의 끝에 도달하지 않은 경우면 현재 있는 인덱스의 숫자를 더하거나 빼는 두 개의 분기를 만들어 이 둘의 합을 반환한다.</p>
<p>이 문제의 시간복잡도는 <span class="math inline">\(O(2^n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/target_number.png" width="290" height="220">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>모의고사</title>
    <url>/2020/12/23/Test/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>수포자 3명의 찍기 패턴이 주어지고 정답이 주어질 때 가장 문제를 많이 맞춘 수포자를 찾아내면 되는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>수포자들의 찍기 패턴이 주어져있지만 이 패턴은 시간복잡도를 최적화하는 것과는 관련이 없다. 결국 모두 봐야한다.</p>
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] answers = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] student1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] student2 = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] student3 = &#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] result = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span>[] idx = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> ans : answers)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ans == student1[idx[<span class="number">0</span>]])</span><br><span class="line">                result[<span class="number">0</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(ans == student2[idx[<span class="number">1</span>]])</span><br><span class="line">                result[<span class="number">1</span>]++;</span><br><span class="line">            <span class="keyword">if</span>(ans == student3[idx[<span class="number">2</span>]])</span><br><span class="line">                result[<span class="number">2</span>]++;</span><br><span class="line">            </span><br><span class="line">            idx[<span class="number">0</span>]++;</span><br><span class="line">            idx[<span class="number">1</span>]++;</span><br><span class="line">            idx[<span class="number">2</span>]++;</span><br><span class="line">            </span><br><span class="line">            idx[<span class="number">0</span>] %= <span class="number">5</span>;</span><br><span class="line">            idx[<span class="number">1</span>] %= <span class="number">8</span>;</span><br><span class="line">            idx[<span class="number">2</span>] %= <span class="number">10</span>;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> cnt : result)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(max &lt; cnt)</span><br><span class="line">                max = cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        Vector&lt;Integer&gt; v = <span class="keyword">new</span> Vector&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(max == result[i])</span><br><span class="line">                v.add(i);</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[v.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            answer[i] = Integer.parseInt(v.get(i).toString()) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>부분부분 살펴보자</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>[] answers = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] student1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] student2 = &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] student3 = &#123;<span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] result = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span>[] idx = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>수포자 1,2,3의 패턴을 담은 student배열을 만들었다. result배열에는 학생의 시험 점수를 담는 배열이고 idx는 각 패턴배열에서 몇번째를 봐야하는지 나타내는 배열이다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> ans : answers)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ans == student1[idx[<span class="number">0</span>]])</span><br><span class="line">        result[<span class="number">0</span>]++;</span><br><span class="line">    <span class="keyword">if</span>(ans == student2[idx[<span class="number">1</span>]])</span><br><span class="line">        result[<span class="number">1</span>]++;</span><br><span class="line">    <span class="keyword">if</span>(ans == student3[idx[<span class="number">2</span>]])</span><br><span class="line">        result[<span class="number">2</span>]++;</span><br><span class="line">    </span><br><span class="line">    idx[<span class="number">0</span>]++;</span><br><span class="line">    idx[<span class="number">1</span>]++;</span><br><span class="line">    idx[<span class="number">2</span>]++;</span><br><span class="line">    </span><br><span class="line">    idx[<span class="number">0</span>] %= <span class="number">5</span>;</span><br><span class="line">    idx[<span class="number">1</span>] %= <span class="number">8</span>;</span><br><span class="line">    idx[<span class="number">2</span>] %= <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>정답을 맞춰보는 코드이다. 만약 학생들의 찍기와 맞다면 result값을 올린다. idx를 증가한다. 이때 나머지 연산통해 배열의 사이즈를 벗어나서 참조하지 않도록 한다. 이 부분의 시간복잡도는 answers의 길이를 n이라 할 때 <span class="math inline">\(O(n)\)</span>이다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> cnt : result)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(max &lt; cnt)</span><br><span class="line">        max = cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>시험결과중 가장 높은 점수를 max에 저장한다. 이 때 result의 길이는 3으로 고정되어 있기 때문에 시간복잡도는 <span class="math inline">\(O(1)\)</span>이다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Vector&lt;Integer&gt; v = <span class="keyword">new</span> Vector&lt;Integer&gt;();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(max == result[i])</span><br><span class="line">        v.add(i);</span><br><span class="line">        </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[v.size()];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line">    answer[i] = Integer.parseInt(v.get(i).toString()) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>result중에 max값과 같은 경우가 있다면 해당 학생을 벡터 v에 넣는다. c++에선 벡터를 주로 사용하였기 때문에 벡터를 썼는데, 자바에서는 벡터보다는 어레이리스트가 많이 쓰인다고 한다. 속도면에서 차이가 있다고 하는데 다음에는 어레이리스트로 작성해봐야겠다. 벡터는 Integer형식이기 때문에 int로 바꿔주는 작업과 동시에 +1을 해준다. 수포자0,1,2가 이나라 수포자 1,2,3이기 때문이다. 이 부분의 시간복잡도는 최대 3으로 고정되므로 <span class="math inline">\(O(1)\)</span>이다.</p>
<p>최종 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/test.png" width="400" height="300">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>추석 트래픽</title>
    <url>/2021/02/08/Thanks-Giving-Traffic/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>1초 동안의 최대 트래픽이 몇개가 되는지 구하는 문제이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> START = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> END = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Time</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ms;</span><br><span class="line">        <span class="keyword">int</span> state;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Time</span><span class="params">(<span class="keyword">int</span> t, <span class="keyword">int</span> s)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.ms = t;</span><br><span class="line">            <span class="keyword">this</span>.state = s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] lines = &#123;<span class="string">&quot;2016-09-15 01:00:04.002 2.0s&quot;</span>, <span class="string">&quot;2016-09-15 01:00:07.000 2s&quot;</span>&#125;;</span><br><span class="line">        List&lt;Time&gt; times = <span class="keyword">new</span> ArrayList&lt;Time&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String line : lines)</span><br><span class="line">        &#123;</span><br><span class="line">            String[] line_info = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">//종료시간을 0.001초 단위로 환산하자</span></span><br><span class="line">            String[] time_str = line_info[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> end_t = Integer.parseInt(time_str[<span class="number">0</span>])*<span class="number">3600000</span> + Integer.parseInt(time_str[<span class="number">1</span>])*<span class="number">60000</span> + Integer.parseInt(time_str[<span class="number">2</span>].split(<span class="string">&quot;\\.&quot;</span>)[<span class="number">0</span>])*<span class="number">1000</span> + Integer.parseInt(time_str[<span class="number">2</span>].split(<span class="string">&quot;\\.&quot;</span>)[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//지속시간을 구해볼까</span></span><br><span class="line">            String last_time_str = line_info[<span class="number">2</span>].substring(<span class="number">0</span>, line_info[<span class="number">2</span>].length()-<span class="number">1</span>);</span><br><span class="line">            String[] last_time_arr = last_time_str.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> last_t = Integer.parseInt(last_time_arr[<span class="number">0</span>])*<span class="number">1000</span>;</span><br><span class="line">            <span class="keyword">if</span>(last_time_arr.length &gt; <span class="number">1</span>)</span><br><span class="line">                last_t += Integer.parseInt(last_time_arr[<span class="number">1</span>]);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//이제 시작 시간을 구하자(끝시간 - 지속시간 +1)</span></span><br><span class="line">            <span class="keyword">int</span> start_t = end_t - last_t + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            test obj = <span class="keyword">new</span> test();</span><br><span class="line">            test.Time t = obj.<span class="function">new <span class="title">Time</span><span class="params">(start_t, START)</span></span>;</span><br><span class="line">            times.add(t);</span><br><span class="line">            t = obj.<span class="function">new <span class="title">Time</span><span class="params">(end_t+<span class="number">999</span>, END)</span></span>;</span><br><span class="line">            times.add(t);</span><br><span class="line">        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Comparator&lt;Time&gt; t_comparator = <span class="keyword">new</span> Comparator&lt;Time&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(Time o1, Time o2)</span></span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(o1.ms != o2.ms)</span><br><span class="line">                    <span class="keyword">return</span> Integer.compare(o1.ms, o2.ms);</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(o1.state, o2.state);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Collections.sort(times, t_comparator);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> working = <span class="number">0</span>, max_cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; times.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(times.get(i).state == START)</span><br><span class="line">                ++working;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                --working;</span><br><span class="line"></span><br><span class="line">            max_cnt = Math.max(working, max_cnt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(max_cnt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 이 문제에서의 핵심 아이디어는 어떻게 1초 트래픽을 어디서 볼 것인가 이다. 밀리초마다 단위를 옯겨가면서 하면 연산량이 많아진다. 따라서 우리는 언제 트래픽의 개수가 변하는지 생각해봐야 한다. 생각해보면 구간의 양 끝에서 트래픽이 변할 수 있다는 것을 알 수 있다. 이 아이디어를 가지고 코드를 살펴보자.</p>
<p>8~16번째 라인을 보면 <code>Time</code>에 대한 정의를 해놓은 것을 볼 수 있다. ms는 시간을 의미하고 <code>state</code>는 구간의 처음에 해당하는지 끝에 해당하는지 알려주는 변수이다. <code>state</code>에는 <code>START</code>또는 <code>END</code>가 들어가며, 이는 각각 0과 1이다.</p>
<p>24~46번째는 로그에 있는 시간을 ms단위로 바꾼 뒤, 이를 리스트에 저장하는 과정이다. 첫구간과 끝구간을 저장하는데 잘 보면 <code>end_T+999</code>를 저장한 것을 볼 수 있다. 이는 뒤 구간을 포함해서 1초안에 해당하면 동시에 진행되는 작업물로 보기 때문이다(ex 4.001초에 완료한것과 5초에 시작하는 트래픽은 동시에 일어난 것으로 본다).</p>
<p>48~57번째 줄에서는 정렬을 한다. 정렬을 할 땐 기본적으로 시작 시각을 기준으로 하고 시각 기준이 같을 시 시작 구간인 부분을 우선으로 한다. 왜냐하면 동시에 시작하고 끝난 트래픽도 두 작업을 같이 했다고 보기 때문이다.</p>
<p>정렬이 끝나고 난 뒤 배열을 돌면서 구간이 <code>START</code> 이면 <code>working</code>에 1을 더해주고 그렇지 않으면 1을 뺀다. 구간에만 집중하여 문제를 풀면 <span class="math inline">\(O(nlogn)\)</span>만에 문제를 풀 수 있다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/thanks_giving_traffic.png" width="290" height="540">
</center>
<p><br></p>
<p>아이디어는 다 생각이 났었는데 코드로 이 아이디어를 어떻게 풀어나가야 할지 몰라 난감했다. 거의 끝까지 왔는데 미처 못 풀어서 다른 사람의 풀이를 참고해서 짰는데 속상하다. 카카오 블라인드 테스트 중에서 가장 어려운 문제라고 하던데 그래도 아이디어는 생각해 낸 것까지 올라온 걸로 위안을 삼기로 했다. 포기하지 말자.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level3</category>
      </categories>
  </entry>
  <entry>
    <title>방금그곡</title>
    <url>/2021/02/03/That-Song/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>네오가 기억하는 계이름과 음악의 계이름 재생시간이 주어질 때, 네오가 들은 곡을 알아내는 문제이다. 음악의 길이보다 재생기간이 길면 반복하여 재생하는 것이고, 짧다면 중간에 끊어진 것이라고 봐야한다. 만약 네오가 기억하는 계이름을 가지고 있는 곡이 여러 개라면 재생 시간이 긴 것을 우선으로 하고, 재생 시간도 같은 경우 먼저 들어온 곡을 반환한다.</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvMTc2ODMjcW5h">문제 링크<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> level2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PreviousSong</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 Level2 방금그곡</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        String[] musicinfos = &#123;</span><br><span class="line">            <span class="string">&quot;12:00,12:05,HI,ABC#ABC&quot;</span>,</span><br><span class="line">            <span class="string">&quot;13:00,13:05,WORLD,ABCDEF&quot;</span></span><br><span class="line">        &#125;;</span><br><span class="line">        String m = <span class="string">&quot;ABC&quot;</span>;</span><br><span class="line">        String answer = <span class="string">&quot;(None)&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> last_time = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String info : musicinfos)</span><br><span class="line">        &#123;</span><br><span class="line">            </span><br><span class="line">            String[] info_arr = info.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">            String[] start_t = info_arr[<span class="number">0</span>].split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            String[] end_t = info_arr[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> start_m = Integer.parseInt(start_t[<span class="number">0</span>])*<span class="number">60</span> + Integer.parseInt(start_t[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">int</span> end_m = Integer.parseInt(end_t[<span class="number">0</span>])*<span class="number">60</span> + Integer.parseInt(end_t[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">int</span> duration = end_m - start_m;</span><br><span class="line">            </span><br><span class="line">            </span><br><span class="line">            String[] split_by_pound_arr = info_arr[<span class="number">3</span>].split(<span class="string">&quot;#&quot;</span>);</span><br><span class="line">            <span class="keyword">int</span> code_cnt = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(String pound_str : split_by_pound_arr)</span><br><span class="line">            &#123;</span><br><span class="line">                String[] codes = pound_str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span>(String code : codes)</span><br><span class="line">                    code_cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            code_cnt--;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> repeat = duration/code_cnt;</span><br><span class="line">            <span class="keyword">int</span> song_end = duration%code_cnt;</span><br><span class="line">            String song = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; repeat; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                song += info_arr[<span class="number">3</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">char</span>[] song_arr = info_arr[<span class="number">3</span>].toCharArray();</span><br><span class="line">            <span class="keyword">int</span> song_idx = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; song_arr.length; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(song_idx == song_end)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                StringBuilder buff = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                buff.append(song_arr[i]);</span><br><span class="line">                <span class="keyword">if</span>((i &lt; song_arr.length-<span class="number">1</span>) &amp;&amp; (song_arr[i+<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>))</span><br><span class="line">                    buff.append(song_arr[++i]);</span><br><span class="line">                song += buff.toString();</span><br><span class="line">                </span><br><span class="line">                </span><br><span class="line">                song_idx++;   </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">int</span> idx = song.indexOf(m);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>((last_time &lt; duration) &amp;&amp; (idx != -<span class="number">1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span>(idx != -<span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(song.length() &gt; idx+m.length())</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(song.charAt(idx+m.length()) == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            idx = song.indexOf(m, idx+m.length());</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; </span><br><span class="line">                    idx = song.indexOf(m, idx+m.length());</span><br><span class="line">                    answer = info_arr[<span class="number">2</span>];</span><br><span class="line">                    last_time = duration;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 곡을 찾아내기 위해 크게 3가지 과정을 거칠 것이다. 1. 재생 시간을 계산한다. 2. 곡을 재생 시간만큼 만든다. 3. 네오가 기억하는 음과 비교하여 그 곡이 맞는지 확인한다.</p>
<p>우선 1번과정부터 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] info_arr = info.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">String[] start_t = info_arr[<span class="number">0</span>].split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line">String[] end_t = info_arr[<span class="number">1</span>].split(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> start_m = Integer.parseInt(start_t[<span class="number">0</span>])*<span class="number">60</span> + Integer.parseInt(start_t[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">int</span> end_m = Integer.parseInt(end_t[<span class="number">0</span>])*<span class="number">60</span> + Integer.parseInt(end_t[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">int</span> duration = end_m - start_m;</span><br></pre></td></tr></table></figure>
<p>재생 시간을 계산하는 방법은 쉽다 모두 분 단위로 변환한 뒤, 종료시각에서 재생시각을 빼면 된다.</p>
<p>2번과정으로 넘어가보자</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] split_by_pound_arr = info_arr[<span class="number">3</span>].split(<span class="string">&quot;#&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> code_cnt = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(String pound_str : split_by_pound_arr)</span><br><span class="line">&#123;</span><br><span class="line">    String[] codes = pound_str.split(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    <span class="keyword">for</span>(String code : codes)</span><br><span class="line">        code_cnt++;</span><br><span class="line">&#125;</span><br><span class="line">code_cnt--;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> repeat = duration/code_cnt;</span><br><span class="line"><span class="keyword">int</span> song_end = duration%code_cnt;</span><br><span class="line">String song = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; repeat; i++)</span><br><span class="line">&#123;</span><br><span class="line">    song += info_arr[<span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>[] song_arr = info_arr[<span class="number">3</span>].toCharArray();</span><br><span class="line"><span class="keyword">int</span> song_idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; song_arr.length; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(song_idx == song_end)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    StringBuilder buff = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    buff.append(song_arr[i]);</span><br><span class="line">    <span class="keyword">if</span>((i &lt; song_arr.length-<span class="number">1</span>) &amp;&amp; (song_arr[i+<span class="number">1</span>] == <span class="string">&#x27;#&#x27;</span>))</span><br><span class="line">        buff.append(song_arr[++i]);</span><br><span class="line">    song += buff.toString();</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    song_idx++;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>곡을 재생시간만큼 만들기 위해서 #에 대한 처리가 필요하다. 일단 #을 제외하면 전체 계이름 개수를 알 수 있다. #을 기준으로 문자열을 쪼갠 뒤, 전체 계이름 개수를 구한다. 그리고 repeat와 song_end를 구한다. repeat는 전체 노래가 몇 번 반복하는지 알려주는 변수이다. 나누기 연산을 통해 구할 수 있다. song_end는 중간에서 노래가 멈출 경우 몇번째 음에서 멈추는지 알려주는 변수이다. 이는 나머지 연산을 통해 구할 수 있다.</p>
<p>repeat수 만큼 전체 문자열을 song에 더해주고 두번째 for문은 song_idx가 song_end에 도달할 때까지 #을 고려하여 song에 계이름을 더해준다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> idx = song.indexOf(m);</span><br><span class="line">            </span><br><span class="line"><span class="keyword">if</span>((last_time &lt; duration) &amp;&amp; (idx != -<span class="number">1</span>))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(idx != -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(song.length() &gt; idx+m.length())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(song.charAt(idx+m.length()) == <span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                idx = song.indexOf(m, idx+m.length());</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        idx = song.indexOf(m, idx+m.length());</span><br><span class="line">        answer = info_arr[<span class="number">2</span>];</span><br><span class="line">        last_time = duration;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이제 만든 노래를 비교해보면 된다. 여태까지 제일 길었떤 재생 시간을 저장한 last_time이 duration보다 작고, 네오가 기억한 음이 포함되어 있다면 if문 안으로 들어간다. 이 때, 처리해주지 못하는 케이스가 있는데 맨 마지막에 #이 붙는 경우이다. 이 경우 indexOf로 찾은 값에 m의 길이를 더해 #이 있으면 불일치로 간주하면 된다. 네오의 음과 일치하는 구절이 여러 곳일 수 있기 때문에 idx는 루프를 돌 때 마다 업데이트한다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/previous_song.png" width="290" height="530">
</center>
<p><br> categories: [Problem Solving, Programmers, Level2]</p>
<p>#을 처리하는 것에서 많이 헤맸는데, 다른 사람들의 풀이를 보니 C#같은 문자열을 c로 바꾸어 문제를 간단하게 풀었다. 나도 그런 아이디어가 나도록 훈련해야겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>단어변환</title>
    <url>/2021/03/02/Transfrom-Word/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>시작단어에서 끝단어로 변환하는 최소 횟수를 알아내려고 한다. 만약 변환할 수 없다면 0을 반환한다. 변환을 거칠 땐 알파벳 한 글자만 바꿀 수 있다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformWord</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//프로그래머스 level3 단어 변환</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[][] matrix;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String begin = <span class="string">&quot;hit&quot;</span>;</span><br><span class="line">        String target = <span class="string">&quot;cog&quot;</span>;</span><br><span class="line">        String[] words = &#123;<span class="string">&quot;cog&quot;</span>, <span class="string">&quot;log&quot;</span>, <span class="string">&quot;lot&quot;</span>, <span class="string">&quot;dog&quot;</span>, <span class="string">&quot;dot&quot;</span>, <span class="string">&quot;hot&quot;</span>&#125;;</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">        list.add(begin);</span><br><span class="line">        <span class="keyword">for</span>(String s : words)</span><br><span class="line">            list.add(s);</span><br><span class="line"></span><br><span class="line">        matrix = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()][list.size()];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; list.size(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(canConnect(list.get(i), list.get(j)))</span><br><span class="line">                &#123;</span><br><span class="line">                    matrix[i][j] = <span class="number">1</span>;</span><br><span class="line">                    matrix[j][i] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> inf = <span class="number">1250</span>;</span><br><span class="line">        <span class="keyword">int</span>[] distance  = <span class="keyword">new</span> <span class="keyword">int</span>[list.size()];</span><br><span class="line">        <span class="keyword">boolean</span>[] visited  = <span class="keyword">new</span> <span class="keyword">boolean</span>[list.size()];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; list.size(); i++)</span><br><span class="line">            distance[i] = inf;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        stack.push(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(!stack.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> root = stack.pop();</span><br><span class="line">            visited[root] = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.size(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(matrix[root][i] == <span class="number">1</span> &amp;&amp; !visited[i])</span><br><span class="line">                &#123;</span><br><span class="line">                    stack.push(i);</span><br><span class="line">                    <span class="keyword">if</span>(distance[i] &gt; distance[root]+<span class="number">1</span>)</span><br><span class="line">                        distance[i] = distance[root]+<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = list.indexOf(target);</span><br><span class="line">        <span class="keyword">if</span>(index == -<span class="number">1</span> || distance[index] == inf)</span><br><span class="line">            System.out.println(<span class="string">&quot;false&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(distance[index]);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">canConnect</span><span class="params">(String s1, String s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr1 = s1.toCharArray();</span><br><span class="line">        <span class="keyword">char</span>[] arr2 = s2.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> wrong = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr1.length; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr1[i] != arr2[i])</span><br><span class="line">                ++wrong;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> wrong == <span class="number">1</span> ? <span class="keyword">true</span> : <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 단어간의 변환 관계를 따지면 그래프를 만들 수 있다. 만든 그래프에서 begin에서 각 단어까지 변환하는데 걸리는 최소 변환 횟수를 구한다. 마지막으로 타겟 단어의 index에 해당하는 횟수를 반환하면 된다. 만약 타겟 단어가 없다면 0을 반환한다.</p>
<p>일단 그래프를 만들기 위해 두 단어가 변환이 되는 지 확인하는 함수 <code>canConnect</code>를 정의하였다. 모든 단어의 길이는 같다고 했으므로, 한쪽의 길이를 기준으로 하여 문자를 비교한다. 만약 다른 글자수(<code>wrong</code>)가 하나라면 <code>true</code>를 반환하고, 아니라면 <code>false</code>를 반환한다.</p>
<p>리스트 <code>list</code>를 만들어 첫시간과 words를 합친다. 반복문을 통해 모든 쌍을 <code>canConnect</code>를 통해 변환할 수 있는 관계인지 파악하고, 만약 변환할 수 있다면 <code>matrix</code>에 1이라 표시한다(18-30줄).</p>
<p>그래프를 <code>matrix</code>에 표시했으므로, dfs를 활용하여 최소 변환 횟수를 구할 차례이다. 이번 문제는 가능한 가 가능한지 않은가가 아니라, 최소를 찾아야 하므로 <code>distance</code>를 추가로 선언한다. 시작단어인 <code>distance[0]</code>은 0으로 하고 나머지는 큰 상수로 초기화한다.</p>
<p>이제 본격적인 dfs로 들어가보자. 스택에 0번을 넣고 <code>vistied</code>(방문했는지 여부)를 true로 한다. 그리고 변환할 수 있는 단어 중에 아직 방문하지 않은 단어들의 인덱스를 담는다. 이 때, 변환 횟수를 비교하는데 만약 현재 단어가 가지고 있는 <code>distance</code>값보다 현재 단어에서 1을 더한 값이 더 작다면 그 값으로 업데이트한다.</p>
<p>dfs를 모두 마치면 <code>distance</code>에는 시작단어에서 각각의 모든 단어로 변환할 수 있는 최소 횟수가 담기게 된다. 이제 <code>indexOf()</code>메소드를 이용하여 끝 단어의 인덱스를 구해 그 값을 반환하면 된다. 만약 끝단어의 <code>distance</code>값이 무한이거나 없을 경우에는 <code>false</code>를 출력하면 된다.</p>
<p>adjacency matrix를 사용하기 때문에, 최종 시간복잡도는 <span class="math inline">\(O(n^2)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/word_transform.png" width="290" height="130">
</center>
<p><br></p>
<p>다른 사람의 풀이를 보니 그냥 dfs를 이용해서 풀었는데도 통과가 되었다. 그런데 그렇게 하면 최소값이 아니게 도달해도 정답이 되버릴텐데,, 이 부분에서 프로그래머스가 테스트 케이스를 추가해줬으면 좋겠다는 생각이 들었다.</p>
<p>이 문제를 풀면서 다익스트라를 참고도 안하고 혼자서 해보려고 했는데 나중에 다 풀고보니 다익스트라는 인접한 것 중에 가장 짧은 경로를 기준으로 가는 거라고 했다. 필자는 그냥 가장 나중에 확인한 것을 다음 노드로 지정하였는데 이렇게 해도 최단 거리를 찾을 수 있을지 궁금하다. 다음에 또 이런 문제를 만난다면 그 땐 다익스트라를 좀 더 세심하게 구현해야겠다. 덕분에 모자란 개념을 보충할 수 있었다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level3</category>
      </categories>
  </entry>
  <entry>
    <title>괄호 변환</title>
    <url>/2021/01/12/Transform-Bracket/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>괄호의 짝이 맞도록 괄호 변환 프로그램을 개발하는 일이다. 감사하게도 변환하는 과정을 담은 알고리즘을 주었다. 변환 과정을 보고 오지 않은 사람들은 <span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvNjAwNTg=">링크<i class="fa fa-external-link-alt"></i></span>에서 보고 오길 바란다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertBracket</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 괄호 변환</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String p = <span class="string">&quot;()))((()&quot;</span>;</span><br><span class="line">        String answer = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(isCorrectBracket(p))</span><br><span class="line">            answer = p;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            answer = ChangeBracket(p);</span><br><span class="line"></span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCorrectBracket</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> open = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> close = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                open++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                close++;</span><br><span class="line">            <span class="keyword">if</span>(close &gt; open)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">ChangeBracket</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//1. 입력이 빈 문자열인 경우 빈 문자열을 반환합니다.</span></span><br><span class="line">        <span class="keyword">if</span>(s.equals(<span class="string">&quot;&quot;</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//2. u, v로 분리</span></span><br><span class="line">            String u = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            String v = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">            <span class="keyword">int</span> open = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> close = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">char</span> c : arr)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                    open++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    close++;</span><br><span class="line">                <span class="keyword">if</span>(open == close)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> idx = open*<span class="number">2</span>;</span><br><span class="line">            u = s.substring(<span class="number">0</span>, idx);</span><br><span class="line">            <span class="keyword">if</span>(idx &lt; s.length())</span><br><span class="line">                v = s.substring(idx);</span><br><span class="line"></span><br><span class="line">            String temp = ChangeBracket(v);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//3.u가 올바른 문자열일 경우</span></span><br><span class="line">            <span class="keyword">if</span>(isCorrectBracket(u))</span><br><span class="line">                <span class="keyword">return</span> u + temp;</span><br><span class="line">            <span class="comment">//4.u가 올바른 문자열이 아닐 경우</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                StringBuilder buff = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">                <span class="comment">//4-1.</span></span><br><span class="line">                buff.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">                <span class="comment">//4-2.</span></span><br><span class="line">                buff.append(temp);</span><br><span class="line">                <span class="comment">//4-3.</span></span><br><span class="line">                buff.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">                <span class="comment">//4-4.</span></span><br><span class="line">                u = u.substring(<span class="number">1</span>, u.length()-<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">if</span>(!u.equals(<span class="string">&quot;&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">char</span>[] array = u.toCharArray();</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)</span><br><span class="line">                        array[i] = array[i] == <span class="string">&#x27;(&#x27;</span> ? <span class="string">&#x27;)&#x27;</span> : <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">                    buff.append(array);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//4-5.</span></span><br><span class="line">                <span class="keyword">return</span> buff.toString();</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 일단 코드 길이에 겁먹지 말자. 필자도 처음에 이런 문제를 보면 멘붕이와서 자괴감에 빠지다가 아무것도 못했다. 이러한 문제는 차근차근 단계를 나누어하면 조금 시간이 걸려도 풀 수 있다. 부분부분 코드를 보면 생각보다 어렵지 않을 것이다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String p = <span class="string">&quot;()))((()&quot;</span>;</span><br><span class="line">String answer = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isCorrectBracket(p))</span><br><span class="line">    answer = p;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    answer = ChangeBracket(p);</span><br><span class="line"></span><br><span class="line">System.out.println(answer);</span><br></pre></td></tr></table></figure>
<p>함수를 실행하는 부분이다. p는 입력이고 p가 만약 올바른 괄호 문자열이라면 p그대로를 정답으로 한다. 그렇지 않으면 변환 프로그램을 거친다. 먼저 올바른 괄호 문자열인지 판별해 주는 isCorrectBracket함수를 살펴보자.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isCorrectBracket</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> open = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> close = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : arr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">            open++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            close++;</span><br><span class="line">        <span class="keyword">if</span>(close &gt; open)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>올바른 괄호 문자열인지 판별하는 방법은 간단하다. 닫은 괄호가 연 괄호보다 많아지는 순간 그 문자열은 올바르지 않다. 이를 그대로 코드로 구현하였다. open과 close를 이용해 닫는 괄호가 여는 괄호보다 많아지면 거짓을 반환하고 그렇지 않다면 참을 반환하도록 했다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">ChangeBracket</span><span class="params">(String s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//1. 입력이 빈 문자열인 경우 빈 문자열을 반환합니다.</span></span><br><span class="line">    <span class="keyword">if</span>(s.equals(<span class="string">&quot;&quot;</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//2. u, v로 분리</span></span><br><span class="line">        String u = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        String v = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">int</span> open = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> close = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c : arr)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                open++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                close++;</span><br><span class="line">            <span class="keyword">if</span>(open == close)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = open*<span class="number">2</span>;</span><br><span class="line">        u = s.substring(<span class="number">0</span>, idx);</span><br><span class="line">        <span class="keyword">if</span>(idx &lt; s.length())</span><br><span class="line">            v = s.substring(idx);</span><br><span class="line"></span><br><span class="line">        String temp = ChangeBracket(v);</span><br><span class="line">            </span><br><span class="line">        <span class="comment">//3.u가 올바른 문자열일 경우</span></span><br><span class="line">        <span class="keyword">if</span>(isCorrectBracket(u))</span><br><span class="line">            <span class="keyword">return</span> u + temp;</span><br><span class="line">        <span class="comment">//4.u가 올바른 문자열이 아닐 경우</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            StringBuilder buff = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">            <span class="comment">//4-1.</span></span><br><span class="line">            buff.append(<span class="string">&quot;(&quot;</span>);</span><br><span class="line">            <span class="comment">//4-2.</span></span><br><span class="line">            buff.append(temp);</span><br><span class="line">            <span class="comment">//4-3.</span></span><br><span class="line">            buff.append(<span class="string">&quot;)&quot;</span>);</span><br><span class="line">            <span class="comment">//4-4.</span></span><br><span class="line">            u = u.substring(<span class="number">1</span>, u.length()-<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(!u.equals(<span class="string">&quot;&quot;</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">char</span>[] array = u.toCharArray();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; i++)</span><br><span class="line">                    array[i] = array[i] == <span class="string">&#x27;(&#x27;</span> ? <span class="string">&#x27;)&#x27;</span> : <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">                buff.append(array);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//4-5.</span></span><br><span class="line">            <span class="keyword">return</span> buff.toString();</span><br><span class="line">                </span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>제일 긴 괄호 변환 프로그램인데 해당 과정마다 주석을 달아놨다. 코드를 찬찬히 읽어보면 이해가 갈 것이다. 2과정에서 u는 더 이상 나누어지지 않는 균형잡힌 괄호 문자열이므로 처음으로 균형이 잡히면 반복문을 탈출한다.</p>
<p>이 코드의 시간 복잡도를 생각해보면 ')('가 여러 개 반복되는 패턴이다(재귀를 최대한 호출하기 때문이다.). 재귀의 반복횟수는 p의 길이를 N이라 할 때, <span class="math inline">\(log_{2}N\)</span>이고, 재귀 안에서의 시간복잡도는 <span class="math inline">\(O(N)\)</span>이므로, <span class="math inline">\(O(Nlog_{2}N)\)</span>이 최종 시간복잡도이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/convert_bracket.png" width="290" height="540">
</center>
<p><br></p>
<p>카카오를 지원했을 때 2-3시간이 지나도 잘 못 풀었던 문제들을 풀어나가서 기쁘다. 비록 이것도 1시간이나 걸렸지만 앞으로 시간을 더 줄여나가야겠다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>삼각 달팽이</title>
    <url>/2021/01/11/Triangle-Snail/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>밑변과 높이의 길이가 n인 삼각형이 있고 이를 맨 위 꼭짓점에서부터 반시계방향으로 달팽이를 채우기 하고 열대로 숫자를 담아 출력하는 문제이다. 자세한 그림이 궁금한 사람은 <span class="exturl" data-url="aHR0cHM6Ly9wcm9ncmFtbWVycy5jby5rci9sZWFybi9jb3Vyc2VzLzMwL2xlc3NvbnMvNjg2NDU=">링크<i class="fa fa-external-link-alt"></i></span>를 참고해보길 바란다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TriSnail</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 삼각 달팽이</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">int</span>[][] paper = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*n-<span class="number">1</span>][<span class="number">2</span>*n-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> len = n;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l_d_move = n%<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> r_move = l_d_move-<span class="number">1</span> &lt; <span class="number">0</span> ? <span class="number">2</span>: l_d_move-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, c = (<span class="number">2</span>*n-<span class="number">1</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(len != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> move_id = len%<span class="number">3</span>;</span><br><span class="line">            <span class="keyword">if</span>(move_id == l_d_move)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">                    paper[r++][c--] = num++;</span><br><span class="line">                r--;</span><br><span class="line">                c++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(move_id == r_move)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    c+=<span class="number">2</span>;</span><br><span class="line">                    paper[r][c] = num++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">                    paper[--r][--c] = num++;</span><br><span class="line">                ++r;</span><br><span class="line">                --c;</span><br><span class="line">            &#125;</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[num-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>*n-<span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>*n-<span class="number">1</span>; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(paper[i][j] != <span class="number">0</span>)</span><br><span class="line">                    answer[idx++] = paper[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 처음엔 같은 행에 속한 요소들끼리 무언가 규칙이 있을까 찾아봤지만, 너무 복잡하였다. 그래서 문제에서 주어진 달팽이를 그대로 2차원 배열에 그린 뒤, 맨 위에서부터 0이 아닌 값을 읽어들여 배열에 넣는 방법을 생각했다. 그럼 반시계 방향으로 달팽이 채우기를 하는 알고리즘이 필요한데, 이해를 돕기 위해 그림을 첨부한다.</p>
<p><br></p>
<center>
<img src="/images/programmers/snail.jpeg" width="800" height="350">
</center>
<p><br></p>
<p>그림을 보면 반시계 방향으로 꺽으면서 이동횟수가 1씩 감소하는 것을 볼 수 있다. 삼각형을 그리면서 움직이므로 여기서 규칙을 찾아낼 수 있다. 바로 이동횟수를 3으로 나누고 난 나머지 값을 활용해 어느 방향으로 가야하는지 알 수 있다는 것이다. n=4일 때의 달팽이 채우기를 보자, 4와 1일 때는 왼쪽 아래로 향하는 것을 볼 수 있다. n=5일 때도 보면 같은 규칙이 적용되는 것을 볼 수 있다. 5와 2는 3으로 나눈 나머지가 모두 2이므로, 2일 때 왼쪽 아래로 움직여야 하는 것을 알 수 있다.</p>
<p>규칙을 찾아냈으니 달팽이 채우기를 그릴 틀이 필요하다. 필자는 이것을 paper라고 선언했다. n<em>n으로 2차원배열을 선언하고자 할텐데, 종이와 달리 배열은 중간에 낀 수가 없기 때문에 이렇게 해선 안된다. 2</em>n-1이 길이여야 하는데 이는 아래 그림을 참고하면 왜 그런지 알 수 있다.</p>
<p><br></p>
<center>
<img src="/images/programmers/snail_paper.jpeg" width="915" height="315">
</center>
<p><br></p>
<p>핵심 아이디어를 다 익혔으니 코드 세부 구현을 보자. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">int</span>[][] paper = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>*n-<span class="number">1</span>][<span class="number">2</span>*n-<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> len = n;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> l_d_move = n%<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> r_move = l_d_move-<span class="number">1</span> &lt; <span class="number">0</span> ? <span class="number">2</span>: l_d_move-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> r = <span class="number">0</span>, c = (<span class="number">2</span>*n-<span class="number">1</span>)/<span class="number">2</span>;</span><br></pre></td></tr></table></figure> 왼쪽아래 움직임을 l_d_move라 표현했다. 그리고 r_move는 오른쪽으로 움직이는 경우의 나머지값을 나타낸 것이다. l_d_moved에서 1을 뺀 값이지만, 만약 l_d_move가 0인 경우, r_move는 2이기 때문에 이에 대한 처리도 함께한다. 초기 1이 위치하는 값은 (0,(2*n-1)/2)이다. 이제 달팽이 채우기로 가보자.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(len != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> move_id = len%<span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>(move_id == l_d_move)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            paper[r++][c--] = num++;</span><br><span class="line">        r--;</span><br><span class="line">        c++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(move_id == r_move)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            c+=<span class="number">2</span>;</span><br><span class="line">            paper[r][c] = num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">            paper[--r][--c] = num++;</span><br><span class="line">        ++r;</span><br><span class="line">        --c;</span><br><span class="line">    &#125;</span><br><span class="line">    len--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>move_id에 따라 종이에 숫자를 채워가는 코드이다. r과 c값을 조정해나가면 된다. 범위 때문에 r이나 c값이 이상해지지 않도록 반복문 탈출 뒤 조정해주는 과정도 거친다. 여기서 필자보다 깨끗하게 코드를 짤 수 있을거라 생각하기 때문에, 이 부분에서 더 세부적인 내용은 생략한다. 여기서 시간복잡도는 <span class="math inline">\(O(n)\)</span>이 되겠다.</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>[] answer = <span class="keyword">new</span> <span class="keyword">int</span>[num-<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">2</span>*n-<span class="number">1</span>; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(paper[i][j] != <span class="number">0</span>)</span><br><span class="line">            answer[idx++] = paper[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이제 paper를 순회하면서 0이 아닌 값을 발견할 때 마다, answer에 값을 넣어주면 된다. 행은 n까지만 보면 되므로, 행의 최대값은 n으로 한다. 이 부분에서 시간복잡도는 <span class="math inline">\(O(n^2)\)</span>이다. 따라서 최종 시간복잡도는 <span class="math inline">\(O(n^2)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/tri_snail.png" width="350" height="270">
</center>
<p><br></p>
<p>어떠한 규칙을 찾아내는 냐에 따라 코드가 천차만별인 것 같다. 코드를 좀 더 줄일 수 있는 규칙이 추가로 있는지 고민해봐야겠다.</p>
]]></content>
  </entry>
  <entry>
    <title>x만큼 간격이 있는 n개의 수</title>
    <url>/2020/12/30/X-Interval-Num/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>x가 초항이자 공차인 등차수열을 n만큼 만드는 것이다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NNumXSpace</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제 풀이 level1 x만큼 간격이 있는 n개의 숫자</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">2</span>, n = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">long</span>[] answer = <span class="keyword">new</span> <span class="keyword">long</span>[n];</span><br><span class="line">        answer[<span class="number">0</span>] = x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++)</span><br><span class="line">            answer[i] = answer[i-<span class="number">1</span>]+x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 정답배열의 첫번째 항을 x로 초기화 한 뒤, 등차수열을 만들 듯 이전 항에 x만큼 더하면 된다. 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/x_space_n_num.png" width="350" height="500">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>다리를 지나는 트럭</title>
    <url>/2021/01/06/Truck-Acrossing-Bridge/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>다리의 길이와 버틸 수 있는 최대 무게, 그리고 지나가려는 트럭의 무게가 주어진다. 트럭이 '순서대로' 다리를 건너가려고 할 때, 걸리는 최소 시간을 구하라.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CrossBridge</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//프로그래머스 문제풀이 level2 다리를 지나는 트럭</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> bridge_length = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span> weight = <span class="number">5</span>;</span><br><span class="line">        <span class="keyword">int</span>[] truck_weights = &#123;<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> answer = <span class="number">0</span>;</span><br><span class="line">        Queue&lt;Integer&gt; q = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> item = <span class="number">0</span>, w = <span class="number">0</span>, out = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> in_time = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(item &lt; truck_weights.length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>((w+truck_weights[item] &gt; weight) </span><br><span class="line">                    || (q.isEmpty() ? <span class="keyword">false</span> : in_time &gt;= q.peek()+bridge_length))</span><br><span class="line">            &#123;</span><br><span class="line">                w -= truck_weights[out++];</span><br><span class="line">                in_time = q.poll() + bridge_length;</span><br><span class="line">            &#125;</span><br><span class="line">            q.add(in_time);</span><br><span class="line">            w += truck_weights[item];</span><br><span class="line"></span><br><span class="line">            in_time++;</span><br><span class="line">            item++;</span><br><span class="line">        &#125;</span><br><span class="line">        answer = --in_time + bridge_length;</span><br><span class="line"></span><br><span class="line">        System.out.println(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure> 처음에 필자는 저 순서대로를 못 읽고, 정렬을 했다가 주구장창 틀렸다. 역시 문제는 꼼꼼히 읽자. 필자는 각 트럭별로 들어오는 시간을 계산하여, 가장 마지막 시작시간에 다리의 길이를 더해주는걸로 정답을 내었다. 변수 설명을 하자면, item은 각 트럭의 id인덱스 번호이다(지금 생각해보니 truck_id가 더 나았을 것 같다.). w는 현재 다리가 버티고 있는 무게이고, out은 현재 다리를 빠져나간 트럭의 인덱스를 나타낸다. in_time은 트럭이 다리로 진입할 때의 시간이다. 이제 트럭을 큐에 넣었다 빼며, 맨 마지막으로 들어오는 트럭의 진입시간(in_time)을 계산하면 된다. 일단 while문을 넘기고 24-28번째 줄을 들여다보자. 큐에 진입하는 시간을 넣고, 다음 트럭이 오는 in_time을 계산하기 위해 item과 in_time을 1씩 증가하였다. 기본적으로 weight가 무한대라면 저것만 쓰면 될 테지만, 다리가 버틸 수 있는 무게가 있기에 while문이 필요한 것이다. while문의 첫번째 조건은 이해가 간다. 들어올 트럭의 무게를 현재 무게에 합했을 때 한계치를 넘을 경우, 앞에 있는 트럭이 빠져나가고 넣어야 한다. 뒤에 있는 조건문이 어려울 수도 있는데 이를 설명하기 위해 코드에서 쓴 테스트 케이스를 그림으로 설명하겠다.</p>
<p><br></p>
<center>
<img src="/images/programmers/truck_bridge.jpeg" width="825" height="680">
</center>
<p><br></p>
<p>트럭의 무게들과 첫번째 조건만을 활용했을 경우 나타나는 오류를 나타낸 그림이다. 아래가 각 시간마다 다리에 있는 트럭의 위치를 나타낸 것이니 참고하면 되겠다. while문의 두번째 조건을 무시하고 첫번째 조건만을 신경쓴 채로 큐에 원소를 넣고 빼고 하다보면 idx = 6일 때 이상한 모습을 볼 수 있다. 6이 진입할 때 무게는 3이어야 하는데 5가 된 것이다. 3번 트럭이 빠지지 않은 것이 문제인데, 첫번째 조건만 가지고는 이것을 걸러낼 수 없다. 큐에서 원소를 뺄 때, 무게만 고려하는 것이 아니라 현재 in_time시간에 빠져나간 트럭들을 제거해주는 것도 같이 해야한다. 그래서 두번째 조건이 나온 것이다. 큐가 만약에 비어있다면 false를 반환하고, 아니라면 in_time에 나가야하는 트럭이 있는지 유무를 확인한 뒤, 그 원소가 큐에 남아있다면 큐에서 그 원소를 삭제한다. 모든 원소의 진입 시간이 계산되었으니, 정답을 계산한다. 마지막 반복문을 돌 때, in_time이 1 증가되었으니 이를 1줄여주고, 다리 길이를 더하면 정답이다.</p>
<p>이 문제의 시간복잡도를 구하기 힘들어할 수도 있는데, 어렵지 않다. 큐에 들어갔다 나오는 최대 반복을 생각하면 된다. truck_weights의 길이를 n이라 했을 때, 다 들어왔다가 다 나간다해도 2n이다. 따라서 시간복잡도는 <span class="math inline">\(O(n)\)</span>이 된다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/truck_bridge_result.png" width="340" height="400">
</center>
<p><br></p>
<p>이 문제같은 경우 시간을 너무 많이 소요했다. 두번째 조건을 생각하기 힘들었는데, 질문하기에서 누군가가 올려준 테스트케이스 덕분에 통과할 수 있었다.</p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level2</category>
      </categories>
  </entry>
  <entry>
    <title>CSS Math 함수들 &#39;calc, clamp&#39;</title>
    <url>/2021/08/25/css-math-functions/</url>
    <content><![CDATA[<p>이 글의 <span class="exturl" data-url="aHR0cHM6Ly9tb2Rlcm5jc3MuZGV2L3ByYWN0aWNhbC11c2VzLW9mLWNzcy1tYXRoLWZ1bmN0aW9ucy1jYWxjLWNsYW1wLW1pbi1tYXgv">원문<i class="fa fa-external-link-alt"></i></span>을 바탕으로 재해석한 글입니다.</p>
<p>CSS에는 수학적으로 수치를 계산할 수 있는 4가지 함수를 제공한다(<span class="exturl" data-url="aHR0cHM6Ly9jYW5pdXNlLmNvbS9jc3MtbWF0aC1mdW5jdGlvbnM=">IE에선 지원하지 않는다<i class="fa fa-external-link-alt"></i></span>). 자주 쓰이지 않을 순 있지만, 그레이디언트와 색깔에 관함 함수 또는 CSS의 커스텀 프로퍼티들과 조합할 때 유용하다. 그래서 아래 4가지 함수와 예시를 함께 들어보려 한다.</p>
<p><strong>건너 뛰기</strong>: - <a href="#calc()">calc()</a> - <a href="#clamp()">clamp()</a></p>
<h2 id="calc">calc()</h2>
<blockquote>
<p>calc() 사용 목적 : 단위를 가진 값들의 사칙연산을 가능하도록 하는 것이다. 그리고 단위를 혼합해서도 사용할 수 있다.</p>
</blockquote>
<p>예를 들어 뷰포트에서 상단의 네비게이션 영역을 뺀 값을 높이로 설정하고 싶다면 다음과 같이 쓸 수 있다.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span>&#123;</span><br><span class="line">  <span class="attribute">height</span>: <span class="built_in">calc</span>(<span class="number">100vh</span> - <span class="number">60px</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>사용하는 디바이스에 따라 <code>100vh</code>가 동적으로 결정되므로, 디바이스에 따라 높이가 달라진다.</p>
<blockquote>
<p>calc의 장점은 하드 코딩을 피하고, 인라인 스타일을 추가하는 자바스크립트 로직이 줄어드는 것이다.</p>
</blockquote>
<h3 id="calc를-사용한-컬러팔레트-생성">calc()를 사용한 컬러팔레트 생성</h3>
<p><code>hsl()</code>과 같이 사용하면 hue, saturation, lightness에 css varaible을 넣음으로써 더 응집도 있는 컬러 팔레트를 완성시킬 수 있다.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.colors</span> &#123;</span><br><span class="line">  --base-hue: <span class="number">140</span>;</span><br><span class="line">  --saturation: <span class="number">95%</span>;</span><br><span class="line">  --lightness: <span class="number">80%</span>;</span><br><span class="line">  --rotation: <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#222</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.color</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0.25rem</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="built_in">hsl</span>(<span class="built_in">var</span>(--hue), <span class="built_in">var</span>(--saturation), <span class="built_in">var</span>(--lightness));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.color1</span>&#123;</span><br><span class="line">  --hue: <span class="built_in">calc</span>(<span class="built_in">var</span>(--base-hue));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.color2</span> &#123;</span><br><span class="line">  --hue: <span class="built_in">calc</span>(<span class="built_in">var</span>(--base-hue) + <span class="built_in">var</span>(--rotation));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.color3</span> &#123;</span><br><span class="line">  --hue: <span class="built_in">calc</span>(<span class="built_in">var</span>(--base-hue) + <span class="built_in">var</span>(--rotation) * <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="clamp">clamp()</h2>
<blockquote>
<p>clamp()의 사용 목적 : 가능한 값의 범주를 지정한다.</p>
</blockquote>
<p><code>clamp()</code>는 3가지 매개변수(최소값, 이상적인 값, 최고값)를 받는다. 이 함수는 <code>fluid typography</code>에서 유용하다. <code>fluid typography</code>란 스크린 크기에 비례하여 폰트사이즈가 유동적으로 변하는 것이다.</p>
<p>따라서 <code>font-size</code>값에 <code>clamp()</code>를 적용하면 이를 만들 수 있다. 이 함수를 사용하면 폰트 사이즈 크기가 너무 커져 제목이 2줄이 되지 않도록 하고 뷰포트의 사이즈를 과도하게 차지하지 않게 할 수 있다.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="built_in">clamp</span>(<span class="number">1.75rem</span>, <span class="number">4vw</span> + <span class="number">1rem</span>, <span class="number">3rem</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="clamp를-이용한-반응형-패딩">clamp()를 이용한 반응형 패딩</h3>
<p>또 다른 예제로는 반응형 패딩이 있다. 패딩을 퍼센티지로 사용할 경우에는 요소의 너비를 가지고 계산한다. 이와 비슷하게 vw의 개념도 생각해 볼 수 있다. 아래의 코드를 보면 <code>.element</code>를 가진 요소들은 1rem보다 작은 패딩값을 가지지 않게 된다.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.element</span>&#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">1.5rem</span> <span class="built_in">clamp</span>(<span class="number">1rem</span>, <span class="number">5%</span>, <span class="number">3rem</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이를 활용하면 미디어 쿼리를 사용하지 않고도 반응형 패딩을 만들 수 있다.</p>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS Math 함수들 &#39;min, max&#39;</title>
    <url>/2021/08/29/css-math-functions2/</url>
    <content><![CDATA[<p>이 글의 <span class="exturl" data-url="aHR0cHM6Ly9tb2Rlcm5jc3MuZGV2L3ByYWN0aWNhbC11c2VzLW9mLWNzcy1tYXRoLWZ1bmN0aW9ucy1jYWxjLWNsYW1wLW1pbi1tYXgv">원문<i class="fa fa-external-link-alt"></i></span>을 바탕으로 재해석한 글입니다.</p>
<p><strong>건너 뛰기</strong>: - <a href="#min()">min()</a> - <a href="#max()">max()</a></p>
<h2 id="min">min()</h2>
<blockquote>
<p>min() 사용 목적: 최댓값의 한계를 설정할 수 있다.</p>
</blockquote>
<p><code>width(80ch, 100vw)</code>의 경우 80인치와 뷰포트의 너비를 비교하여 더 작은 값을 선택한다.</p>
<h3 id="container클래스를-활용한-예제">.container클래스를 활용한 예제</h3>
<p><code>min()</code>함수 이내에는 계산식을 포함할 수 있다. 따라서 아래와 같이 코드를 작성할 경우, 적절한 좌우 여백을 줄 수 있다.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">min</span>(<span class="number">80ch</span>, <span class="number">100vw</span> - <span class="number">2rem</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>위의 코드의 경우 <code>.container</code>클래스를 가진 요소는 80인치까지 너비를 가질 수 있으며, 뷰포트가 줄어들 경우 양쪽 너비 <code>1rem</code>의 요소를 만들 수 있다.</p>
<p>다른 예시로는 아래 css 코드를 들 수 있다.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">min</span>(<span class="number">40ch</span>, <span class="number">100%</span> - <span class="number">2rem</span>);</span><br><span class="line">  <span class="attribute">margin-right</span>: auto;</span><br><span class="line">  <span class="attribute">margin-left</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>여기서 <code>ch</code> 단위는 글꼴과 관련된 스타일이 모두 적용된 <code>0</code>의 너비를 이야기한다. 이를 활용하면 한 줄에 들어가는 문자의 수를 가늠할 수 있다. 따라서 어떠한 문서를 읽을 때, 좀 더 나은 경험을 제공할 수 있다.</p>
</blockquote>
<p><strong>장점</strong> 미디어 쿼리 없이도 반응형을 제작할 수 있다.</p>
<h3 id="min을-통한-반응형-요소">min()을 통한 반응형 요소</h3>
<p>댓글이나 피드옆에 사용자 프로필이 있는 경우를 생각해보자. 만약 이들의 크기가 화면의 크기에 따라 유동적으로 바뀌어야 할 때 <code>min</code>을 활용할 수 있다. <code>min(64px, 15%, 10vw)</code>를 사용하면 이 요소는 <code>min</code>안에 적힌 3개의 값 모두를 넘어서지 못한다.</p>
<p>이 min함수가 사용된 요소는 <code>64px</code>를 절대 넘어서지 못함과 동시에 최소 <code>15%</code>또는 <code>10vw</code>의 사이즈를 가진다.</p>
<h3 id="min을-사용한-다른-특성">min()을 사용한 다른 특성</h3>
<p><code>min()</code>은 <code>background-size</code>에도 활용될 수 있다. 어떠한 배경 이미지가 유동적으로 확장되고자 할 때 이에 대한 경계를 <code>min()</code>이 지정할 수 있다.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.background-image</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#1F1B1C</span> <span class="built_in">url</span>(<span class="string">https://source.unsplash.com/RapCPd_mJTU/800x800</span>) no-repeat center;</span><br><span class="line">  <span class="attribute">background-size</span>: <span class="built_in">min</span>(<span class="number">600px</span>, <span class="number">100%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이 예시를 보면 이미지가 <code>600px</code>을 넘지 않을 것을 보증한다. 그리고 <code>600px</code>보다 작은 경우에는 알아서 크기를 줄인다.</p>
<h2 id="max">max()</h2>
<blockquote>
<p>max는 반응형 요소에서 최소값의 경계를 지정한다.</p>
</blockquote>
<p><code>max()</code>의 경우 <code>min()</code>의 반대다.</p>
<h2 id="max로-문맥상-여백-주기">max()로 문맥상 여백 주기</h2>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cudzMub3JnL1dBSS9XQ0FHMjIvVW5kZXJzdGFuZGluZy9yZWZsb3cuaHRtbA==">Web Content Accessibility Guidelines (WCAG) Success Criterion 1.4.10<i class="fa fa-external-link-alt"></i></span>에 따르면 사이트를 최대 400%까지 확대할 수 있어야한다. 이때 <code>px</code>과 <code>rem</code>은 표준에 맞지 않는 단위이다.</p>
<p>만약에 <code>1280px</code>사이즈의 데스크톱에 400% 줌을 준다면 뷰포트 너비가 <code>320px</code>로 줄어든다. 이때 모바일에서 이를 한다면, 방향은 가로로 계속 유지된다. 이러한 뷰포트의 축소는 읽기와 상호작용 영역이 감소했음을 의미한다. 더하여 휴대폰에서는 적합한 크기가 확대된 창에서는 훨씬 커보일 수 있다.</p>
<p>이때 쓸 수 있는 것이 <code>max()</code>이다. 원문의 저자는 작은 여백에는 <code>rem</code>단위를 선호한다. 하지만 영역 간의 큰 여백을 줘야하는 경우에는 아래와 같은 코드를 사용한다. 이렇게 하면 뷰포트에 따라 조정이 된다.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.element</span> + <span class="selector-class">.element</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="built_in">max</span>(<span class="number">8vh</span>, <span class="number">2rem</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>뷰포트의 너비가 큰 경우 <code>8vh</code>가 쓰이고 그것보다 작거나 확대된 창에서는 <code>2rem</code>이 적용된다.</p>
<h3 id="max를-활용한-ios-브라우저-자동-줌인-방지">max를 활용한 iOS 브라우저 자동 줌인 방지</h3>
<p>iOS에선 <code>16px</code>보다 작은 입력창을 가지고 있으면 자동으로 줌인이 된다. 이 떄 아래와 같은 코드를 사용하면 이 문제를 해결 할 수 있다.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="built_in">max</span>(<span class="number">16px</span>, <span class="number">1rem</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>max()</code>를 통해 어느 값이던 수용할 수 있고, 최소 <code>16px</code>을 유지할 수 있게 된다.</p>
<h3 id="max를-활용한-포커싱-아웃라인">max()를 활용한 포커싱 아웃라인</h3>
<p><code>max</code>를 활용하면 포커싱 아웃라인에 대한 상대적인 크기를 설정할 수 있다. 아래 코드를 통해 아웃라인의 최소 너비를 <code>2px</code>로 설정하고, <code>em</code>값에 따라 너비가 상대적으로 조절될 수 있다.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  --<span class="attribute">outline</span>-size: <span class="built_in">max</span>(<span class="number">2px</span>, <span class="number">0.08em</span>);</span><br><span class="line">  --<span class="attribute">outline-style</span>: solid;</span><br><span class="line">  --<span class="attribute">outline-color</span>: currentColor;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:focus</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: <span class="built_in">var</span>(--outline-size) <span class="built_in">var</span>(--outline-style) <span class="built_in">var</span>(--outline-color);</span><br><span class="line">  <span class="attribute">outline-offset</span>: <span class="built_in">var</span>(--outline-size);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="max와-타겟-사이즈">max()와 타겟 사이즈</h3>
<p>타겟 사이즈란 말은 <span class="exturl" data-url="aHR0cHM6Ly93d3cudzMub3JnL1dBSS9XQ0FHMjIvVW5kZXJzdGFuZGluZy90YXJnZXQtc2l6ZS1lbmhhbmNlZC5odG1s">WCAG Success Criterion (SC) 2.5.5<i class="fa fa-external-link-alt"></i></span>에 나오며 타겟은 포인터 이벤트를 받을 수 있는 것을 말한다. 곧 나올 WCAG 2.2버전에서는 이런 타겟 사이즈를 최소 <code>44px</code>로 설정할 것을 권고한다.</p>
<p>이 때도 <code>max()</code>를 활용할 수 있다. 만약 프로필을 눌러 프로필 페이지로 이동해야하는 경우 프로필 버튼에 다음과 같은 스타일링을 줄 수 있다.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.icon-button</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="built_in">max</span>(<span class="number">44px</span>, <span class="number">2em</span>);</span><br><span class="line">  <span class="attribute">height</span>: <span class="built_in">max</span>(<span class="number">44px</span>, <span class="number">2em</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="aspect-ratio의-보완책-max">aspect-ratio의 보완책 max()</h3>
<p><code>aspect-ratio</code>를 지원하지 않는 브라우저에서 <code>max()</code>에 높이를 지정하는 방식으로 비슷하게 흉내낼 수 있다.</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">  <span class="comment">/* Fallback for `aspect-ratio` of defining a height */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="built_in">max</span>(<span class="number">18vh</span>, <span class="number">12rem</span>);</span><br><span class="line">  <span class="attribute">object-fit</span>: cover;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* When supported, use `aspect-ratio` */</span></span><br><span class="line"><span class="keyword">@supports</span> (<span class="attribute">aspect-ratio</span>: <span class="number">1</span>) &#123;</span><br><span class="line">  <span class="selector-tag">img</span> &#123;</span><br><span class="line">    aspect-ratio: <span class="built_in">var</span>(--img-ratio);</span><br><span class="line">    <span class="attribute">height</span>: auto;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>nooopener</title>
    <url>/2021/04/21/noopener/</url>
    <content><![CDATA[<h1 id="링크-타입-noopener">링크 타입: noopener</h1>
<p><code>noopener</code>란 <code>a</code>, <code>area</code>, <code>form</code>태그의 <code>rel</code>속성에 들어가는 속성 값이다. 이 값은 새로운 창이 열려있을 때, 기존에 브라우징 되어있는 요소에 접근할 수 없도록 한다.</p>
<blockquote>
<p>A브라우저에서 링크를 타고 B브라우저를 새탭에서 열었을 경우 <code>Window.opener</code>라는 객체가 생기는데, 이걸 통해 B브라우저가 A브라우저를 악의적으로 동작하게 만들 수 있기 때문에 <code>noopener</code>는 이 객체를 생성하지 않고 널값을 반환한다.</p>
</blockquote>
<p>이 값은 특히 신뢰할 수 없는 사이트에 들어갈 때 유용하다. 이 값을 사용하면 <code>Window.opener</code>를 통해서 현재 브라우저에 접근할 수 있는 통로를 차단한다. (이 값을 사용한다는 기본 전제는 <code>Referer</code>HTTP 헤더를 사용한다는 것이다. 리퍼러는 사용자가 어디에서 새 브라우저로 왔는지 url에 보여준다. 이 정보가 명확히 있기 때문에 <code>Window.opener</code>에서 조작할 수 있는건데, <code>noreferrer</code>를 사용한다면 애초에 어디서부터 왔는지 보이지 않기 때문에 <code>noopener</code>를 사용할 이유가 없어진다.)</p>
<p><code>noopener</code>를 사용할 경우 <code>target</code>속성에 기존 속성값이 아닌 임의의 값을 넣으면 <code>_blank</code>처럼 여겨져서 계속 새로운 창을 띄운다.(원래는 프레임 내임으로 탭이 하나 생성되고 링크를 여러번 타도 그 창을 삭제하지 않는 한 새로운 탭이 생성되지 않는다.)</p>
<blockquote>
<p>현재 <code>target="_blank"</code>를 <code>&lt;a&gt;</code>태그에 사용하면 이 값이 암묵적으로 적용된다.</p>
</blockquote>
]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>Docs</category>
        <category>MDN</category>
      </categories>
  </entry>
  <entry>
    <title>수박수박수박수박수박수?</title>
    <url>/2020/12/29/WaterMelon/</url>
    <content><![CDATA[<h2 id="문제정의">문제정의</h2>
<hr />
<p>서로 마주보고 탕수육을 번갈아 말하는 게임을 해본적이 있을 것이다. 이 문제도 딱 그런 느낌이다. 수와 박을 번갈아가면서 n번 말했을 때 문자열을 출력하면 된다.</p>
<h2 id="문제풀이">문제풀이</h2>
<hr />
<p>전체 코드는 다음과 같다. <figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaterMelon</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = <span class="number">3</span>;</span><br><span class="line">        StringBuffer buff = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                buff.append(<span class="string">&quot;수&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                buff.append(<span class="string">&quot;박&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        String answer = buff.toString();</span><br><span class="line">        System.out.print(answer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 0이 첫번째 숫자이자 짝수이므로 0부터 n-1까지 짝수인지 홀수인지 판별하여 수와 박을 버퍼에 붙여준다. 총 시간복잡도는 <span class="math inline">\(O(n)\)</span>이다.</p>
<h2 id="테스트">테스트</h2>
<p><br></p>
<center>
<img src="/images/programmers/watermelon.png" width="400" height="300">
</center>
<p><br></p>
]]></content>
      <categories>
        <category>Problem Solving</category>
        <category>Programmers</category>
        <category>Level1</category>
      </categories>
  </entry>
  <entry>
    <title>noreferrer</title>
    <url>/2021/04/21/noreferrer/</url>
    <content><![CDATA[<h1 id="링크-타입-noreferrer">링크 타입 : noreferrer</h1>
<p><code>noreferrer</code>는 <code>&lt;a&gt;</code>, <code>&lt;area&gt;</code>, <code>&lt;form&gt;</code>의 <code>rel</code> 속성에 쓰는 속성 값이다. 타겟 브라우저로 이동할 때 원 브라우저에 대한 정보(Referer)를 제공하지 않는다. 레퍼러를 제공하지 않기 때문에 새 탭으로 인한 보안 문제가 해결된다. 이런 면에서는 <code>noopener</code>가 쓰인 것과 같은 효과를 볼 수 있다.</p>
]]></content>
      <categories>
        <category>HTML/CSS</category>
        <category>Docs</category>
        <category>MDN</category>
      </categories>
  </entry>
  <entry>
    <title>스토리북 작성 방법</title>
    <url>/2021/08/23/stories/</url>
    <content><![CDATA[<h1 id="스토리북-작성-방법">스토리북 작성 방법</h1>
<p>리액트와 함께 스토리북을 작성해보자. 스토리북을 작성하면 코드 작성에 따라 문서가 자동으로 생성되기 때문에 협업을 하기 편리하다.</p>
<p>일단 컴포넌트를 아래와 같이 작성하였다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; string, oneOf &#125; <span class="keyword">from</span> <span class="string">&#x27;prop-types&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> HomeLink = <span class="function">(<span class="params">&#123;<span class="keyword">as</span>:Comp, lang, className, children, ...restProps&#125;</span>) =&gt;</span>&#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="xml"><span class="tag">&lt;&gt;</span> </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">Comp</span> <span class="attr">lang</span> = <span class="string">&#123;lang&#125;</span> <span class="attr">className</span> = <span class="string">&#123;className&#125;</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span> =<span class="string">&quot;www.google.co.kr&quot;</span>&gt;</span>&#123;children&#125;<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">Comp</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/&gt;</span></span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">HomeLink.defaultProps = &#123;</span><br><span class="line">    <span class="keyword">as</span> : <span class="string">&#x27;h1&#x27;</span>,</span><br><span class="line">    lang: <span class="string">&#x27;en&#x27;</span>,</span><br><span class="line">    className: string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">HomeLink.propTypes = &#123;</span><br><span class="line">    <span class="comment">/** 제목 요소를 설정합니다. */</span></span><br><span class="line">    <span class="keyword">as</span>: oneOf([<span class="string">&#x27;h1&#x27;</span>,<span class="string">&#x27;h2&#x27;</span>,<span class="string">&#x27;h3&#x27;</span>,<span class="string">&#x27;h4&#x27;</span>,<span class="string">&#x27;h5&#x27;</span>,<span class="string">&#x27;h6&#x27;</span>]),</span><br><span class="line">    <span class="comment">/** 언어를 지정할 수 있습니다. (스크린 리더 음성 변경 됨) */</span></span><br><span class="line">    lang: oneOf([<span class="string">&#x27;en&#x27;</span>, <span class="string">&#x27;ko&#x27;</span>]),</span><br><span class="line">    <span class="comment">/** 클래스 이름을 추가할 수 있습니다. */</span></span><br><span class="line">    className: string,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> HomeLink;</span><br></pre></td></tr></table></figure>
<p>여기서 기본값인 <code>defaultProps</code>를 작성하고 props에 대한 타입을 지정하기 위해 <code>propTypes</code>를 설정한다. 타입스크립트의 경우 이부분은 생략할 수 있다. 만든 컴포넌트는 다시 내보낸다.</p>
<p>이제 만든 파일에 대한 스토리를 작성한다. 스토리 파일은 아래와 같이 작성할 수 있다.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> HomeLink <span class="keyword">from</span> <span class="string">&quot;./HomeLink&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Logo &#125; <span class="keyword">from</span> <span class="string">&quot;components&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    title: <span class="string">&#x27;Components/UI/HomeLink&#x27;</span>,</span><br><span class="line">    component: HomeLink,</span><br><span class="line">    parameters:&#123;</span><br><span class="line">        docs: &#123;</span><br><span class="line">            description:&#123;</span><br><span class="line">                component: <span class="string">&#x27;홈 링크 입니다.&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">    &#125;,</span><br><span class="line">    argTypes: &#123;</span><br><span class="line">        children:&#123;</span><br><span class="line">            table: &#123;<span class="attr">disable</span>: <span class="literal">true</span>&#125;,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Template = <span class="function">(<span class="params">args</span>) =&gt;</span> <span class="xml"><span class="tag">&lt;<span class="name">HomeLink</span> &#123;<span class="attr">...args</span>&#125;/&gt;</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Img = Template.bind(&#123;&#125;);</span><br><span class="line">Img.args = &#123;<span class="attr">as</span>: <span class="string">&#x27;h1&#x27;</span>, <span class="attr">children</span>:<span class="xml"><span class="tag">&lt;<span class="name">Logo</span>&gt;</span><span class="tag">&lt;/<span class="name">Logo</span>&gt;</span></span>&#125;;</span><br><span class="line">Img.storyName = <span class="string">&#x27;홈 링크 (이미지)&#x27;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Text = Template.bind(&#123;&#125;);</span><br><span class="line">Text.args = &#123;<span class="attr">as</span>: <span class="string">&#x27;h1&#x27;</span>, <span class="attr">children</span>:<span class="string">&#x27;111&#x27;</span>&#125;;</span><br><span class="line">Text.storyName = <span class="string">&#x27;홈 링크 (텍스트)&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>같은 경로에 <code>HomeLink.stories.js</code>를 생성하고 스토리 파일을 작성한다. <code>export default</code>안에 있는 블럭은 각각 다음과 같다.</p>
<ul>
<li><code>title</code> : 스토리 파일 내에서 경로 설정</li>
<li><code>componenet</code> : 해당 컴포넌트에 대한 설명</li>
<li><code>table</code> : 스토리북 내에서 props의 표시 유무를 설정하는 값. 기본적으론 <code>false</code>이며 이 값이 <code>true</code>로 변경하는 경우 스토리북 내에서 해당 props가 보이지 않게 된다.</li>
</ul>
<p>props값에 따라 컴포넌트가 어떻게 변화하는지 보고 싶은 경우에는 템플릿을 작성하여 이를 보여줄 수 있다. <code>Template</code>를 선언하고 여기에 객체를 바인딩하여 내가 전달하고자 하는 props를 매개변수로 전달한다. 이 때 <code>storyName</code>을 통해 스토리북 내에서 표시될 이름을 설정할 수 있다.</p>
]]></content>
  </entry>
</search>
